{"./":{"url":"./","title":"Introduction","keywords":"","body":"articles this is blog! "},"SUMMARY.html":{"url":"SUMMARY.html","title":"SUMMARY","keywords":"","body":"Summary Introduction SUMMARY MySQL学习 初识数据库 MySQL库操作 MySQL表操作 1、MySQL表操作 2、MySQL存储引擎 3、MySQLl数据类型 4、完整性约束 5、多表查询之补充 MySQL数据操作 1、MySQL数据操作 2、单表查询 3、多表查询 4、MySQL逻辑查询语句执行顺序 5、多表查询解析 Python3连接MySQL python Django初识 Web框架本质及第一个Django实例 HTTP协议 Django框架简介 Django的视图 Django的路由系统 Django模板系统 Django模型ORM Django路由系统 ORM相关操作 ORM版学员管理系统 Form组件 博客项目点赞与灭操作 博客项目评论 luffy结算中心 "},"MySQL学习/":{"url":"MySQL学习/","title":"MySQL学习","keywords":"","body":"articles 一、初识数据库 Python3连接MySQL "},"MySQL学习/01-初识数据库.html":{"url":"MySQL学习/01-初识数据库.html","title":"初识数据库","keywords":"","body":"一 、数据库管理软件的由来 基于我们之前所学，数据要想永久保存，都是保存于文件中，毫无疑问，一个文件仅仅只能存在于某一台机器上。 如果我们暂且忽略直接基于文件来存取数据的效率问题，并且假设程序所有的组件都运行在一台机器上，那么用文件存取数据，并没有问题。 很不幸，这些假设都是你自己意淫出来的，上述假设存在以下几个问题。。。。。。 1、程序所有的组件就不可能运行在一台机器上 因为这台机器一旦挂掉则意味着整个软件的崩溃，并且程序的执行效率依赖于承载它的硬件， 而一台机器机器的性能总归是有限的，受限于目前的硬件水平，就一台机器的性能垂直进行 扩展是有极限的。 于是我们只能通过水平扩展来增强我们系统的整体性能，这就需要我们将程序的各个组件分布 于多台机器去执行。 2、数据安全问题 根据1的描述，我们将程序的各个组件分布到各台机器，但需知各组件仍然是一个整体， 言外之意，所有组件的数据还是要共享的。但每台机器上的组件都只能操作本机的文件， 这就导致了数据必然不一致。 于是我们想到了将数据与应用程序分离：把文件存放于一台机器，然后将多台机器通过 网络去访问这台机器上的文件（用socket实现），即共享这台机器上的文件,共享则意味 着竞争，会发生数据不安全，需要加锁处理。。。。 3、并发 根据2的描述，我们必须写一个socket服务端来管理这台机器（数据库服务器）上的文件， 然后写一个socket客户端，完成如下功能： #1.远程连接（支持并发） #2.打开文件 #3.读写（加锁） #4.关闭文件 总结： 我们在编写任何程序之前，都需要事先写好基于网络操作一台主机上文件的程序（socket 服务端与客户端程序），于是有人将此类程序写成一个专门的处理软件，这就是mysql等 数据库管理软件的由来，但mysql解决的不仅仅是数据共享的问题，还有查询效率， 安全性等一系列问题，总之，把程序员从数据管理中解脱出来，专注于自己的程序 逻辑的编写。 二 数据库概述 1 什么是数据（Data） 描述事物的符号记录称为数据，描述事物的符号既可以是数字，也可以是文字、图片，图像、声音、语言等，数据由多种表现形式，它们都可以经过数字化后存入计算机 在计算机中描述一个事物，就需要抽取这一事物的典型特征，组成一条记录，就相当于文件里的一行内容，如： 1 egon,male,18,1999,山东,计算机系,2017,oldboy 单纯的一条记录并没有任何意义，如果我们按逗号作为分隔，依次定义各个字段的意思，相当于定义表的标题 1 name,sex,age,birth,born_addr,major,entrance_time,school #字段 2 egon,male,18,1999,山东,计算机系,2017,oldboy #记录 2 什么是数据库（DataBase，简称DB） 数据库即存放数据的仓库，只不过这个仓库是在计算机存储设备上，而且数据是按一定的格式存放的 过去人们将数据存放在文件柜里，现在数据量庞大，已经不再适用 数据库是长期存放在计算机内、有组织、可共享的数据即可。 数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种 用户共享 3 什么是数据库管理系统（DataBase Management System 简称DBMS） 在了解了Data与DB的概念后，如何科学地组织和存储数据，如何高效获取和维护数据成了关键 这就用到了一个系统软件---数据库管理系统 如MySQL、Oracle、SQLite、Access、MS SQL Server mysql主要用于大型门户，例如搜狗、新浪等，它主要的优势就是开放源代码，因为开放源代码这个数据库是免费的，他现在是甲骨文公司的产品。 oracle主要用于银行、铁路、飞机场等。该数据库功能强大，软件费用高。也是甲骨文公司的产品。 sql server是微软公司的产品，主要应用于大中型企业，如联想、方正等。 4 数据库服务器、数据管理系统、数据库、表与记录的关系（重点理解！！！） 记录：1 刘海龙 324245234 22（多个字段的信息组成一条记录，即文件中的一行内容） 表：student,scholl,class_list（即文件） 数据库：oldboy_stu（即文件夹） 数据库管理系统：如mysql（是一个软件） 数据库服务器：一台计算机（对内存要求比较高） 总结： 数据库服务器-：运行数据库管理软件 数据库管理软件：管理-数据库 数据库：即文件夹，用来组织文件/表 表：即文件，用来存放多行内容/多条记录 5 数据库管理技术的发展历程(了解) 一 人工管理阶段 20世纪50年代中期以前，计算机主要用于科学计算。 当时的硬件水平：外存只有纸带、卡片、磁带，没有磁盘等直接存取的存储设备 当时的软件状况：没有操作系统，没有管理数据的软件，数据的处理方式是批处理。 人工管理数据具有以下特点： 1 数据不保存：计算机主要用于科学计算，数据临时用，临时输入，不保存 2 应用程序管理数据：数据要有应用程序自己管理，应用程序需要处理数据的逻辑+物理结构，开发负担很重 3 数据不共享：一组数据只对应一个程序，多个程序之间涉及相同数据时，必须各自定义，造成数据大量冗余 4 数据不具有独立性：数据的逻辑结构或物理结构发生变化后，必须对应用程序做出相应的修改，开发负担进一步加大 "},"MySQL学习/02-MySQL库操作.html":{"url":"MySQL学习/02-MySQL库操作.html","title":"MySQL库操作","keywords":"","body":"二、MySQL库操作 一 系统数据库 information_schema： 虚拟库，不占用磁盘空间，存储的是数据库启动后的一些参数，如用户表信息、列信息、权限信息、字符信息等 performance_schema： MySQL 5.5开始新增一个数据库：主要用于收集数据库服务器性能参数，记录处理查询请求时发生的各种事件、锁等现象 mysql： 授权库，主要存储系统用户的权限信息 test： MySQL数据库系统自动创建的测试数据库 二 创建数据库 1 语法(help create database) CREATE DATABASE 数据库名 charset utf8; 2 数据库命名规则： 可以由字母、数字、下划线、＠、＃、＄ 区分大小写 唯一性 不能使用关键字如 create select 不能单独使用数字 最长128位 三 数据库相关操作 查看数据库 show databases; show create database db1; select database(); 选择数据库 USE 数据库名 删除数据库 DROP DATABASE 数据库名; 修改数据库 alter database db1 charset utf8; "},"MySQL学习/03-MySQL表操作/":{"url":"MySQL学习/03-MySQL表操作/","title":"MySQL表操作","keywords":"","body":"├─03-MySQL表操作 │ 1、MySQL表操作.md │ 2、MySQL存储引擎.md │ 3、MySQLl数据类型.md │ 4、完整性约束.md "},"MySQL学习/03-MySQL表操作/1、MySQL表操作.html":{"url":"MySQL学习/03-MySQL表操作/1、MySQL表操作.html","title":"1、MySQL表操作","keywords":"","body":"1、MySQL表操作 一 存储引擎介绍 存储引擎即表类型，mysql根据不同的表类型会有不同的处理机制 desc 二 表介绍 表相当于文件，表中的一条记录就相当于文件的一行内容，不同的是，表中的一条记录有对应的标题，称为表的字段id，name，qq，age称为字段，其余的，一行内容称为一条记录 三 创建表 #语法： create table 表名( 字段名1 类型[(宽度) 约束条件], 字段名2 类型[(宽度) 约束条件], 字段名3 类型[(宽度) 约束条件] ); #注意： 1. 在同一张表中，字段名是不能相同 2. 宽度和约束条件可选 3. 字段名和类型是必须的 # 往表中插入数据 MariaDB [(none)]> create database db1 charset utf8; MariaDB [(none)]> use db1; MariaDB [db1]> create table t1( -> id int, -> name varchar(50), -> sex enum('male','female'), -> age int(3) -> ); MariaDB [db1]> show tables; #查看db1库下所有表名 MariaDB [db1]> desc t1; +-------+-----------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-----------------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(50) | YES | | NULL | | | sex | enum('male','female') | YES | | NULL | | | age | int(3) | YES | | NULL | | +-------+-----------------------+------+-----+---------+-------+ MariaDB [db1]> select id,name,sex,age from t1; Empty set (0.00 sec) MariaDB [db1]> select * from t1; Empty set (0.00 sec) MariaDB [db1]> select id,name from t1; Empty set (0.00 sec) MariaDB [db1]> insert into t1 values -> (1,'egon',18,'male'), -> (2,'alex',81,'female') -> ; MariaDB [db1]> select * from t1; +------+------+------+--------+ | id | name | age | sex | +------+------+------+--------+ | 1 | egon | 18 | male | | 2 | alex | 81 | female | +------+------+------+--------+ MariaDB [db1]> insert into t1(id) values -> (3), -> (4); MariaDB [db1]> select * from t1; +------+------+------+--------+ | id | name | age | sex | +------+------+------+--------+ | 1 | egon | 18 | male | | 2 | alex | 81 | female | | 3 | NULL | NULL | NULL | | 4 | NULL | NULL | NULL | +------+------+------+--------+ 注意注意注意：表中的最后一个字段不要加逗号 四 查看表结构 MariaDB [db1]> describe t1; #查看表结构，可简写为desc 表名 +-------+-----------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-----------------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(50) | YES | | NULL | | | sex | enum('male','female') | YES | | NULL | | | age | int(3) | YES | | NULL | | +-------+-----------------------+------+-----+---------+-------+ MariaDB [db1]> show create table t1\\G; #查看表详细结构，可加\\G 五 数据类型 5 六 表完整性约束 6 七 修改表ALTER TABLE 1. 修改表名 ALTER TABLE 表名 RENAME 新表名; 2. 增加字段 ALTER TABLE 表名 ADD 字段名 数据类型 [完整性约束条件…], ADD 字段名 数据类型 [完整性约束条件…]; ALTER TABLE 表名 ADD 字段名 数据类型 [完整性约束条件…] FIRST; ALTER TABLE 表名 ADD 字段名 数据类型 [完整性约束条件…] AFTER 字段名; 3. 删除字段 ALTER TABLE 表名 DROP 字段名; 4. 修改字段 ALTER TABLE 表名 MODIFY 字段名 数据类型 [完整性约束条件…]; ALTER TABLE 表名 CHANGE 旧字段名 新字段名 旧数据类型 [完整性约束条件…]; ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型 [完整性约束条件…]; # 示例： # 1. 修改存储引擎 mysql> alter table service -> engine=innodb; 2. 添加字段 mysql> alter table student10 -> add name varchar(20) not null, -> add age int(3) not null default 22; mysql> alter table student10 -> add stu_num varchar(10) not null after name; //添加name字段之后 mysql> alter table student10 -> add sex enum('male','female') default 'male' first; //添加到最前面 3. 删除字段 mysql> alter table student10 -> drop sex; mysql> alter table service -> drop mac; 4. 修改字段类型modify mysql> alter table student10 -> modify age int(3); mysql> alter table student10 -> modify id int(11) not null primary key auto_increment; //修改为主键 5. 增加约束（针对已有的主键增加auto_increment） mysql> alter table student10 modify id int(11) not null primary key auto_increment; ERROR 1068 (42000): Multiple primary key defined mysql> alter table student10 modify id int(11) not null auto_increment; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 6. 对已经存在的表增加复合主键 mysql> alter table service2 -> add primary key(host_ip,port); 7. 增加主键 mysql> alter table student1 -> modify name varchar(10) not null primary key; 8. 增加主键和自动增长 mysql> alter table student1 -> modify id int not null primary key auto_increment; 9. 删除主键 a. 删除自增约束 mysql> alter table student10 modify id int(11) not null; b. 删除主键 mysql> alter table student10 -> drop primary key; 八 复制表 -- 复制表结构'＋'记录 (key不会复制: 主键、外键和索引) mysql> create table new_service select * from service; --只复制表结构 mysql> select * from service where 1=2; // 条件为假，查不到任何记录 Empty set (0.00 sec) mysql> create table new1_service select * from service where 1=2; Query OK, 0 rows affected (0.00 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> create table t4 like employees; 九 删除表 DROP TABLE 表名; "},"MySQL学习/03-MySQL表操作/2、MySQL存储引擎.html":{"url":"MySQL学习/03-MySQL表操作/2、MySQL存储引擎.html","title":"2、MySQL存储引擎","keywords":"","body":"2、MySQL存储引擎 一 什么是存储引擎 mysql中建立的库===>文件夹 库中建立的表===>文件 现实生活中我们用来存储数据的文件有不同的类型，每种文件类型对应各自不同的处理机制：比如处理文本用txt类型，处理表格用excel，处理图片用png等 数据库中的表也应该有不同的类型，表的类型不同，会对应mysql不同的存取机制，表类型又称为存储引擎。 存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方 法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和 操作此表的类型） 在Oracle 和SQL Server等数据库中只有一种存储引擎，所有数据存储管理机制都是一样的。而MySql 数据库提供了多种存储引擎。用户可以根据不同的需求为数据表选择不同的存储引擎，用户也可以根据 自己的需要编写自己的存储引擎 SQL 解析器、SQL 优化器、缓冲池、存储引擎等组件在每个数据库中都存在,但不是每 个数据库都有这么多存储引擎。MySQL 的插件式存储引擎可以让存储引擎层的开发人员设 计他们希望的存储层,例如,有的应用需要满足事务的要求,有的应用则不需要对事务有这 么强的要求 ;有的希望数据能持久存储,有的只希望放在内存中,临时并快速地提供对数据 的查询。 二 mysql支持的存储引擎 #查看正在使用的存储引擎 MariaDB [(none)]> show engines\\G #查看所有支持的存储引擎 MariaDB [(none)]> show variables like 'storage_engine%'; MySQL存储引擎介绍 #InnoDB 存储引擎 支持事务,其设计目标主要面向联机事务处理(OLTP)的应用。其 特点是行锁设计、支持外键,并支持类似 Oracle 的非锁定读,即默认读取操作不会产生锁。 从 MySQL 5.5.8 版本开始是默认的存储引擎。 InnoDB 存储引擎将数据放在一个逻辑的表空间中,这个表空间就像黑盒一样由 InnoDB 存储引擎自身来管理。从 MySQL 4.1(包括 4.1)版本开始,可以将每个 InnoDB 存储引擎的 表单独存放到一个独立的 ibd 文件中。此外,InnoDB 存储引擎支持将裸设备(row disk)用 于建立其表空间。 InnoDB 通过使用多版本并发控制(MVCC)来获得高并发性,并且实现了 SQL 标准 的 4 种隔离级别,默认为 REPEATABLE 级别,同时使用一种称为 netx-key locking 的策略来 避免幻读(phantom)现象的产生。除此之外,InnoDB 存储引擎还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead) 等高性能和高可用的功能。 对于表中数据的存储,InnoDB 存储引擎采用了聚集(clustered)的方式,每张表都是按 主键的顺序进行存储的,如果没有显式地在表定义时指定主键,InnoDB 存储引擎会为每一 行生成一个 6 字节的 ROWID,并以此作为主键。 InnoDB 存储引擎是 MySQL 数据库最为常用的一种引擎,Facebook、Google、Yahoo 等 公司的成功应用已经证明了 InnoDB 存储引擎具备高可用性、高性能以及高可扩展性。对其 底层实现的掌握和理解也需要时间和技术的积累。如果想深入了解 InnoDB 存储引擎的工作 原理、实现和应用,可以参考《MySQL 技术内幕:InnoDB 存储引擎》一书。 #MyISAM 存储引擎 不支持事务、表锁设计、支持全文索引,主要面向一些 OLAP 数 据库应用,在 MySQL 5.5.8 版本之前是默认的存储引擎(除 Windows 版本外)。数据库系统 与文件系统一个很大的不同在于对事务的支持,MyISAM 存储引擎是不支持事务的。究其根 本,这也并不难理解。用户在所有的应用中是否都需要事务呢?在数据仓库中,如果没有 ETL 这些操作,只是简单地通过报表查询还需要事务的支持吗?此外,MyISAM 存储引擎的 另一个与众不同的地方是,它的缓冲池只缓存(cache)索引文件,而不缓存数据文件,这与 大多数的数据库都不相同。 #NDB 存储引擎 年,MySQL AB 公司从 Sony Ericsson 公司收购了 NDB 存储引擎。 NDB 存储引擎是一个集群存储引擎,类似于 Oracle 的 RAC 集群,不过与 Oracle RAC 的 share everything 结构不同的是,其结构是 share nothing 的集群架构,因此能提供更高级别的 高可用性。NDB 存储引擎的特点是数据全部放在内存中(从 5.1 版本开始,可以将非索引数 据放在磁盘上),因此主键查找(primary key lookups)的速度极快,并且能够在线添加 NDB 数据存储节点(data node)以便线性地提高数据库性能。由此可见,NDB 存储引擎是高可用、 高性能、高可扩展性的数据库集群系统,其面向的也是 OLTP 的数据库应用类型。 #Memory 存储引擎 正如其名,Memory 存储引擎中的数据都存放在内存中,数据库重 启或发生崩溃,表中的数据都将消失。它非常适合于存储 OLTP 数据库应用中临时数据的临时表,也可以作为 OLAP 数据库应用中数据仓库的维度表。Memory 存储引擎默认使用哈希 索引,而不是通常熟悉的 B+ 树索引。 #Infobright 存储引擎 第三方的存储引擎。其特点是存储是按照列而非行的,因此非常 适合 OLAP 的数据库应用。其官方网站是 http://www.infobright.org/,上面有不少成功的数据 仓库案例可供分析。 #NTSE 存储引擎 网易公司开发的面向其内部使用的存储引擎。目前的版本不支持事务, 但提供压缩、行级缓存等特性,不久的将来会实现面向内存的事务支持。 #BLACKHOLE 黑洞存储引擎，可以应用于主备复制中的分发主库。 MySQL 数据库还有很多其他存储引擎,上述只是列举了最为常用的一些引擎。如果 你喜欢,完全可以编写专属于自己的引擎,这就是开源赋予我们的能力,也是开源的魅 力所在。 三 使用存储引擎 方法1：建表时指定 MariaDB [db1]> creat table innodb_t1(id int,name char)engine=innodb; MariaDB [db1]> create table innodb_t2(id int)engine=innodb; MariaDB [db1]> show create table innodb_t1; MariaDB [db1]> show create table innodb_t2; 方法2：在配置文件中指定默认的存储引擎 /etc/my.cnf [mysqld] default-storage-engine=INNODB innodb_file_per_table=1 查看 [root@egon db1]# cd /var/lib/mysql/db1/ [root@egon db1]# ls db.opt innodb_t1.frm innodb_t1.ibd innodb_t2.frm innodb_t2.ibd 创建四个表，分别使用innodb，myisam，memory，blackhole存储引擎，进行插入数据测试 MariaDB [db1]> create table t1(id int)engine=innodb; MariaDB [db1]> create table t2(id int)engine=myisam; MariaDB [db1]> create table t3(id int)engine=memory; MariaDB [db1]> create table t4(id int)engine=blackhole; MariaDB [db1]> quit [root@egon db1]# ls /var/lib/mysql/db1/ #发现后两种存储引擎只有表结构，无数据 db.opt t1.frm t1.ibd t2.MYD t2.MYI t2.frm t3.frm t4.frm #memory，在重启mysql或者重启机器后，表内数据清空 #blackhole，往表内插入任何数据，都相当于丢入黑洞，表内永远不存记录 "},"MySQL学习/03-MySQL表操作/3、MySQLl数据类型.html":{"url":"MySQL学习/03-MySQL表操作/3、MySQLl数据类型.html","title":"3、MySQLl数据类型","keywords":"","body":"3、MySQL数据类型 一 介绍 存储引擎决定了表的类型，而表内存放的数据也要有不同的类型，每种数据类型都有自己的宽度，但宽度是可选的 详细参考： http://www.runoob.com/mysql/mysql-data-types.html http://dev.mysql.com/doc/refman/5.7/en/data-type-overview.html mysql常用数据类型概览 #1. 数字： 整型：tinyinit int bigint 小数： float ：在位数比较短的情况下不精准 double ：在位数比较长的情况下不精准 0.000001230123123123 存成：0.000001230000 decimal：（如果用小数，则用推荐使用decimal） 精准 内部原理是以字符串形式去存 #2. 字符串： char（10）：简单粗暴，浪费空间，存取速度快 root存成root000000 varchar：精准，节省空间，存取速度慢 sql优化：创建表时，定长的类型往前放，变长的往后放 比如性别 比如地址或描述信息 >255个字符，超了就把文件路径存放到数据库中。 比如图片，视频等找一个文件服务器，数据库中只存路径或url。 #3. 时间类型： 最常用：datetime #4. 枚举类型与集合类型 二 数值类型 1、整数类型 整数类型：TINYINT SMALLINT MEDIUMINT INT BIGINT 作用：存储年龄，等级，id，各种号码等 ======================================== tinyint[(m)] [unsigned] [zerofill] 小整数，数据类型用于保存一些范围的整数数值范围： 有符号： -128 ～ 127 无符号： ～ 255 PS： MySQL中无布尔值，使用tinyint(1)构造。 ======================================== int[(m)][unsigned][zerofill] 整数，数据类型用于保存一些范围的整数数值范围： 有符号： -2147483648 ～ 2147483647 无符号： ～ 4294967295 ======================================== bigint[(m)][unsigned][zerofill] 大整数，数据类型用于保存一些范围的整数数值范围： 有符号： -9223372036854775808 ～ 9223372036854775807 无符号： ～ 18446744073709551615 =========有符号和无符号tinyint========== #tinyint默认为有符号 MariaDB [db1]> create table t1(x tinyint); #默认为有符号，即数字前有正负号 MariaDB [db1]> desc t1; MariaDB [db1]> insert into t1 values -> (-129), -> (-128), -> (127), -> (128); MariaDB [db1]> select * from t1; +------+ | x | +------+ | -128 | #-129存成了-128 | -128 | #有符号，最小值为-128 | 127 | #有符号，最大值127 | 127 | #128存成了127 +------+ #设置无符号tinyint MariaDB [db1]> create table t2(x tinyint unsigned); MariaDB [db1]> insert into t2 values -> (-1), -> (0), -> (255), -> (256); MariaDB [db1]> select * from t2; +------+ | x | +------+ | 0 | -1存成了0 | 0 | #无符号，最小值为0 | 255 | #无符号，最大值为255 | 255 | #256存成了255 +------+ ============有符号和无符号int============= #int默认为有符号 MariaDB [db1]> create table t3(x int); #默认为有符号整数 MariaDB [db1]> insert into t3 values -> (-2147483649), -> (-2147483648), -> (2147483647), -> (2147483648); MariaDB [db1]> select * from t3; +-------------+ | x | +-------------+ | -2147483648 | #-2147483649存成了-2147483648 | -2147483648 | #有符号，最小值为-2147483648 | 2147483647 | #有符号，最大值为2147483647 | 2147483647 | #2147483648存成了2147483647 +-------------+ #设置无符号int MariaDB [db1]> create table t4(x int unsigned); MariaDB [db1]> insert into t4 values -> (-1), -> (0), -> (4294967295), -> (4294967296); MariaDB [db1]> select * from t4; +------------+ | x | +------------+ | 0 | #-1存成了0 | 0 | #无符号，最小值为0 | 4294967295 | #无符号，最大值为4294967295 | 4294967295 | #4294967296存成了4294967295 +------------+ ==============有符号和无符号bigint============= MariaDB [db1]> create table t6(x bigint); MariaDB [db1]> insert into t5 values -> (-9223372036854775809), -> (-9223372036854775808), -> (9223372036854775807), -> (9223372036854775808); MariaDB [db1]> select * from t5; +----------------------+ | x | +----------------------+ | -9223372036854775808 | | -9223372036854775808 | | 9223372036854775807 | | 9223372036854775807 | +----------------------+ MariaDB [db1]> create table t6(x bigint unsigned); MariaDB [db1]> insert into t6 values -> (-1), -> (0), -> (18446744073709551615), -> (18446744073709551616); MariaDB [db1]> select * from t6; +----------------------+ | x | +----------------------+ | 0 | | 0 | | 18446744073709551615 | | 18446744073709551615 | +----------------------+ ======用zerofill测试整数类型的显示宽度============= MariaDB [db1]> create table t7(x int(3) zerofill); MariaDB [db1]> insert into t7 values -> (1), -> (11), -> (111), -> (1111); MariaDB [db1]> select * from t7; +------+ | x | +------+ | 001 | | 011 | | 111 | | 1111 | #超过宽度限制仍然可以存 +------+ 注意：为该类型指定宽度时，仅仅只是指定查询结果的显示宽度，与存储范围无关，存储范围如下 其实我们完全没必要为整数类型指定显示宽度，使用默认的就可以了 默认的显示宽度，都是在最大值的基础上加1 \bint的存储宽度是4个Bytes，即32个bit，即2**32 无符号最大值为：4294967296-1 有符号最大值：2147483648-1 有符号和无符号的最大数字需要的显示宽度均为10，而针对有符号的最小值则需要11位才能显示完全，所以int类型默认的显示宽度为11是非常合理的 最后：整形类型，其实没有必要指定显示宽度，使用默认的就ok 2、浮点型 定点数类型 DEC等同于DECIMAL　　 浮点类型：FLOAT DOUBLE 作用：存储薪资、身高、体重、体质参数等 ====================================== #FLOAT[(M,D)] [UNSIGNED] [ZEROFILL] 定义： 单精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。m最大值为255，d最大值为30 有符号： -3.402823466E+38 to -1.175494351E-38, 1.175494351E-38 to 3.402823466E+38 无符号： 1.175494351E-38 to 3.402823466E+38 精确度： **** 随着小数的增多，精度变得不准确 **** ====================================== #DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL] 定义： 双精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。m最大值为255，d最大值为30 有符号： -1.7976931348623157E+308 to -2.2250738585072014E-308 2.2250738585072014E-308 to 1.7976931348623157E+308 无符号： 2.2250738585072014E-308 to 1.7976931348623157E+308 精确度： ****随着小数的增多，精度比float要高，但也会变得不准确 **** ====================================== decimal[(m[,d])] [unsigned] [zerofill] 定义： 准确的小数值，m是数字总个数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。 精确度： **** 随着小数的增多，精度始终准确 **** 对于精确数值计算时需要用此类型 decaimal能够存储精确值的原因在于其内部按照字符串存储。 mysql> create table t1(x float(256,31)); ERROR 1425 (42000): Too big scale 31 specified for column 'x'. Maximum is 30. mysql> create table t1(x float(256,30)); ERROR 1439 (42000): Display width out of range for column 'x' (max = 255) mysql> create table t1(x float(255,30)); #建表成功 Query OK, 0 rows affected (0.02 sec) mysql> create table t2(x double(255,30)); #建表成功 Query OK, 0 rows affected (0.02 sec) mysql> create table t3(x decimal(66,31)); ERROR 1425 (42000): Too big scale 31 specified for column 'x'. Maximum is 30. mysql> create table t3(x decimal(66,30)); ERROR 1426 (42000): Too-big precision 66 specified for 'x'. Maximum is 65. mysql> create table t3(x decimal(65,30)); #建表成功 Query OK, 0 rows affected (0.02 sec) mysql> show tables; +---------------+ | Tables_in_db1 | +---------------+ | t1 | | t2 | | t3 | +---------------+ rows in set (0.00 sec) mysql> insert into t1 values(1.1111111111111111111111111111111); #小数点后31个1 Query OK, 1 row affected (0.01 sec) mysql> insert into t2 values(1.1111111111111111111111111111111); Query OK, 1 row affected (0.00 sec) mysql> insert into t3 values(1.1111111111111111111111111111111); Query OK, 1 row affected, 1 warning (0.01 sec) mysql> select * from t1; #随着小数的增多，精度开始不准确 +----------------------------------+ | x | +----------------------------------+ | 1.111111164093017600000000000000 | +----------------------------------+ row in set (0.00 sec) mysql> select * from t2; #精度比float要准确点，但随着小数的增多，同样变得不准确 +----------------------------------+ | x | +----------------------------------+ | 1.111111111111111200000000000000 | +----------------------------------+ row in set (0.00 sec) mysql> select * from t3; #精度始终准确,d为30，于是只留了30位小数 +----------------------------------+ | x | +----------------------------------+ | 1.111111111111111111111111111111 | +----------------------------------+ row in set (0.00 sec) 3、位类型（了解） BIT(M)可以用来存放多位二进制数，M范围从1~64，如果不写默认为1位。 注意：对于位字段需要使用函数读取 bin()显示为二进制 hex()显示为十六进制 DATE TIME DATETIME TIMESTAMP YEAR 作用：存储用户注册时间，文章发布时间，员工入职时间，出生时间，过期时间等 YEAR YYYY（1901/2155） DATE YYYY-MM-DD（1000-01-01/9999-12-31） TIME HH:MM:SS（'-838:59:59'/'838:59:59'） DATETIME YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00/9999-12-31 23:59:59 Y） TIMESTAMP YYYYMMDD HHMMSS（1970-01-01 00:00:00/2037 年某时） ============year=========== MariaDB [db1]> create table t10(born_year year); #无论year指定何种宽度，最后都默认是year(4) MariaDB [db1]> insert into t10 values -> (1900), -> (1901), -> (2155), -> (2156); MariaDB [db1]> select * from t10; +-----------+ | born_year | +-----------+ | 0000 | | 1901 | | 2155 | | 0000 | +-----------+ ============date,time,datetime=========== MariaDB [db1]> create table t11(d date,t time,dt datetime); MariaDB [db1]> desc t11; +-------+----------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+----------+------+-----+---------+-------+ | d | date | YES | | NULL | | | t | time | YES | | NULL | | | dt | datetime | YES | | NULL | | +-------+----------+------+-----+---------+-------+ MariaDB [db1]> insert into t11 values(now(),now(),now()); MariaDB [db1]> select * from t11; +------------+----------+---------------------+ | d | t | dt | +------------+----------+---------------------+ | 2017-07-25 | 16:26:54 | 2017-07-25 16:26:54 | +------------+----------+---------------------+ ============timestamp=========== MariaDB [db1]> create table t12(time timestamp); MariaDB [db1]> insert into t12 values(); MariaDB [db1]> insert into t12 values(null); MariaDB [db1]> select * from t12; +---------------------+ | time | +---------------------+ | 2017-07-25 16:29:17 | | 2017-07-25 16:30:01 | +---------------------+ ============注意啦，注意啦，注意啦=========== 1. 单独插入时间时，需要以字符串的形式，按照对应的格式插入 2. 插入年份时，尽量使用4位值 3. 插入两位年份时，=70，以19开头，比如71，结果1971 MariaDB [db1]> create table t12(y year); MariaDB [db1]> insert into t12 values -> (50), -> (71); MariaDB [db1]> select * from t12; +------+ | y | +------+ | 2050 | | 1971 | +------+ ============综合练习=========== MariaDB [db1]> create table student( -> id int, -> name varchar(20), -> born_year year, -> birth date, -> class_time time, -> reg_time datetime); MariaDB [db1]> insert into student values -> (1,'alex',\"1995\",\"1995-11-11\",\"11:11:11\",\"2017-11-11 11:11:11\"), -> (2,'egon',\"1997\",\"1997-12-12\",\"12:12:12\",\"2017-12-12 12:12:12\"), -> (3,'wsb',\"1998\",\"1998-01-01\",\"13:13:13\",\"2017-01-01 13:13:13\"); MariaDB [db1]> select * from student; +------+------+-----------+------------+------------+---------------------+ | id | name | born_year | birth | class_time | reg_time | +------+------+-----------+------------+------------+---------------------+ | 1 | alex | 1995 | 1995-11-11 | 11:11:11 | 2017-11-11 11:11:11 | | 2 | egon | 1997 | 1997-12-12 | 12:12:12 | 2017-12-12 12:12:12 | | 3 | wsb | 1998 | 1998-01-01 | 13:13:13 | 2017-01-01 13:13:13 | +------+------+-----------+------------+------------+---------------------+ datetime与timestamp的区别 在实际应用的很多场景中，MySQL的这两种日期类型都能够满足我们的需要，存储精度都为秒，但在某些情况下，会展现出他们各自的优劣。下面就来总结一下两种日期类型的区别。 1.DATETIME的日期范围是1001——9999年，TIMESTAMP的时间范围是1970——2038年。 2.DATETIME存储时间与时区无关，TIMESTAMP存储时间与时区有关，显示的值也依赖于时区。在mysql服务器，操作系统以及客户端连接都有时区的设置。 3.DATETIME使用8字节的存储空间，TIMESTAMP的存储空间为4字节。因此，TIMESTAMP比DATETIME的空间利用率更高。 4.DATETIME的默认值为null；TIMESTAMP的字段默认不为空（not null）,默认值为当前时间（CURRENT_TIMESTAMP），如果不做特殊处理，并且update语句中没有指定该列的更新值，则默认更新为当前时间。 四 字符串类型 #官网：https://dev.mysql.com/doc/refman/5.7/en/char.html #注意：char和varchar括号内的参数指的都是字符的长度 #char类型：定长，简单粗暴，浪费空间，存取速度快 字符长度范围：0-255（一个中文是一个字符，是utf8编码的3个字节） 存储： 存储char类型的值时，会往右填充空格来满足长度 例如：指定长度为10，存>10个字符则报错，存255bytes则需要2Bytes的前缀（2Bytes=16bit 2**16最大表示的数字为65535） 检索： 尾部有空格会保存下来，在检索或者说查询时，也会正常显示包含空格在内的内容 #官网：https://dev.mysql.com/doc/refman/5.7/en/char.html CHAR 和 VARCHAR 是最常使用的两种字符串类型。 一般来说 CHAR(N)用来保存固定长度的字符串，对于 CHAR 类型,N 的范围 为 0 ~ 255 VARCHAR(N)用来保存变长字符类型，对于 VARCHAR 类型,N 的范围为 0 ~ 65 535 CHAR(N)和 VARCHAR(N) 中的 N 都代表字符长度,而非字节长度。 ps：对于 MySQL 4.1 之前的版本,如 MySQL 3.23 和 MySQL 4.0,CHAR(N)和 VARCHAR (N)中的 N 代表字节长度。 #CHAR类型 对于 CHAR 类型的字符串,MySQL 数据库会自动对存储列的右边进行填充(Right Padded)操作,直到字符串达到指定的长度 N。而在读取该列时,MySQL 数据库会自动将 填充的字符删除。有一种情况例外,那就是显式地将 SQL_MODE 设置为 PAD_CHAR_TO_ FULL_LENGTH,例如: mysql> CREATE TABLE t ( a CHAR(10)); Query OK, 0 rows affected (0.03 sec) mysql> INSERT INTO t SELECT 'abc'; Query OK, 1 row affected (0.03 sec) Records: 1 Duplicates: 0 Warnings: 0 mysql> SELECT a,HEX(a),LENGTH(a) FROM t\\G; *************************** 1. row *************************** a: abc HEX(a): 616263 LENGTH (a): 3 row in set (0.00 sec) mysql> SET SQL_MODE='PAD_CHAR_TO_FULL_LENGTH'; Query OK, 0 rows affected (0.00 sec) mysql> SELECT a,HEX(a),LENGTH(a) FROM t\\G; *************************** 1. row *************************** a: abc HEX(a): 61626320202020202020 LENGTH (a): 10 row in set (0.00 sec) 在上述这个例子中,先创建了一张表 t,a 列的类型为 CHAR(10)。然后通过 INSERT语句插入值“abc”,因为 a 列的类型为 CHAR 型,所以会自动在后面填充空字符串,使其长 度为 10。接下来在通过 SELECT 语句取出数据时会将 a 列右填充的空字符移除,从而得到 值“abc”。通过 LENGTH 函数看到 a 列的字符长度为 3 而非 10。 接着我们将 SQL_MODE 显式地设置为 PAD_CHAR_TO_FULL_LENGTH。这时再通过 SELECT 语句进行查询时,得到的结果是“abc ”,abc 右边有 7 个填充字符 0x20,并通 过 HEX 函数得到了验证。这次 LENGTH 函数返回的长度为 10。需要注意的是,LENGTH 函数返回的是字节长度,而不是字符长度。对于多字节字符集,CHAR(N)长度的列最多 可占用的字节数为该字符集单字符最大占用字节数 *N。例如,对于 utf8 下,CHAR(10)最 多可能占用 30 个字节。通过对多字节字符串使用 CHAR_LENGTH 函数和 LENGTH 函数, 可以发现两者的不同,示例如下: mysql> SET NAMES gbk; Query OK, 0 rows affected (0.03 sec) mysql> SELECT @a:='MySQL 技术内幕 '; -- Query OK, 0 rows affected (0.03 sec) mysql> SELECT @a,HEX(@a),LENGTH(@a),CHAR_LENGTH(@a)\\G; ***************************** 1. row **************************** a: MySQL 技术内幕 HEX(a): 4D7953514CBCBCCAF5C4DAC4BB LENGTH (a): 13 CHAR_LENGTH(a): 9 row in set (0.00 sec) 变 量 @ a 是 g b k 字 符 集 的 字 符 串 类 型 , 值 为 “ M y S Q L 技 术 内 幕 ”, 十 六 进 制 为 0x4D7953514CBCBCCAF5C4DAC4BB,LENGTH 函数返回 13,即该字符串占用 13 字节, 因为 gbk 字符集中的中文字符占用两个字节,因此一共占用 13 字节。CHAR_LENGTH 函数 返回 9,很显然该字符长度为 9。 #VARCHAR类型 VARCHAR 类型存储变长字段的字符类型,与 CHAR 类型不同的是,其存储时需要在 前缀长度列表加上实际存储的字符,该字符占用 1 ~ 2 字节的空间。当存储的字符串长度小 于 255 字节时,其需要 1 字节的空间,当大于 255 字节时,需要 2 字节的空间。所以,对 于单字节的 latin1 来说,CHAR(10)和 VARCHAR(10)最大占用的存储空间是不同的, CHAR(10)占用 10 个字节这是毫无疑问的,而 VARCHAR(10)的最大占用空间数是 11 字节,因为其需要 1 字节来存放字符长度。 ------------------------------------------------- 注意 对于有些多字节的字符集类型,其 CHAR 和 VARCHAR 在存储方法上是一样的,同样 需要为长度列表加上字符串的值。对于 GBK 和 UTF-8 这些字符类型,其有些字符是以 1 字节 存放的,有些字符是按 2 或 3 字节存放的,因此同样需要 1 ~ 2 字节的空间来存储字符的长 度。 ------------------------------------------------- 虽然 CHAR 和 VARCHAR 的存储方式不太相同,但是对于两个字符串的比较,都只比 较其值,忽略 CHAR 值存在的右填充,即使将 SQL _MODE 设置为 PAD_CHAR_TO_FULL_ LENGTH 也一样,例如: mysql> CREATE TABLE t ( a CHAR(10), b VARCHAR(10)); Query OK, 0 rows affected (0.01 sec) mysql> INSERT INTO t SELECT 'a','a'; Query OK, 1 row affected (0.00 sec) Records: 1 Duplicates: 0 Warnings: 0 mysql> SELECT a=b FROM t\\G; *************************** 1. row *************************** a=b: 1 row in set (0.00 sec) mysql> SET SQL_MODE='PAD_CHAR_TO_FULL_LENGTH'; Query OK, 0 rows affected (0.00 sec) mysql> SELECT a=b FROM t\\G; *************************** 1. row *************************** a=b: 1 row in set (0.00 sec) Value CHAR(4) Storage Required VARCHAR(4) Storage Required 'ab' 'ab ' 4 bytes 'ab' 3 bytes 'abcd' 'abcd' 4 bytes 'abcd' 5 bytes 'abcdefgh' 'abcd' 4 bytes 'abcd' 5 bytes 测试前了解两个函数 length：查看字节数 char_length:查看字符数 1. char填充空格来满足固定长度，但是在查询时却会很不要脸地删除尾部的空格（装作自己好像没有浪费过空间一样），然后修改sql_mode让其现出原形 mysql> create table t1(x char(5),y varchar(5)); Query OK, 0 rows affected (0.26 sec) #char存5个字符，而varchar存4个字符 mysql> insert into t1 values('你瞅啥 ','你瞅啥 '); Query OK, 1 row affected (0.05 sec) mysql> SET sql_mode=''; Query OK, 0 rows affected, 1 warning (0.00 sec) #在检索时char很不要脸地将自己浪费的2个字符给删掉了，装的好像自己没浪费过空间一样，而varchar很老实，存了多少，就显示多少 mysql> select x,char_length(x),y,char_length(y) from t1; +-----------+----------------+------------+----------------+ | x | char_length(x) | y | char_length(y) | +-----------+----------------+------------+----------------+ | 你瞅啥 | 3 | 你瞅啥 | 4 | +-----------+----------------+------------+----------------+ row in set (0.00 sec) #略施小计，让char现出原形 mysql> SET sql_mode = 'PAD_CHAR_TO_FULL_LENGTH'; Query OK, 0 rows affected (0.00 sec) #这下子char原形毕露了...... mysql> select x,char_length(x),y,char_length(y) from t1; +-------------+----------------+------------+----------------+ | x | char_length(x) | y | char_length(y) | +-------------+----------------+------------+----------------+ | 你瞅啥 | 5 | 你瞅啥 | 4 | +-------------+----------------+------------+----------------+ row in set (0.00 sec) #char类型：3个中文字符+2个空格=11Bytes #varchar类型:3个中文字符+1个空格=10Bytes mysql> select x,length(x),y,length(y) from t1; +-------------+-----------+------------+-----------+ | x | length(x) | y | length(y) | +-------------+-----------+------------+-----------+ | 你瞅啥 | 11 | 你瞅啥 | 10 | +-------------+-----------+------------+-----------+ row in set (0.00 sec) 了解concat mysql> select concat('数据: ',x,'长度: ',char_length(x)),concat(y,char_length(y) ) from t1; +------------------------------------------------+--------------------------+ | concat('数据: ',x,'长度: ',char_length(x)) | concat(y,char_length(y)) | +------------------------------------------------+--------------------------+ | 数据: 你瞅啥 长度: 5 | 你瞅啥 4 | +------------------------------------------------+--------------------------+ row in set (0.00 sec) 点击查看关于sql_mode的详细介绍 2. 虽然 CHAR 和 VARCHAR 的存储方式不太相同,但是对于两个字符串的比较,都只比 较其值,忽略 CHAR 值存在的右填充,即使将 SQL _MODE 设置为 PAD_CHAR_TO_FULL_ LENGTH 也一样,,但这不适用于like Values in CHAR and VARCHAR columns are sorted and compared according to the character set collation assigned to the column. All MySQL collations are of type PAD SPACE. This means that all CHAR, VARCHAR, and TEXT values are compared without regard to any trailing spaces. “Comparison” in this context does not include the LIKE pattern-matching operator, for which trailing spaces are significant. For example: mysql> CREATE TABLE names (myname CHAR(10)); Query OK, 0 rows affected (0.03 sec) mysql> INSERT INTO names VALUES ('Monty'); Query OK, 1 row affected (0.00 sec) mysql> SELECT myname = 'Monty', myname = 'Monty ' FROM names; +------------------+--------------------+ | myname = 'Monty' | myname = 'Monty ' | +------------------+--------------------+ | 1 | 1 | +------------------+--------------------+ row in set (0.00 sec) mysql> SELECT myname LIKE 'Monty', myname LIKE 'Monty ' FROM names; +---------------------+-----------------------+ | myname LIKE 'Monty' | myname LIKE 'Monty ' | +---------------------+-----------------------+ | 1 | 0 | +---------------------+-----------------------+ row in set (0.00 sec) 3.总结 #常用字符串系列：char与varchar 注：虽然varchar使用起来较为灵活，但是从整个系统的性能角度来说，char数据类型的处理速度更快，有时甚至可以超出varchar处理速度的50%。因此，用户在设计数据库时应当综合考虑各方面的因素，以求达到最佳的平衡 #其他字符串系列（效率：char>varchar>text） TEXT系列 TINYTEXT TEXT MEDIUMTEXT LONGTEXT BLOB 系列 TINYBLOB BLOB MEDIUMBLOB LONGBLOB BINARY系列 BINARY VARBINARY text：text数据类型用于保存变长的大字符串，可以组多到65535 (2**16 − 1)个字符。 mediumtext：A TEXT column with a maximum length of 16,777,215 (2**24 − 1) characters. longtext：A TEXT column with a maximum length of 4,294,967,295 or 4GB (2**32 − 1) characters. 五 枚举类型与集合类型 字段的值只能在给定范围中选择，如单选框，多选框 enum 单选 只能在给定的范围内选一个值，如性别 sex 男male/女female set 多选 在给定的范围内可以选择一个或一个以上的值（爱好1,爱好2,爱好3...） 枚举类型（enum） An ENUM column can have a maximum of 65,535 distinct elements. (The practical limit is less than 3000.) 示例： CREATE TABLE shirts ( name VARCHAR(40), size ENUM('x-small', 'small', 'medium', 'large', 'x-large') ); INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),('polo shirt','small'); 集合类型（set） A SET column can have a maximum of 64 distinct members. 示例： CREATE TABLE myset (col SET('a', 'b', 'c', 'd')); INSERT INTO myset (col) VALUES ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d'); MariaDB [db1]> create table consumer( -> name varchar(50), -> sex enum('male','female'), -> level enum('vip1','vip2','vip3','vip4','vip5'), #在指定范围内，多选一 -> hobby set('play','music','read','study') #在指定范围内，多选多 -> ); MariaDB [db1]> insert into consumer values -> ('egon','male','vip5','read,study'), -> ('alex','female','vip1','girl'); MariaDB [db1]> select * from consumer; +------+--------+-------+------------+ | name | sex | level | hobby | +------+--------+-------+------------+ | egon | male | vip5 | read,study | | alex | female | vip1 | | +------+--------+-------+------------+ "},"MySQL学习/03-MySQL表操作/4、完整性约束.html":{"url":"MySQL学习/03-MySQL表操作/4、完整性约束.html","title":"4、完整性约束","keywords":"","body":"4、完整性约束 一 介绍 约束条件与数据类型的宽度一样，都是可选参数 作用：用于保证数据的完整性和一致性 主要分为： PRIMARY KEY (PK) 标识该字段为该表的主键，可以唯一的标识记录 FOREIGN KEY (FK) 标识该字段为该表的外键 NOT NULL 标识该字段不能为空 UNIQUE KEY (UK) 标识该字段的值是唯一的 AUTO_INCREMENT 标识该字段的值自动增长（整数类型，而且为主键） DEFAULT 为该字段设置默认值 UNSIGNED 无符号 ZEROFILL 使用0填充 说明： 1. 是否允许为空，默认NULL，可设置NOT NULL，字段不允许为空，必须赋值 2. 字段是否有默认值，缺省的默认值是NULL，如果插入记录时不给字段赋值，此字段使用默认值 sex enum('male','female') not null default 'male' age int unsigned NOT NULL default 20 必须为正值（无符号） 不允许为空 默认是20 3. 是否是key 主键 primary key 外键 foreign key 索引 (index,unique...) 二 not null与default 是否可空，null表示空，非字符串 not null - 不可空 null - 可空 默认值，创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值 create table tb1( nid int not null defalut 2, num int not null ) 验证 ==================not null==================== mysql> create table t1(id int); -- id字段默认可以插入空 mysql> desc t1; +-------+---------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+---------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | +-------+---------+------+-----+---------+-------+ mysql> insert into t1 values(); -- 可以插入空 mysql> create table t2(id int not null); #设置字段id不为空 mysql> desc t2; +-------+---------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+---------+------+-----+---------+-------+ | id | int(11) | NO | | NULL | | +-------+---------+------+-----+---------+-------+ mysql> insert into t2 values(); #不能插入空 ERROR 1364 (HY000): Field 'id' doesn't have a default value ==================default==================== #设置id字段有默认值后，则无论id字段是null还是not null，都可以插入空，插入空默认填入default指定的默认值 mysql> create table t3(id int default 1); mysql> alter table t3 modify id int not null default 1; ==================综合练习==================== mysql> create table student( -> name varchar(20) not null, -> age int(3) unsigned not null default 18, -> sex enum('male','female') default 'male', -> hobby set('play','study','read','music') default 'play,music' -> ); mysql> desc student; +-------+------------------------------------+------+-----+------------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+------------------------------------+------+-----+------------+-------+ | name | varchar(20) | NO | | NULL | | | age | int(3) unsigned | NO | | 18 | | | sex | enum('male','female') | YES | | male | | | hobby | set('play','study','read','music') | YES | | play,music | | +-------+------------------------------------+------+-----+------------+-------+ mysql> insert into student(name) values('egon'); mysql> select * from student; +------+-----+------+------------+ | name | age | sex | hobby | +------+-----+------+------------+ | egon | 18 | male | play,music | +------+-----+------+------------+ 三 unique ============设置唯一约束 UNIQUE=============== 方法一： create table department1( id int, name varchar(20) unique, comment varchar(100) ); 方法二： create table department2( id int, name varchar(20), comment varchar(100), constraint uk_name unique(name) ); mysql> insert into department1 values(1,'IT','技术'); Query OK, 1 row affected (0.00 sec) mysql> insert into department1 values(1,'IT','技术'); ERROR 1062 (23000): Duplicate entry 'IT' for key 'name' not null+unique的化学反应 mysql> create table t1(id int not null unique); Query OK, 0 rows affected (0.02 sec) mysql> desc t1; +-------+---------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+---------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | +-------+---------+------+-----+---------+-------+ row in set (0.00 sec) create table service( id int primary key auto_increment, name varchar(20), host varchar(15) not null, port int not null, unique(host,port) --- 联合唯一 ); mysql> insert into service values -> (1,'nginx','192.168.0.10',80), -> (2,'haproxy','192.168.0.20',80), -> (3,'mysql','192.168.0.30',3306) -> ; Query OK, 3 rows affected (0.01 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql> insert into service(name,host,port) values('nginx','192.168.0.10',80); ERROR 1062 (23000): Duplicate entry '192.168.0.10-80' for key 'host' 四 primary key 从约束角度看primary key字段的值不为空且唯一，那我们直接使用not null+unique不就可以了吗，要它干什么？ 主键primary key是innodb存储引擎组织数据的依据，innodb称之为索引组织表，一张表中必须有且只有一个主键。 一个表中可以： 单列做主键 多列做主键（复合主键） ============单列做主键=============== #方法一：not null+unique create table department1( id int not null unique, #主键 name varchar(20) not null unique, comment varchar(100) ); mysql> desc department1; +---------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +---------+--------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(20) | NO | UNI | NULL | | | comment | varchar(100) | YES | | NULL | | +---------+--------------+------+-----+---------+-------+ rows in set (0.01 sec) #方法二：在某一个字段后用primary key create table department2( id int primary key, #主键 name varchar(20), comment varchar(100) ); mysql> desc department2; +---------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +---------+--------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(20) | YES | | NULL | | | comment | varchar(100) | YES | | NULL | | +---------+--------------+------+-----+---------+-------+ rows in set (0.00 sec) #方法三：在所有字段后单独定义primary key create table department3( id int, name varchar(20), comment varchar(100), constraint pk_name primary key(id); #创建主键并为其命名pk_name mysql> desc department3; +---------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +---------+--------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(20) | YES | | NULL | | | comment | varchar(100) | YES | | NULL | | +---------+--------------+------+-----+---------+-------+ rows in set (0.01 sec) ==================多列做主键================ create table service( ip varchar(15), port char(5), service_name varchar(10) not null, primary key(ip,port) ); mysql> desc service; +--------------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------------+-------------+------+-----+---------+-------+ | ip | varchar(15) | NO | PRI | NULL | | | port | char(5) | NO | PRI | NULL | | | service_name | varchar(10) | NO | | NULL | | +--------------+-------------+------+-----+---------+-------+ rows in set (0.00 sec) mysql> insert into service values -> ('172.16.45.10','3306','mysqld'), -> ('172.16.45.11','3306','mariadb') -> ; Query OK, 2 rows affected (0.00 sec) Records: 2 Duplicates: 0 Warnings: 0 mysql> insert into service values ('172.16.45.10','3306','nginx'); ERROR 1062 (23000): Duplicate entry '172.16.45.10-3306' for key 'PRIMARY' 五 auto_increment 约束字段为自动增长，被约束的字段必须同时被key约束 #不指定id，则自动增长 create table student( id int primary key auto_increment, name varchar(20), sex enum('male','female') default 'male' ); mysql> desc student; +-------+-----------------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +-------+-----------------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | name | varchar(20) | YES | | NULL | | | sex | enum('male','female') | YES | | male | | +-------+-----------------------+------+-----+---------+----------------+ mysql> insert into student(name) values -> ('egon'), -> ('alex') -> ; mysql> select * from student; +----+------+------+ | id | name | sex | +----+------+------+ | 1 | egon | male | | 2 | alex | male | +----+------+------+ #也可以指定id mysql> insert into student values(4,'asb','female'); Query OK, 1 row affected (0.00 sec) mysql> insert into student values(7,'wsb','female'); Query OK, 1 row affected (0.00 sec) mysql> select * from student; +----+------+--------+ | id | name | sex | +----+------+--------+ | 1 | egon | male | | 2 | alex | male | | 4 | asb | female | | 7 | wsb | female | +----+------+--------+ #对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长 mysql> delete from student; Query OK, 4 rows affected (0.00 sec) mysql> select * from student; Empty set (0.00 sec) mysql> insert into student(name) values('ysb'); mysql> select * from student; +----+------+------+ | id | name | sex | +----+------+------+ | 8 | ysb | male | +----+------+------+ #应该用truncate清空表，比起delete一条一条地删除记录，truncate是直接清空表，在删除大表时用它 mysql> truncate student; Query OK, 0 rows affected (0.01 sec) mysql> insert into student(name) values('egon'); Query OK, 1 row affected (0.01 sec) mysql> select * from student; +----+------+------+ | id | name | sex | +----+------+------+ | 1 | egon | male | +----+------+------+ row in set (0.00 sec) #在创建完表后，修改自增字段的起始值 mysql> create table student( -> id int primary key auto_increment, -> name varchar(20), -> sex enum('male','female') default 'male' -> ); mysql> alter table student auto_increment=3; mysql> show create table student; ....... ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 mysql> insert into student(name) values('egon'); Query OK, 1 row affected (0.01 sec) mysql> select * from student; +----+------+------+ | id | name | sex | +----+------+------+ | 3 | egon | male | +----+------+------+ row in set (0.00 sec) mysql> show create table student; ....... ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 #也可以创建表时指定auto_increment的初始值，注意初始值的设置为表选项，应该放到括号外 create table student( id int primary key auto_increment, name varchar(20), sex enum('male','female') default 'male' )auto_increment=3; #设置步长 sqlserver：自增步长 基于表级别 create table t1（ id int。。。 ）engine=innodb,auto_increment=2 步长=2 default charset=utf8 mysql自增的步长： show session variables like 'auto_inc%'; #基于会话级别 set session auth_increment_increment=2 #修改会话级别的步长 #基于全局级别的 set global auth_increment_increment=2 #修改全局级别的步长（所有会话都生效） #！！！注意了注意了注意了！！！ If the value of auto_increment_offset is greater than that of auto_increment_increment, the value of auto_increment_offset is ignored. 翻译：如果auto_increment_offset的值大于auto_increment_increment的值，则auto_increment_offset的值会被忽略 ，这相当于第一步步子就迈大了，扯着了蛋 比如：设置auto_increment_offset=3，auto_increment_increment=2 mysql> set global auto_increment_increment=5; Query OK, 0 rows affected (0.00 sec) mysql> set global auto_increment_offset=3; Query OK, 0 rows affected (0.00 sec) mysql> show variables like 'auto_incre%'; #需要退出重新登录 +--------------------------+-------+ | Variable_name | Value | +--------------------------+-------+ | auto_increment_increment | 1 | | auto_increment_offset | 1 | +--------------------------+-------+ create table student( id int primary key auto_increment, name varchar(20), sex enum('male','female') default 'male' ); mysql> insert into student(name) values('egon1'),('egon2'),('egon3'); mysql> select * from student; +----+-------+------+ | id | name | sex | +----+-------+------+ | 3 | egon1 | male | | 8 | egon2 | male | | 13 | egon3 | male | +----+-------+------+ 六 foreign key 一 快速理解foreign key 员工信息表有三个字段：工号 姓名 部门 公司有3个部门，但是有1个亿的员工，那意味着部门这个字段需要重复存储，部门名字越长，越浪费 解决方法： 我们完全可以定义一个部门表 然后让员工信息表关联该表，如何关联，即foreign key #表类型必须是innodb存储引擎，且被关联的字段，即references指定的另外一个表的字段，必须保证唯一 create table department( id int primary key, name varchar(20) not null )engine=innodb; #dpt_id外键，关联父表（department主键id），同步更新，同步删除 create table employee( id int primary key, name varchar(20) not null, dpt_id int, constraint fk_name foreign key(dpt_id) references department(id) on delete cascade on update cascade )engine=innodb; #先往父表department中插入记录 insert into department values (1,'欧德博爱技术有限事业部'), (2,'艾利克斯人力资源部'), (3,'销售部'); #再往子表employee中插入记录 insert into employee values (1,'egon',1), (2,'alex1',2), (3,'alex2',2), (4,'alex3',2), (5,'李坦克',3), (6,'刘飞机',3), (7,'张火箭',3), (8,'林子弹',3), (9,'加特林',3) ; #删父表department，子表employee中对应的记录跟着删 mysql> delete from department where id=3; mysql> select * from employee; +----+-------+--------+ | id | name | dpt_id | +----+-------+--------+ | 1 | egon | 1 | | 2 | alex1 | 2 | | 3 | alex2 | 2 | | 4 | alex3 | 2 | +----+-------+--------+ #更新父表department，子表employee中对应的记录跟着改 mysql> update department set id=22222 where id=2; mysql> select * from employee; +----+-------+--------+ | id | name | dpt_id | +----+-------+--------+ | 1 | egon | 1 | | 3 | alex2 | 22222 | | 4 | alex3 | 22222 | | 5 | alex1 | 22222 | +----+-------+--------+ 二 如何找出两张表之间的关系 分析步骤： #1、先站在左表的角度去找 是否左表的多条记录可以对应右表的一条记录，如果是，则证明左表的一个字段foreign key 右表一个字段（通常是id） #2、再站在右表的角度去找 是否右表的多条记录可以对应左表的一条记录，如果是，则证明右表的一个字段foreign key 左表一个字段（通常是id） #3、总结： #多对一： 如果只有步骤1成立，则是左表多对一右表 如果只有步骤2成立，则是右表多对一左表 #多对多 如果步骤1和2同时成立，则证明这两张表时一个双向的多对一，即多对多,需要定义一个这两张表的关系表来专门存放二者的关系 #一对一: 如果1和2都不成立，而是左表的一条记录唯一对应右表的一条记录，反之亦然。这种情况很简单，就是在左表foreign key右表的基础上，将左表的外键字段设置成unique即可 三 建立表之间的关系 #一对多或称为多对一 三张表：出版社，作者信息，书 一对多（或多对一）：一个出版社可以出版多本书 关联方式：foreign key =====================多对一===================== create table press( id int primary key auto_increment, name varchar(20) ); create table book( id int primary key auto_increment, name varchar(20), press_id int not null, foreign key(press_id) references press(id) on delete cascade on update cascade ); insert into press(name) values ('北京工业地雷出版社'), ('人民音乐不好听出版社'), ('知识产权没有用出版社') ; insert into book(name,press_id) values ('九阳神功',1), ('九阴真经',2), ('九阴白骨爪',2), ('独孤九剑',3), ('降龙十巴掌',2), ('葵花宝典',3) ; 一夫多妻制 #妻子表的丈夫id外键到丈夫表的id #多对多 三张表：出版社，作者信息，书 多对多：一个作者可以写多本书，一本书也可以有多个作者，双向的一对多，即多对多 　　 关联方式：foreign key+一张新的表 =====================多对多===================== create table author( id int primary key auto_increment, name varchar(20) ); #这张表就存放作者表与书表的关系，即查询二者的关系查这表就可以了 create table author2book( id int not null unique auto_increment, author_id int not null, book_id int not null, constraint fk_author foreign key(author_id) references author(id) on delete cascade on update cascade, constraint fk_book foreign key(book_id) references book(id) on delete cascade on update cascade, primary key(author_id,book_id) ); #插入四个作者，id依次排开 insert into author(name) values('egon'),('alex'),('yuanhao'),('wpq'); #每个作者与自己的代表作如下 egon: 九阳神功 九阴真经 九阴白骨爪 独孤九剑 降龙十巴掌 葵花宝典 alex: 九阳神功 葵花宝典 yuanhao: 独孤九剑 降龙十巴掌 葵花宝典 wpq: 九阳神功 insert into author2book(author_id,book_id) values (1,1), (1,2), (1,3), (1,4), (1,5), (1,6), (2,1), (2,6), (3,4), (3,5), (3,6), (4,1) ; 单张表：用户表+相亲关系表，相当于：用户表+相亲关系表+用户表 多张表：用户表+用户与主机关系表+主机表 中间那一张存放关系的表，对外关联的字段可以联合唯一 #一对一 两张表：学生表和客户表 一对一：一个学生是一个客户，一个客户有可能变成一个学校，即一对一的关系 关联方式：foreign key+unique #一定是student来foreign key表customer，这样就保证了： #1 学生一定是一个客户， #2 客户不一定是学生，但有可能成为一个学生 create table customer( id int primary key auto_increment, name varchar(20) not null, qq varchar(10) not null, phone char(16) not null ); create table student( id int primary key auto_increment, class_name varchar(20) not null, customer_id int unique, #该字段一定要是唯一的 foreign key(customer_id) references customer(id) #外键的字段一定要保证unique on delete cascade on update cascade ); #增加客户 insert into customer(name,qq,phone) values ('李飞机','31811231',13811341220), ('王大炮','123123123',15213146809), ('守榴弹','283818181',1867141331), ('吴坦克','283818181',1851143312), ('赢火箭','888818181',1861243314), ('战地雷','112312312',18811431230) ; #增加学生 insert into student(class_name,customer_id) values ('脱产3班',3), ('周末19期',4), ('周末19期',5) ; 其他例子 例一：一个用户只有一个博客 用户表： id name egon alex wupeiqi 博客表 fk+unique id url name_id xxxx 1 yyyy 3 zzz 2 例二：一个管理员唯一对应一个用户 用户表： id user password egon xxxx alex yyyy 管理员表： fk+unique id user_id password 1 xxxxx 2 yyyyy 七 作业 练习：账号信息表，用户组，主机表，主机组 #用户表 create table user( id int not null unique auto_increment, username varchar(20) not null, password varchar(50) not null, primary key(username,password) ); insert into user(username,password) values ('root','123'), ('egon','456'), ('alex','alex3714') ; #用户组表 create table usergroup( id int primary key auto_increment, groupname varchar(20) not null unique ); insert into usergroup(groupname) values ('IT'), ('Sale'), ('Finance'), ('boss') ; #主机表 create table host( id int primary key auto_increment, ip char(15) not null unique default '127.0.0.1' ); insert into host(ip) values ('172.16.45.2'), ('172.16.31.10'), ('172.16.45.3'), ('172.16.31.11'), ('172.10.45.3'), ('172.10.45.4'), ('172.10.45.5'), ('192.168.1.20'), ('192.168.1.21'), ('192.168.1.22'), ('192.168.2.23'), ('192.168.2.223'), ('192.168.2.24'), ('192.168.3.22'), ('192.168.3.23'), ('192.168.3.24') ; #业务线表 create table business( id int primary key auto_increment, business varchar(20) not null unique ); insert into business(business) values ('轻松贷'), ('随便花'), ('大富翁'), ('穷一生') ; #建关系：user与usergroup create table user2usergroup( id int not null unique auto_increment, user_id int not null, group_id int not null, primary key(user_id,group_id), foreign key(user_id) references user(id), foreign key(group_id) references usergroup(id) ); insert into user2usergroup(user_id,group_id) values (1,1), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4) ; #建关系：host与business create table host2business( id int not null unique auto_increment, host_id int not null, business_id int not null, primary key(host_id,business_id), foreign key(host_id) references host(id), foreign key(business_id) references business(id) ); insert into host2business(host_id,business_id) values (1,1), (1,2), (1,3), (2,2), (2,3), (3,4) ; #建关系：user与host create table user2host( id int not null unique auto_increment, user_id int not null, host_id int not null, primary key(user_id,host_id), foreign key(user_id) references user(id), foreign key(host_id) references host(id) ); insert into user2host(user_id,host_id) values (1,1), (1,2), (1,3), (1,4), (1,5), (1,6), (1,7), (1,8), (1,9), (1,10), (1,11), (1,12), (1,13), (1,14), (1,15), (1,16), (2,2), (2,3), (2,4), (2,5), (3,10), (3,11), (3,12) ; "},"MySQL学习/03-MySQL表操作/5、多表查询之补充.html":{"url":"MySQL学习/03-MySQL表操作/5、多表查询之补充.html","title":"5、多表查询之补充","keywords":"","body":"MySQL 之 多表查询 一.多表联合查询 #创建部门 CREATE TABLE IF NOT EXISTS dept ( did int not null auto_increment PRIMARY KEY, dname VARCHAR(50) not null COMMENT '部门名称' )ENGINE=INNODB DEFAULT charset utf8; #添加部门数据 INSERT INTO `dept` VALUES ('1', '教学部'); INSERT INTO `dept` VALUES ('2', '销售部'); INSERT INTO `dept` VALUES ('3', '市场部'); INSERT INTO `dept` VALUES ('4', '人事部'); INSERT INTO `dept` VALUES ('5', '鼓励部'); -- 创建人员 DROP TABLE IF EXISTS `person`; CREATE TABLE `person` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(50) NOT NULL, `age` tinyint(4) DEFAULT '0', `sex` enum('男','女','人妖') NOT NULL DEFAULT '人妖', `salary` decimal(10,2) NOT NULL DEFAULT '250.00', `hire_date` date NOT NULL, `dept_id` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8; -- 添加人员数据 -- 教学部 INSERT INTO `person` VALUES ('1', 'alex', '28', '人妖', '53000.00', '2010-06-21', '1'); INSERT INTO `person` VALUES ('2', 'wupeiqi', '23', '男', '8000.00', '2011-02-21', '1'); INSERT INTO `person` VALUES ('3', 'egon', '30', '男', '6500.00', '2015-06-21', '1'); INSERT INTO `person` VALUES ('4', 'jingnvshen', '18', '女', '6680.00', '2014-06-21', '1'); -- 销售部 INSERT INTO `person` VALUES ('5', '歪歪', '20', '女', '3000.00', '2015-02-21', '2'); INSERT INTO `person` VALUES ('6', '星星', '20', '女', '2000.00', '2018-01-30', '2'); INSERT INTO `person` VALUES ('7', '格格', '20', '女', '2000.00', '2018-02-27', '2'); INSERT INTO `person` VALUES ('8', '周周', '20', '女', '2000.00', '2015-06-21', '2'); -- 市场部 INSERT INTO `person` VALUES ('9', '月月', '21', '女', '4000.00', '2014-07-21', '3'); INSERT INTO `person` VALUES ('10', '安琪', '22', '女', '4000.00', '2015-07-15', '3'); -- 人事部 INSERT INTO `person` VALUES ('11', '周明月', '17', '女', '5000.00', '2014-06-21', '4'); -- 鼓励部 INSERT INTO `person` VALUES ('12', '苍老师', '33', '女', '1000000.00', '2018-02-21', null); #多表查询语法 select 字段1,字段2... from 表1,表2... [where 条件] 注意: 如果不加条件直接进行查询,则会出现以下效果,这种结果我们称之为 笛卡尔乘积 #查询人员和部门所有信息 select * from person,dept 笛卡尔乘积公式 : A表中数据条数 * B表中数据条数 = 笛卡尔乘积. mysql> select * from person ,dept; +----+----------+-----+-----+--------+------+-----+--------+ | id | name | age | sex | salary | did | did | dname | +----+----------+-----+-----+--------+------+-----+--------+ | 1 | alex | 28 | 女 | 53000 | 1 | 1 | python | | 1 | alex | 28 | 女 | 53000 | 1 | 2 | linux | | 1 | alex | 28 | 女 | 53000 | 1 | 3 | 明教 | | 2 | wupeiqi | 23 | 女 | 29000 | 1 | 1 | python | | 2 | wupeiqi | 23 | 女 | 29000 | 1 | 2 | linux | | 2 | wupeiqi | 23 | 女 | 29000 | 1 | 3 | 明教 | | 3 | egon | 30 | 男 | 27000 | 1 | 1 | python | | 3 | egon | 30 | 男 | 27000 | 1 | 2 | linux | | 3 | egon | 30 | 男 | 27000 | 1 | 3 | 明教 | | 4 | oldboy | 22 | 男 | 1 | 2 | 1 | python | | 4 | oldboy | 22 | 男 | 1 | 2 | 2 | linux | | 4 | oldboy | 22 | 男 | 1 | 2 | 3 | 明教 | | 5 | jinxin | 33 | 女 | 28888 | 1 | 1 | python | | 5 | jinxin | 33 | 女 | 28888 | 1 | 2 | linux | | 5 | jinxin | 33 | 女 | 28888 | 1 | 3 | 明教 | | 6 | 张无忌 | 20 | 男 | 8000 | 3 | 1 | python | | 6 | 张无忌 | 20 | 男 | 8000 | 3 | 2 | linux | | 6 | 张无忌 | 20 | 男 | 8000 | 3 | 3 | 明教 | | 7 | 令狐冲 | 22 | 男 | 6500 | NULL | 1 | python | | 7 | 令狐冲 | 22 | 男 | 6500 | NULL | 2 | linux | | 7 | 令狐冲 | 22 | 男 | 6500 | NULL | 3 | 明教 | | 8 | 东方不败 | 23 | 女 | 18000 | NULL | 1 | python | | 8 | 东方不败 | 23 | 女 | 18000 | NULL | 2 | linux | | 8 | 东方不败 | 23 | 女 | 18000 | NULL | 3 | 明教 | +----+----------+-----+-----+--------+------+-----+--------+ 笛卡尔乘积示例 #查询人员和部门所有信息 select * from person,dept where person.did = dept.did; #注意: 多表查询时,一定要找到两个表中相互关联的字段,并且作为条件使用 mysql> select * from person,dept where person.did = dept.did; +----+---------+-----+-----+--------+-----+-----+--------+ | id | name | age | sex | salary | did | did | dname | +----+---------+-----+-----+--------+-----+-----+--------+ | 1 | alex | 28 | 女 | 53000 | 1 | 1 | python | | 2 | wupeiqi | 23 | 女 | 29000 | 1 | 1 | python | | 3 | egon | 30 | 男 | 27000 | 1 | 1 | python | | 4 | oldboy | 22 | 男 | 1 | 2 | 2 | linux | | 5 | jinxin | 33 | 女 | 28888 | 1 | 1 | python | | 6 | 张无忌 | 20 | 男 | 8000 | 3 | 3 | 明教 | | 7 | 令狐冲 | 22 | 男 | 6500 | 2 | 2 | linux | +----+---------+-----+-----+--------+-----+-----+--------+ rows in set 二 多表连接查询 #多表连接查询语法(重点) SELECT 字段列表 FROM 表1 INNER|LEFT|RIGHT JOIN 表2 ON 表1.字段 = 表2.字段; 1 内连接查询 (只显示符合条件的数据) #查询人员和部门所有信息 select * from person inner join dept on person.did =dept.did; 效果: 大家可能会发现, 内连接查询与多表联合查询的效果是一样的. mysql> select * from person inner join dept on person.did =dept.did; +----+---------+-----+-----+--------+-----+-----+--------+ | id | name | age | sex | salary | did | did | dname | +----+---------+-----+-----+--------+-----+-----+--------+ | 1 | alex | 28 | 女 | 53000 | 1 | 1 | python | | 2 | wupeiqi | 23 | 女 | 29000 | 1 | 1 | python | | 3 | egon | 30 | 男 | 27000 | 1 | 1 | python | | 4 | oldboy | 22 | 男 | 1 | 2 | 2 | linux | | 5 | jinxin | 33 | 女 | 28888 | 1 | 1 | python | | 6 | 张无忌 | 20 | 男 | 8000 | 3 | 3 | 明教 | | 7 | 令狐冲 | 22 | 男 | 6500 | 2 | 2 | linux | +----+---------+-----+-----+--------+-----+-----+--------+ rows in set 2 左外连接查询 (左边表中的数据优先全部显示) #查询人员和部门所有信息 select * from person left join dept on person.did =dept.did; 效果:人员表中的数据全部都显示,而 部门表中的数据符合条件的才会显示,不符合条件的会以 null 进行填充. mysql> select * from person left join dept on person.did =dept.did; +----+----------+-----+-----+--------+------+------+--------+ | id | name | age | sex | salary | did | did | dname | +----+----------+-----+-----+--------+------+------+--------+ | 1 | alex | 28 | 女 | 53000 | 1 | 1 | python | | 2 | wupeiqi | 23 | 女 | 29000 | 1 | 1 | python | | 3 | egon | 30 | 男 | 27000 | 1 | 1 | python | | 5 | jinxin | 33 | 女 | 28888 | 1 | 1 | python | | 4 | oldboy | 22 | 男 | 1 | 2 | 2 | linux | | 7 | 令狐冲 | 22 | 男 | 6500 | 2 | 2 | linux | | 6 | 张无忌 | 20 | 男 | 8000 | 3 | 3 | 明教 | | 8 | 东方不败 | 23 | 女 | 18000 | NULL | NULL | NULL | +----+----------+-----+-----+--------+------+------+--------+ rows in set 3 右外连接查询 (右边表中的数据优先全部显示) #查询人员和部门所有信息 select * from person right join dept on person.did =dept.did; 效果:正好与[左外连接相反] mysql> select * from person right join dept on person.did =dept.did; +----+---------+-----+-----+--------+-----+-----+--------+ | id | name | age | sex | salary | did | did | dname | +----+---------+-----+-----+--------+-----+-----+--------+ | 1 | alex | 28 | 女 | 53000 | 1 | 1 | python | | 2 | wupeiqi | 23 | 女 | 29000 | 1 | 1 | python | | 3 | egon | 30 | 男 | 27000 | 1 | 1 | python | | 4 | oldboy | 22 | 男 | 1 | 2 | 2 | linux | | 5 | jinxin | 33 | 女 | 28888 | 1 | 1 | python | | 6 | 张无忌 | 20 | 男 | 8000 | 3 | 3 | 明教 | | 7 | 令狐冲 | 22 | 男 | 6500 | 2 | 2 | linux | +----+---------+-----+-----+--------+-----+-----+--------+ rows in set 4 全连接查询(显示左右表中全部数据) 全连接查询：是在内连接的基础上增加 左右两边没有显示的数据 　　注意: mysql并不支持全连接 full JOIN 关键字 　　注意: 但是mysql 提供了 UNION 关键字.使用 UNION 可以间接实现 full JOIN 功能 #查询人员和部门的所有数据 SELECT * FROM person LEFT JOIN dept ON person.did = dept.did UNION SELECT * FROM person RIGHT JOIN dept ON person.did = dept.did; mysql> SELECT * FROM person LEFT JOIN dept ON person.did = dept.did UNION SELECT * FROM person RIGHT JOIN dept ON person.did = dept.did; +------+----------+------+------+--------+------+------+--------+ | id | name | age | sex | salary | did | did | dname | +------+----------+------+------+--------+------+------+--------+ | 1 | alex | 28 | 女 | 53000 | 1 | 1 | python | | 2 | wupeiqi | 23 | 女 | 29000 | 1 | 1 | python | | 3 | egon | 30 | 男 | 27000 | 1 | 1 | python | | 5 | jinxin | 33 | 女 | 28888 | 1 | 1 | python | | 4 | oldboy | 22 | 男 | 1 | 2 | 2 | linux | | 7 | 令狐冲 | 22 | 男 | 6500 | 2 | 2 | linux | | 6 | 张无忌 | 20 | 男 | 8000 | 3 | 3 | 明教 | | 8 | 东方不败 | 23 | 女 | 18000 | NULL | NULL | NULL | | NULL | NULL | NULL | NULL | NULL | NULL | 4 | 基督教 | +------+----------+------+------+--------+------+------+--------+ rows in set 注意: UNION 和 UNION ALL 的区别:UNION 会去掉重复的数据,而 UNION ALL 则直接显示结果 三 复杂条件多表查询 1. 查询出 教学部 年龄大于20岁,并且工资小于40000的员工,按工资倒序排列.(要求:分别使用多表联合查询和内连接查询) #1.多表联合查询方式: select * from person p1,dept d2 where p1.did = d2.did and d2.dname='python' and age>20 and salary 20 and salary select MAX(salary),MIN(salary),dept.dname from person LEFT JOIN dept ON person.did = dept.did GROUP BY person.did; 四 子语句查询　 子查询(嵌套查询): 查多次, 多个select 注意: 第一次的查询结果可以作为第二次的查询的 条件 或者 表名 使用. 子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS等关键字. 还可以包含比较运算符：= 、 !=、> 、 1.作为表名使用 select * from (select * from person) as 表名; ps:大家需要注意的是: 一条语句中可以有多个这样的子查询,在执行时,最里层括号(sql语句) 具有优先执行权.注意: as 后面的表名称不能加引号('') 2.求最大工资那个人的姓名和薪水 1.求最大工资 select max(salary) from person; 2.求最大工资那个人叫什么 select name,salary from person where salary=53000; 合并 select name,salary from person where salary=(select max(salary) from person); 3. 求工资高于所有人员平均工资的人员 1.求平均工资 select avg(salary) from person; 2.工资大于平均工资的 人的姓名、工资 select name,salary from person where salary > 21298.625; 合并 select name,salary from person where salary >(select avg(salary) from person); 4.练习 1.查询平均年龄在20岁以上的部门名 2.查询教学部 下的员工信息 3.查询大于所有人平均工资的人员的姓名与年龄 #1.查询平均年龄在20岁以上的部门名 SELECT * from dept where dept.did in ( select dept_id from person GROUP BY dept_id HAVING avg(person.age) > 20 ); #2.查询教学部 下的员工信息 select * from person where dept_id = (select did from dept where dname ='教学部'); #3.查询大于所有人平均工资的人员的姓名与年龄 select * from person where salary > (select avg(salary) from person); 5.关键字 ANY关键字 假设any内部的查询语句返回的结果个数是三个，如:result1,result2,result3,那么， select ...from ... where a > any(...); -> select ...from ... where a > result1 or a > result2 or a > result3; ALL关键字 ALL关键字与any关键字类似，只不过上面的or改成and。即: select ...from ... where a > all(...); -> select ...from ... where a > result1 and a > result2 and a > result3; SOME关键字 some关键字和any关键字是一样的功能。所以: select ...from ... where a > some(...); -> select ...from ... where a > result1 or a > result2 or a > result3; EXISTS 关键字 EXISTS 和 NOT EXISTS 子查询语法如下： 　　SELECT ... FROM table WHERE EXISTS (subquery) 该语法可以理解为：主查询(外部查询)会根据子查询验证结果（TRUE 或 FALSE）来决定主查询是否得以执行。 mysql> SELECT * FROM person -> WHERE EXISTS -> (SELECT * FROM dept WHERE did=5); Empty set (0.00 sec) 此处内层循环并没有查询到满足条件的结果，因此返回false，外层查询不执行。 NOT EXISTS刚好与之相反 mysql> SELECT * FROM person -> WHERE NOT EXISTS -> (SELECT * FROM dept WHERE did=5); +----+----------+-----+-----+--------+------+ | id | name | age | sex | salary | did | +----+----------+-----+-----+--------+------+ | 1 | alex | 28 | 女 | 53000 | 1 | | 2 | wupeiqi | 23 | 女 | 29000 | 1 | | 3 | egon | 30 | 男 | 27000 | 1 | | 4 | oldboy | 22 | 男 | 1 | 2 | | 5 | jinxin | 33 | 女 | 28888 | 1 | | 6 | 张无忌 | 20 | 男 | 8000 | 3 | | 7 | 令狐冲 | 22 | 男 | 6500 | 2 | | 8 | 东方不败 | 23 | 女 | 18000 | NULL | +----+----------+-----+-----+--------+------+ rows in set 当然，EXISTS关键字可以与其他的查询条件一起使用，条件表达式与EXISTS关键字之间用AND或者OR来连接，如下： mysql> SELECT * FROM person -> WHERE AGE >23 AND NOT EXISTS -> (SELECT * FROM dept WHERE did=5); 提示： •EXISTS (subquery) 只返回 TRUE 或 FALSE，因此子查询中的 SELECT * 也可以是 SELECT 1 或其他，官方说法是实际执行时会忽略 SELECT 清单，因此没有区别。 五 其他查询 1.临时表查询 需求: 查询高于本部门平均工资的人员 解析思路: 1.先查询本部门人员平均工资是多少. 　　　　 2.再使用人员的工资与部门的平均工资进行比较 #1.先查询部门人员的平均工资 SELECT dept_id,AVG(salary)as sal from person GROUP BY dept_id; #2.再用人员的工资与部门的平均工资进行比较 SELECT * FROM person as p1, (SELECT dept_id,AVG(salary)as '平均工资' from person GROUP BY dept_id) as p2 where p1.dept_id = p2.dept_id AND p1.salary >p2.`平均工资`; ps:在当前语句中,我们可以把上一次的查询结果当前做一张表来使用.因为p2表不是真是存在的,所以:我们称之为 临时表　　 临时表:不局限于自身表,任何的查询结果集都可以认为是一个临时表. 2. 判断查询　IF关键字 需求1 :根据工资高低,将人员划分为两个级别,分别为 高端人群和低端人群。显示效果:姓名,年龄,性别,工资,级别 select p1.*, IF(p1.salary >10000,'高端人群','低端人群') as '级别' from person p1; #ps: 语法: IF(条件表达式,\"结果为true\",'结果为false'); 需求2: 根据工资高低,统计每个部门人员收入情况,划分为 富人,小资,平民,吊丝 四个级别, 要求统计四个级别分别有多少人 SELECT dname '部门', sum(case WHEN salary >50000 THEN 1 ELSE 0 end) as '富人', sum(case WHEN salary between 29000 and 50000 THEN 1 ELSE 0 end) as '小资', sum(case WHEN salary between 10000 and 29000 THEN 1 ELSE 0 end) as '平民', sum(case WHEN salary 六 SQL逻辑查询语句执行顺序(重点*) 先来一段伪代码，首先你能看懂么？ SELECT DISTINCT FROM JOIN ON WHERE GROUP BY HAVING ORDER BY LIMIT 重点: 　　在这些SQL语句的执行过程中，都会产生一个虚拟表，用来保存SQL语句的执行结果（这是重点），我们现在就来跟踪这个虚拟表的变化，得到最终的查询结果的过程，来分析整个SQL逻辑查询的执行顺序和过程。 1.执行FROM语句 2.执行ON过滤 3.添加外部行 4.执行WHERE过滤 5.执行GROUP BY分组 6.执行HAVING过滤 7.SELECT列表 8.执行DISTINCT子句 9.执行ORDER BY子句 10.执行LIMIT子句 七 外键约束 1.问题? 　　什么是约束:约束是一种限制，它通过对表的行或列的数据做出限制，来确保表的数据的完整性、唯一性 2.问题? 　　以上两个表 person和dept中, 新人员可以没有部门吗? 3.问题? 　　新人员可以添加一个不存在的部门吗? 4.如何解决以上问题呢? 　　简单的说,就是对两个表的关系进行一些约束 (即: froegin key). 　　foreign key 定义:就是表与表之间的某种约定的关系，由于这种关系的存在，能够让表与表之间的数据，更加的完整，关连性更强。 5.具体操作 5.1创建表时,同时创建外键约束 CREATE TABLE IF NOT EXISTS dept ( did int not null auto_increment PRIMARY KEY, dname VARCHAR(50) not null COMMENT '部门名称' )ENGINE=INNODB DEFAULT charset utf8; CREATE TABLE IF NOT EXISTS person( id int not null auto_increment PRIMARY KEY, name VARCHAR(50) not null, age TINYINT(4) null DEFAULT 0, sex enum('男','女','人妖') NOT NULL DEFAULT '人妖', salary decimal(10,2) NULL DEFAULT '250.00', hire_date date NOT NULL, dept_id int(11) DEFAULT NULL, 　 CONSTRAINT fk_did FOREIGN KEY(dept_id) REFERENCES dept(did) -- 添加外键约束 )ENGINE = INNODB DEFAULT charset utf8; 5.2 已经创建表后,追加外键约束 #添加外键约束 ALTER table person add constraint fk_did FOREIGN key(dept_id) REFERENCES dept(did); #删除外键约束 ALTER TABLE person drop FOREIGN key fk_did; 定义外键的条件： （1）外键对应的字段数据类型保持一致,且被关联的字段(即references指定的另外一个表的字段)，必须保证唯一 （2）所有tables的存储引擎必须是InnoDB类型. （3）外键的约束4种类型: 1.RESTRICT 2. NO ACTION 3.CASCADE 4.SET NULL 约束类型详解 RESTRICT 同no action, 都是立即检查外键约束 NO ACTION 如果子表中有匹配的记录,则不允许对父表对应候选键进行update/delete操作 CASCADE 在父表上update/delete记录时，同步update/delete掉子表的匹配记录 SET NULL 在父表上update/delete记录时，将子表上匹配记录的列设为null (要注意子表的外键列不能为not null) （4）建议:1.如果需要外键约束,最好创建表同时创建外键约束. 　　　　 2.如果需要设置级联关系,删除时最好设置为 SET NULL. 注：插入数据时，先插入主表中的数据，再插入从表中的数据。 删除数据时，先删除从表中的数据，再删除主表中的数据。 八 其他约束类型 1.非空约束 关键字: NOT NULL ,表示 不可空. 用来约束表中的字段列 create table t1( id int(10) not null primary key, name varchar(100) null ); 2.主键约束 用于约束表中的一行，作为这一行的标识符，在一张表中通过主键就能准确定位到一行，因此主键十分重要。 create table t2( id int(10) not null primary key ); 注意: 主键这一行的数据不能重复且不能为空。 还有一种特殊的主键——复合主键。主键不仅可以是表中的一列，也可以由表中的两列或多列来共同标识 create table t3( id int(10) not null, name varchar(100) , primary key(id,name) ); 3.唯一约束 关键字: UNIQUE, 比较简单，它规定一张表中指定的一列的值必须不能有重复值，即这一列每个值都是唯一的。 create table t4( id int(10) not null, name varchar(255) , unique id_name(id,name) ); //添加唯一约束 alter table t4 add unique id_name(id,name); //删除唯一约束 alter table t4 drop index id_name; 注意: 当INSERT语句新插入的数据和已有数据重复的时候，如果有UNIQUE约束，则INSERT失败.　 4.默认值约束 关键字: DEFAULT create table t5( id int(10) not null primary key, name varchar(255) default '张三' ); #插入数据 INSERT into t5(id) VALUES(1),(2); 注意: INSERT语句执行时.，如果被DEFAULT约束的位置没有值，那么这个位置将会被DEFAULT的值填充 九.表与表之间的关系 1.表关系分类: 总体可以分为三类: 一对一 、一对多(多对一) 、多对多 2.如何区分表与表之间是什么关系? #分析步骤: #多对一 /一对多 #1.站在左表的角度去看右表(情况一) 如果左表中的一条记录,对应右表中多条记录.那么他们的关系则为 一对多 关系.约束关系为:左表普通字段, 对应右表foreign key 字段. 注意:如果左表与右表的情况反之.则关系为 多对一 关系.约束关系为:左表foreign key 字段, 对应右表普通字段. #一对一 #2.站在左表的角度去看右表(情况二) 如果左表中的一条记录 对应 右表中的一条记录. 则关系为 一对一关系. 约束关系为:左表foreign key字段上 添加唯一(unique)约束, 对应右表 关联字段. 或者:右表foreign key字段上 添加唯一(unique)约束, 对应右表 关联字段. #多对多 #3.站在左表和右表同时去看(情况三) 如果左表中的一条记录 对应 右表中的多条记录,并且右表中的一条记录同时也对应左表的多条记录. 那么这种关系 则 多对多 关系. 这种关系需要定义一个这两张表的[关系表]来专门存放二者的关系 3.建立表关系 1.一对多关系 　例如:一个人可以拥有多辆汽车，要求查询某个人拥有的所有车辆。 　分析：人和车辆分别单独建表，那么如何将两个表关联呢？有个巧妙的方法，在车辆的表中加个外键字段(人的编号)即可。 　 (思路小结：’建两个表，一’方不动，’多’方添加一个外键字段) 2.一对一关系 例如：一个中国公民只能有一个身份证信息 分析: 一对一的表关系实际上是 变异了的 一对多关系. 通过在从表的外键字段上添加唯一约束(unique)来实现一对一表关系. 3.多对多关系 　例如：学生选课，一个学生可以选修多门课程，每门课程可供多个学生选择。 　分析：这种方式可以按照类似一对多方式建表，但冗余信息太多，好的方式是实体和关系分离并单独建表，实体表为学生表和课程表，关系表为选修表， 其中关系表采用联合主键的方式(由学生表主键和课程表主键组成)建表。 数据库设计三范式: 1．第一范式(确保每列保持原子性) 2．第二范式(确保表中的每列都和主键相关) 3．第三范式(确保每列都和主键列直接相关,而不是间接相关) 注意事项： 1.第二范式与第三范式的本质区别：在于有没有分出两张表。 第二范式是说一张表中包含了多种不同实体的属性，那么必须要分成多张表，第三范式是要求已经分好了多张表的话，一张表中只能有另一张标的ID，而不能有其他任何信息，（其他任何信息，一律用主键在另一张表中查询）。 2.必须先满足第一范式才能满足第二范式，必须同时满足第一第二范式才能满足第三范式。 "},"MySQL学习/04-MySQL数据操作/":{"url":"MySQL学习/04-MySQL数据操作/","title":"MySQL数据操作","keywords":"","body":"├─04-MySQL数据操作 ├──────1、MySQL数据操作.md ├──────2、单表查询.md ├──────3、多表查询.md ├──────4、MySQL逻辑查询语句执行顺序.md ├──────多表查询作业答案.md "},"MySQL学习/04-MySQL数据操作/1、MySQL数据操作.html":{"url":"MySQL学习/04-MySQL数据操作/1、MySQL数据操作.html","title":"1、MySQL数据操作","keywords":"","body":"1、MySQL数据操作 一 介绍 MySQL数据操作： DML 在MySQL管理软件中，可以通过SQL语句中的DML语言来实现数据的操作，包括 使用INSERT实现数据的插入 UPDATE实现数据的更新 使用DELETE实现数据的删除 使用SELECT查询数据以及。 二 插入数据INSERT 1. 插入完整数据（顺序插入） 语法一： INSERT INTO 表名(字段1,字段2,字段3…字段n) VALUES(值1,值2,值3…值n); 语法二： INSERT INTO 表名 VALUES (值1,值2,值3…值n); 2. 指定字段插入数据 语法： INSERT INTO 表名(字段1,字段2,字段3…) VALUES (值1,值2,值3…); 3. 插入多条记录 语法： INSERT INTO 表名 VALUES (值1,值2,值3…值n), (值1,值2,值3…值n), (值1,值2,值3…值n); 4. 插入查询结果 语法： INSERT INTO 表名(字段1,字段2,字段3…字段n) SELECT (字段1,字段2,字段3…字段n) FROM 表2 WHERE …; 三 更新数据UPDATE 语法： UPDATE 表名 SET 字段1=值1, 字段2=值2, WHERE CONDITION; 示例： UPDATE mysql.user SET password=password(‘123’) where user=’root’ and host=’localhost’; 四 删除数据DELETE 语法： DELETE FROM 表名 WHERE CONITION; 示例： DELETE FROM mysql.user WHERE password=’’; 练习： 更新MySQL root用户密码为mysql123 删除除从本地登录的root用户以外的所有用户 五 查询数据SELECT 单表查询 多表查询 六 权限管理 #授权表 user #该表放行的权限，针对：所有数据，所有库下所有表，以及表下的所有字段 db #该表放行的权限，针对：某一数据库，该数据库下的所有表，以及表下的所有字段 tables_priv #该表放行的权限。针对：某一张表，以及该表下的所有字段 columns_priv #该表放行的权限，针对：某一个字段 #按图解释： user：放行db1，db2及其包含的所有 db：放行db1，及其db1包含的所有 tables_priv:放行db1.table1，及其该表包含的所有 columns_prive:放行db1.table1.column1，只放行该字段 权限相关操作 #创建用户 create user 'egon'@'1.1.1.1' identified by '123'; create user 'egon'@'192.168.1.%' identified by '123'; create user 'egon'@'%' identified by '123'; #授权：对文件夹，对文件，对文件某一字段的权限 查看帮助：help grant 常用权限有：select,update,alter,delete all可以代表除了grant之外的所有权限 #针对所有库的授权:*.* grant select on *.* to 'egon1'@'localhost' identified by '123'; #只在user表中可以查到egon1用户的select权限被设置为Y #针对某一数据库：db1.* grant select on db1.* to 'egon2'@'%' identified by '123'; #只在db表中可以查到egon2用户的select权限被设置为Y #针对某一个表：db1.t1 grant select on db1.t1 to 'egon3'@'%' identified by '123'; #只在tables_priv表中可以查到egon3用户的select权限 #针对某一个字段： mysql> select * from t3; +------+-------+------+ | id | name | age | +------+-------+------+ | 1 | egon1 | 18 | | 2 | egon2 | 19 | | 3 | egon3 | 29 | +------+-------+------+ grant select (id,name),update (age) on db1.t3 to 'egon4'@'localhost' identified by '123'; #可以在tables_priv和columns_priv中看到相应的权限 mysql> select * from tables_priv where user='egon4'\\G *************************** 1. row *************************** Host: localhost Db: db1 User: egon4 Table_name: t3 Grantor: root@localhost Timestamp: 0000-00-00 00:00:00 Table_priv: Column_priv: Select,Update row in set (0.00 sec) mysql> select * from columns_priv where user='egon4'\\G *************************** 1. row *************************** Host: localhost Db: db1 User: egon4 Table_name: t3 Column_name: id Timestamp: 0000-00-00 00:00:00 Column_priv: Select *************************** 2. row *************************** Host: localhost Db: db1 User: egon4 Table_name: t3 Column_name: name Timestamp: 0000-00-00 00:00:00 Column_priv: Select *************************** 3. row *************************** Host: localhost Db: db1 User: egon4 Table_name: t3 Column_name: age Timestamp: 0000-00-00 00:00:00 Column_priv: Update rows in set (0.00 sec) #删除权限 revoke select on db1.* from 'egon'@'%'; "},"MySQL学习/04-MySQL数据操作/2、单表查询.html":{"url":"MySQL学习/04-MySQL数据操作/2、单表查询.html","title":"2、单表查询","keywords":"","body":"2、单表查询 一 单表查询的语法 SELECT 字段1,字段2... FROM 表名 WHERE 条件 GROUP BY field HAVING 筛选 ORDER BY field LIMIT 限制条数 二 关键字的执行优先级(重点) from where group by having select distinct order by limit 重点中的重点：关键字的执行优先级 1.找到表:from 2.拿着where指定的约束条件，去文件/表中取出一条条记录 3.将取出的一条条记录进行分组group by，如果没有group by，则整体作为一组 4.将分组的结果进行having过滤 5.执行select 6.去重 7.将结果按条件排序：order by 8.限制结果的显示条数 详细见： 三 简单查询 准备表和记录 company.employee 员工id id int 姓名 emp_name varchar 性别 sex enum 年龄 age int 入职日期 hire_date date 岗位 post varchar 职位描述 post_comment varchar 薪水 salary double 办公室 office int 部门编号 depart_id int #创建表 create table employee( id int not null unique auto_increment, name varchar(20) not null, sex enum('male','female') not null default 'male', #大部分是男的 age int(3) unsigned not null default 28, hire_date date not null, post varchar(50), post_comment varchar(100), salary double(15,2), office int, #一个部门一个屋子 depart_id int ); #查看表结构 mysql> desc employee; +--------------+-----------------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +--------------+-----------------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | name | varchar(20) | NO | | NULL | | | sex | enum('male','female') | NO | | male | | | age | int(3) unsigned | NO | | 28 | | | hire_date | date | NO | | NULL | | | post | varchar(50) | YES | | NULL | | | post_comment | varchar(100) | YES | | NULL | | | salary | double(15,2) | YES | | NULL | | | office | int(11) | YES | | NULL | | | depart_id | int(11) | YES | | NULL | | +--------------+-----------------------+------+-----+---------+----------------+ #插入记录 #三个部门：教学，销售，运营 insert into employee(name,sex,age,hire_date,post,salary,office,depart_id) values ('egon','male',18,'20170301','老男孩驻沙河办事处外交大使',7300.33,401,1), #以下是教学部 ('alex','male',78,'20150302','teacher',1000000.31,401,1), ('wupeiqi','male',81,'20130305','teacher',8300,401,1), ('yuanhao','male',73,'20140701','teacher',3500,401,1), ('liwenzhou','male',28,'20121101','teacher',2100,401,1), ('jingliyang','female',18,'20110211','teacher',9000,401,1), ('jinxin','male',18,'19000301','teacher',30000,401,1), ('成龙','male',48,'20101111','teacher',10000,401,1), ('歪歪','female',48,'20150311','sale',3000.13,402,2),#以下是销售部门 ('丫丫','female',38,'20101101','sale',2000.35,402,2), ('丁丁','female',18,'20110312','sale',1000.37,402,2), ('星星','female',18,'20160513','sale',3000.29,402,2), ('格格','female',28,'20170127','sale',4000.33,402,2), ('张野','male',28,'20160311','operation',10000.13,403,3), #以下是运营部门 ('程咬金','male',18,'19970312','operation',20000,403,3), ('程咬银','female',18,'20130311','operation',19000,403,3), ('程咬铜','male',18,'20150411','operation',18000,403,3), ('程咬铁','female',18,'20140512','operation',17000,403,3) ; #ps：如果在windows系统中，插入中文字符，select的结果为空白，可以将所有字符编码统一设置成gbk #简单查询 SELECT id,name,sex,age,hire_date,post,post_comment,salary,office,depart_id FROM employee; SELECT * FROM employee; SELECT name,salary FROM employee; #避免重复DISTINCT SELECT DISTINCT post FROM employee; #通过四则运算查询 SELECT name, salary*12 FROM employee; SELECT name, salary*12 AS Annual_salary FROM employee; SELECT name, salary*12 Annual_salary FROM employee; #定义显示格式 CONCAT() 函数用于连接字符串 SELECT CONCAT('姓名: ',name,' 年薪: ', salary*12) AS Annual_salary FROM employee; CONCAT_WS() 第一个参数为分隔符 SELECT CONCAT_WS(':',name,salary*12) AS Annual_salary FROM employee; 结合CASE语句： SELECT ( CASE WHEN NAME = 'egon' THEN NAME WHEN NAME = 'alex' THEN CONCAT(name,'_BIGSB') ELSE concat(NAME, 'SB') END ) as new_name FROM emp; 小练习： 1 查出所有员工的名字，薪资,格式为 2 查出所有的岗位（去掉重复） 3 查出所有员工名字，以及他们的年薪,年薪的字段名为annual_year select concat(' ','') from employee; select distinct depart_id from employee; select name,salary*12 annual_salary from employee; 四 WHERE约束 where字句中可以使用： 比较运算符：> = != between 80 and 100 值在10到20之间 in(80,90,100) 值是10或20或30 like 'egon%' pattern可以是%或， %表示任意多字符 表示一个字符 逻辑运算符：在多个条件直接可以使用逻辑运算符 and or not where字句中可以使用： 比较运算符：> = != between 80 and 100 值在10到20之间 in(80,90,100) 值是10或20或30 like 'egon%' pattern可以是%或， %表示任意多字符 表示一个字符 逻辑运算符：在多个条件直接可以使用逻辑运算符 and or not #1:单条件查询 SELECT name FROM employee WHERE post='sale'; #2:多条件查询 SELECT name,salary FROM employee WHERE post='teacher' AND salary>10000; #3:关键字BETWEEN AND SELECT name,salary FROM employee WHERE salary BETWEEN 10000 AND 20000; SELECT name,salary FROM employee WHERE salary NOT BETWEEN 10000 AND 20000; #4:关键字IS NULL(判断某个字段是否为NULL不能用等号，需要用IS) SELECT name,post_comment FROM employee WHERE post_comment IS NULL; SELECT name,post_comment FROM employee WHERE post_comment IS NOT NULL; SELECT name,post_comment FROM employee WHERE post_comment=''; 注意''是空字符串，不是null ps： 执行 update employee set post_comment='' where id=2; 再用上条查看，就会有结果了 #5:关键字IN集合查询 SELECT name,salary FROM employee WHERE salary=3000 OR salary=3500 OR salary=4000 OR salary=9000 ; SELECT name,salary FROM employee WHERE salary IN (3000,3500,4000,9000) ; SELECT name,salary FROM employee WHERE salary NOT IN (3000,3500,4000,9000) ; #6:关键字LIKE模糊查询 通配符’%’ SELECT * FROM employee WHERE name LIKE 'eg%'; 通配符’_’ SELECT * FROM employee WHERE name LIKE 'al__'; 小练习： 1. 查看岗位是teacher的员工姓名、年龄 2. 查看岗位是teacher且年龄大于30岁的员工姓名、年龄 3. 查看岗位是teacher且薪资在9000-1000范围内的员工姓名、年龄、薪资 4. 查看岗位描述不为NULL的员工信息 5. 查看岗位是teacher且薪资是10000或9000或30000的员工姓名、年龄、薪资 6. 查看岗位是teacher且薪资不是10000或9000或30000的员工姓名、年龄、薪资 7. 查看岗位是teacher且名字是jin开头的员工姓名、年薪 select name,age from employee where post = 'teacher'; select name,age from employee where post='teacher' and age > 30; select name,age,salary from employee where post='teacher' and salary between 9000 and 10000; select * from employee where post_comment is not null; select name,age,salary from employee where post='teacher' and salary in (10000,9000,30000); select name,age,salary from employee where post='teacher' and salary not in (10000,9000,30000); select name,salary*12 from employee where post='teacher' and name like 'jin%'; 五 分组查询:GROUP BY 一 什么是分组？为什么要分组？ #1、首先明确一点：分组发生在where之后，即分组是基于where之后得到的记录而进行的 #2、分组指的是：将所有记录按照某个相同字段进行归类，比如针对员工信息表的职位分组，或者按照性别进行分组等 #3、为何要分组呢？ 取每个部门的最高工资 取每个部门的员工数 取男人数和女人数 小窍门：‘每’这个字后面的字段，就是我们分组的依据 #4、大前提： 可以按照任意字段分组，但是分组完毕后，比如group by post，只能查看post字段，如果想查看组内信息，需要借助于聚合函数 二 ONLY_FULL_GROUP_BY ！！！SQL_MODE设置！！！ #查看MySQL 5.7默认的sql_mode如下： mysql> select @@global.sql_mode; ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION #！！！注意 ONLY_FULL_GROUP_BY的语义就是确定select target list中的所有列的值都是明确语义，简单的说来，在ONLY_FULL_GROUP_BY模式下，target list中的值要么是来自于聚集函数的结果，要么是来自于group by list中的表达式的值。 #设置sql_mole如下操作(我们可以去掉ONLY_FULL_GROUP_BY模式)： mysql> set global sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'; mysql> select @@global.sql_mode; +-------------------+ | @@global.sql_mode | +-------------------+ | | +-------------------+ row in set (0.00 sec) mysql> select * from emp group by post; +----+------+--------+-----+------------+----------------------------+--------------+------------+--------+-----------+ | id | name | sex | age | hire_date | post | post_comment | salary | office | depart_id | +----+------+--------+-----+------------+----------------------------+--------------+------------+--------+-----------+ | 14 | 张野 | male | 28 | 2016-03-11 | operation | NULL | 10000.13 | 403 | 3 | | 9 | 歪歪 | female | 48 | 2015-03-11 | sale | NULL | 3000.13 | 402 | 2 | | 2 | alex | male | 78 | 2015-03-02 | teacher | NULL | 1000000.31 | 401 | 1 | | 1 | egon | male | 18 | 2017-03-01 | 老男孩驻沙河办事处外交大使 | NULL | 7300.33 | 401 | 1 | +----+------+--------+-----+------------+----------------------------+--------------+------------+--------+-----------+ rows in set (0.00 sec) #由于没有设置ONLY_FULL_GROUP_BY,于是也可以有结果，默认都是组内的第一条记录，但其实这是没有意义的 mysql> set global sql_mode='ONLY_FULL_GROUP_BY'; Query OK, 0 rows affected (0.00 sec) mysql> quit #设置成功后，一定要退出，然后重新登录方可生效 Bye mysql> use db1; Database changed mysql> select * from emp group by post; #报错 ERROR 1055 (42000): 'db1.emp.id' isn't in GROUP BY mysql> select post,count(id) from emp group by post; #只能查看分组依据和使用聚合函数 +----------------------------+-----------+ | post | count(id) | +----------------------------+-----------+ | operation | 5 | | sale | 5 | | teacher | 7 | | 老男孩驻沙河办事处外交大使 | 1 | +----------------------------+-----------+ rows in set (0.00 sec) 三 GROUP BY 单独使用GROUP BY关键字分组 SELECT post FROM employee GROUP BY post; 注意：我们按照post字段分组，那么select查询的字段只能是post，想要获取组内的其他相关信息，需要借助函数 GROUP BY关键字和GROUP_CONCAT()函数一起使用 SELECT post,GROUP_CONCAT(name) FROM employee GROUP BY post;#按照岗位分组，并查看组内成员名 SELECT post,GROUP_CONCAT(name) as emp_members FROM employee GROUP BY post; GROUP BY与聚合函数一起使用 select post,count(id) as count from employee group by post;#按照岗位分组，并查看每个组有多少人 强调： 如果我们用unique的字段作为分组的依据，则每一条记录自成一组，这种分组没有意义 多条记录之间的某个字段值相同，该字段通常用来作为分组的依据 四 聚合函数 #强调：聚合函数聚合的是组的内容，若是没有分组，则默认一组 示例： SELECT COUNT(*) FROM employee; SELECT COUNT(*) FROM employee WHERE depart_id=1; SELECT MAX(salary) FROM employee; SELECT MIN(salary) FROM employee; SELECT AVG(salary) FROM employee; SELECT SUM(salary) FROM employee; SELECT SUM(salary) FROM employee WHERE depart_id=3; 五 小练习： 1. 查询岗位名以及岗位包含的所有员工名字 2. 查询岗位名以及各岗位内包含的员工个数 3. 查询公司内男员工和女员工的个数 4. 查询岗位名以及各岗位的平均薪资 5. 查询岗位名以及各岗位的最高薪资 6. 查询岗位名以及各岗位的最低薪资 7. 查询男员工与男员工的平均薪资，女员工与女员工的平均薪资 #题1：分组 mysql> select post,group_concat(name) from employee group by post; +-----------------------------------------+---------------------------------------------------------+ | post | group_concat(name) | +-----------------------------------------+---------------------------------------------------------+ | operation | 张野,程咬金,程咬银,程咬铜,程咬铁 | | sale | 歪歪,丫丫,丁丁,星星,格格 | | teacher | alex,wupeiqi,yuanhao,liwenzhou,jingliyang,jinxin,成龙 | | 老男孩驻沙河办事处外交大使 | egon | +-----------------------------------------+---------------------------------------------------------+ #题目2： mysql> select post,count(id) from employee group by post; +-----------------------------------------+-----------+ | post | count(id) | +-----------------------------------------+-----------+ | operation | 5 | | sale | 5 | | teacher | 7 | | 老男孩驻沙河办事处外交大使 | 1 | +-----------------------------------------+-----------+ #题目3： mysql> select sex,count(id) from employee group by sex; +--------+-----------+ | sex | count(id) | +--------+-----------+ | male | 10 | | female | 8 | +--------+-----------+ #题目4： mysql> select post,avg(salary) from employee group by post; +-----------------------------------------+---------------+ | post | avg(salary) | +-----------------------------------------+---------------+ | operation | 16800.026000 | | sale | 2600.294000 | | teacher | 151842.901429 | | 老男孩驻沙河办事处外交大使 | 7300.330000 | +-----------------------------------------+---------------+ #题目5 mysql> select post,max(salary) from employee group by post; +-----------------------------------------+-------------+ | post | max(salary) | +-----------------------------------------+-------------+ | operation | 20000.00 | | sale | 4000.33 | | teacher | 1000000.31 | | 老男孩驻沙河办事处外交大使 | 7300.33 | +-----------------------------------------+-------------+ #题目6 mysql> select post,min(salary) from employee group by post; +-----------------------------------------+-------------+ | post | min(salary) | +-----------------------------------------+-------------+ | operation | 10000.13 | | sale | 1000.37 | | teacher | 2100.00 | | 老男孩驻沙河办事处外交大使 | 7300.33 | +-----------------------------------------+-------------+ #题目七 mysql> select sex,avg(salary) from employee group by sex; +--------+---------------+ | sex | avg(salary) | +--------+---------------+ | male | 110920.077000 | | female | 7250.183750 | +--------+---------------+ 六 HAVING过滤 HAVING与WHERE不一样的地方在于!!!!!! #！！！执行优先级从高到低：where > group by > having #1. Where 发生在分组group by之前，因而Where中可以有任意字段，但是绝对不能使用聚合函数。 #2. Having发生在分组group by之后，因而Having中可以使用分组的字段，无法直接取到其他字段,可以使用聚合函数 验证 mysql> select @@sql_mode; +--------------------+ | @@sql_mode | +--------------------+ | ONLY_FULL_GROUP_BY | +--------------------+ row in set (0.00 sec) mysql> select * from emp where salary > 100000; +----+------+------+-----+------------+---------+--------------+------------+--------+-----------+ | id | name | sex | age | hire_date | post | post_comment | salary | office | depart_id | +----+------+------+-----+------------+---------+--------------+------------+--------+-----------+ | 2 | alex | male | 78 | 2015-03-02 | teacher | NULL | 1000000.31 | 401 | 1 | +----+------+------+-----+------------+---------+--------------+------------+--------+-----------+ row in set (0.00 sec) mysql> select * from emp having salary > 100000; ERROR 1463 (42000): Non-grouping field 'salary' is used in HAVING clause mysql> select post,group_concat(name) from emp group by post having salary > 10000;#错误，分组后无法直接取到salary字段 ERROR 1054 (42S22): Unknown column 'salary' in 'having clause' mysql> select post,group_concat(name) from emp group by post having avg(salary) > 10000; +-----------+-------------------------------------------------------+ | post | group_concat(name) | +-----------+-------------------------------------------------------+ | operation | 程咬铁,程咬铜,程咬银,程咬金,张野 | | teacher | 成龙,jinxin,jingliyang,liwenzhou,yuanhao,wupeiqi,alex | +-----------+-------------------------------------------------------+ rows in set (0.00 sec) 小练习： 1. 查询各岗位内包含的员工个数小于2的岗位名、岗位内包含员工名字、个数 3. 查询各岗位平均薪资大于10000的岗位名、平均工资 4. 查询各岗位平均薪资大于10000且小于20000的岗位名、平均工资 #题1： mysql> select post,group_concat(name),count(id) from employee group by post having count(id) select post,avg(salary) from employee group by post having avg(salary) > 10000; +-----------+---------------+ | post | avg(salary) | +-----------+---------------+ | operation | 16800.026000 | | teacher | 151842.901429 | +-----------+---------------+ #题目3： mysql> select post,avg(salary) from employee group by post having avg(salary) > 10000 and avg(salary) 七 查询排序:ORDER BY 按单列排序 SELECT * FROM employee ORDER BY salary; SELECT * FROM employee ORDER BY salary ASC; SELECT * FROM employee ORDER BY salary DESC; 按多列排序:先按照age排序，如果年纪相同，则按照薪资排序 SELECT * from employee ORDER BY age, salary DESC; 小练习： 1. 查询所有员工信息，先按照age升序排序，如果age相同则按照hire_date降序排序 2. 查询各岗位平均薪资大于10000的岗位名、平均工资,结果按平均薪资升序排列 3. 查询各岗位平均薪资大于10000的岗位名、平均工资,结果按平均薪资降序排列 八 限制查询的记录数:LIMIT 示例： SELECT * FROM employee ORDER BY salary DESC LIMIT 3; #默认初始位置为0 SELECT * FROM employee ORDER BY salary DESC LIMIT 0,5; #从第0开始，即先查询出第一条，然后包含这一条在内往后查5条 SELECT * FROM employee ORDER BY salary DESC LIMIT 5,5; #从第5开始，即先查询出第6条，然后包含这一条在内往后查5条 小练习： 1. 分页显示，每页5条 mysql> select * from employee limit 0,5; +----+-----------+------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+ | id | name | sex | age | hire_date | post | post_comment | salary | office | depart_id | +----+-----------+------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+ | 1 | egon | male | 18 | 2017-03-01 | 老男孩驻沙河办事处外交大使 | NULL | 7300.33 | 401 | 1 | | 2 | alex | male | 78 | 2015-03-02 | teacher | | 1000000.31 | 401 | 1 | | 3 | wupeiqi | male | 81 | 2013-03-05 | teacher | NULL | 8300.00 | 401 | 1 | | 4 | yuanhao | male | 73 | 2014-07-01 | teacher | NULL | 3500.00 | 401 | 1 | | 5 | liwenzhou | male | 28 | 2012-11-01 | teacher | NULL | 2100.00 | 401 | 1 | +----+-----------+------+-----+------------+-----------------------------------------+--------------+------------+--------+-----------+ rows in set (0.00 sec) mysql> select * from employee limit 5,5; +----+------------+--------+-----+------------+---------+--------------+----------+--------+-----------+ | id | name | sex | age | hire_date | post | post_comment | salary | office | depart_id | +----+------------+--------+-----+------------+---------+--------------+----------+--------+-----------+ | 6 | jingliyang | female | 18 | 2011-02-11 | teacher | NULL | 9000.00 | 401 | 1 | | 7 | jinxin | male | 18 | 1900-03-01 | teacher | NULL | 30000.00 | 401 | 1 | | 8 | 成龙 | male | 48 | 2010-11-11 | teacher | NULL | 10000.00 | 401 | 1 | | 9 | 歪歪 | female | 48 | 2015-03-11 | sale | NULL | 3000.13 | 402 | 2 | | 10 | 丫丫 | female | 38 | 2010-11-01 | sale | NULL | 2000.35 | 402 | 2 | +----+------------+--------+-----+------------+---------+--------------+----------+--------+-----------+ rows in set (0.00 sec) mysql> select * from employee limit 10,5; +----+-----------+--------+-----+------------+-----------+--------------+----------+--------+-----------+ | id | name | sex | age | hire_date | post | post_comment | salary | office | depart_id | +----+-----------+--------+-----+------------+-----------+--------------+----------+--------+-----------+ | 11 | 丁丁 | female | 18 | 2011-03-12 | sale | NULL | 1000.37 | 402 | 2 | | 12 | 星星 | female | 18 | 2016-05-13 | sale | NULL | 3000.29 | 402 | 2 | | 13 | 格格 | female | 28 | 2017-01-27 | sale | NULL | 4000.33 | 402 | 2 | | 14 | 张野 | male | 28 | 2016-03-11 | operation | NULL | 10000.13 | 403 | 3 | | 15 | 程咬金 | male | 18 | 1997-03-12 | operation | NULL | 20000.00 | 403 | 3 | +----+-----------+--------+-----+------------+-----------+--------------+----------+--------+-----------+ rows in set (0.00 sec) 九 使用正则表达式查询 SELECT * FROM employee WHERE name REGEXP '^ale'; SELECT * FROM employee WHERE name REGEXP 'on$'; SELECT * FROM employee WHERE name REGEXP 'm{2}'; 小结：对字符串匹配的方式 WHERE name = 'egon'; WHERE name LIKE 'yua%'; WHERE name REGEXP 'on$'; 小练习： 查看所有员工中名字是jin开头，n或者g结果的员工信息 select * from employee where name regexp '^jin.*[gn]$'; "},"MySQL学习/04-MySQL数据操作/3、多表查询.html":{"url":"MySQL学习/04-MySQL数据操作/3、多表查询.html","title":"3、多表查询","keywords":"","body":"2、多表查询 一 介绍 多表查询主要内容: 多表连接查询 复合条件连接查询 子查询 表department与employee #建表 create table department( id int, name varchar(20) ); create table employee( id int primary key auto_increment, name varchar(20), sex enum('male','female') not null default 'male', age int, dep_id int ); #插入数据 insert into department values (200,'技术'), (201,'人力资源'), (202,'销售'), (203,'运营'); insert into employee(name,sex,age,dep_id) values ('egon','male',18,200), ('alex','female',48,201), ('wupeiqi','male',38,201), ('yuanhao','female',28,202), ('liwenzhou','male',18,200), ('jingliyang','female',18,204) ; #查看表结构和数据 mysql> desc department; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ mysql> desc employee; +--------+-----------------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +--------+-----------------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | name | varchar(20) | YES | | NULL | | | sex | enum('male','female') | NO | | male | | | age | int(11) | YES | | NULL | | | dep_id | int(11) | YES | | NULL | | +--------+-----------------------+------+-----+---------+----------------+ mysql> select * from department; +------+--------------+ | id | name | +------+--------------+ | 200 | 技术 | | 201 | 人力资源 | | 202 | 销售 | | 203 | 运营 | +------+--------------+ mysql> select * from employee; +----+------------+--------+------+--------+ | id | name | sex | age | dep_id | +----+------------+--------+------+--------+ | 1 | egon | male | 18 | 200 | | 2 | alex | female | 48 | 201 | | 3 | wupeiqi | male | 38 | 201 | | 4 | yuanhao | female | 28 | 202 | | 5 | liwenzhou | male | 18 | 200 | | 6 | jingliyang | female | 18 | 204 | +----+------------+--------+------+--------+ 二 多表连接查询 #重点：外链接语法 SELECT 字段列表 FROM 表1 INNER|LEFT|RIGHT JOIN 表2 ON 表1.字段 = 表2.字段; 1 交叉连接：不适用任何匹配条件。生成笛卡尔积 mysql> select * from employee,department; +----+------------+--------+------+--------+------+--------------+ | id | name | sex | age | dep_id | id | name | +----+------------+--------+------+--------+------+--------------+ | 1 | egon | male | 18 | 200 | 200 | 技术 | | 1 | egon | male | 18 | 200 | 201 | 人力资源 | | 1 | egon | male | 18 | 200 | 202 | 销售 | | 1 | egon | male | 18 | 200 | 203 | 运营 | | 2 | alex | female | 48 | 201 | 200 | 技术 | | 2 | alex | female | 48 | 201 | 201 | 人力资源 | | 2 | alex | female | 48 | 201 | 202 | 销售 | | 2 | alex | female | 48 | 201 | 203 | 运营 | | 3 | wupeiqi | male | 38 | 201 | 200 | 技术 | | 3 | wupeiqi | male | 38 | 201 | 201 | 人力资源 | | 3 | wupeiqi | male | 38 | 201 | 202 | 销售 | | 3 | wupeiqi | male | 38 | 201 | 203 | 运营 | | 4 | yuanhao | female | 28 | 202 | 200 | 技术 | | 4 | yuanhao | female | 28 | 202 | 201 | 人力资源 | | 4 | yuanhao | female | 28 | 202 | 202 | 销售 | | 4 | yuanhao | female | 28 | 202 | 203 | 运营 | | 5 | liwenzhou | male | 18 | 200 | 200 | 技术 | | 5 | liwenzhou | male | 18 | 200 | 201 | 人力资源 | | 5 | liwenzhou | male | 18 | 200 | 202 | 销售 | | 5 | liwenzhou | male | 18 | 200 | 203 | 运营 | | 6 | jingliyang | female | 18 | 204 | 200 | 技术 | | 6 | jingliyang | female | 18 | 204 | 201 | 人力资源 | | 6 | jingliyang | female | 18 | 204 | 202 | 销售 | | 6 | jingliyang | female | 18 | 204 | 203 | 运营 | +----+------------+--------+------+--------+------+--------------+ 2 内连接：只连接匹配的行 #找两张表共有的部分，相当于利用条件从笛卡尔积结果中筛选出了正确的结果 #department没有204这个部门，因而employee表中关于204这条员工信息没有匹配出来 mysql> select employee.id,employee.name,employee.age,employee.sex,department.name from employee inner join department on employee.dep_id=department.id; +----+-----------+------+--------+--------------+ | id | name | age | sex | name | +----+-----------+------+--------+--------------+ | 1 | egon | 18 | male | 技术 | | 2 | alex | 48 | female | 人力资源 | | 3 | wupeiqi | 38 | male | 人力资源 | | 4 | yuanhao | 28 | female | 销售 | | 5 | liwenzhou | 18 | male | 技术 | +----+-----------+------+--------+--------------+ #上述sql等同于 mysql> select employee.id,employee.name,employee.age,employee.sex,department.name from employee,department where employee.dep_id=department.id; 3 外链接之左连接：优先显示左表全部记录 #以左表为准，即找出所有员工信息，当然包括没有部门的员工 #本质就是：在内连接的基础上增加左边有右边没有的结果 mysql> select employee.id,employee.name,department.name as depart_name from employee left join department on employee.dep_id=department.id; +----+------------+--------------+ | id | name | depart_name | +----+------------+--------------+ | 1 | egon | 技术 | | 5 | liwenzhou | 技术 | | 2 | alex | 人力资源 | | 3 | wupeiqi | 人力资源 | | 4 | yuanhao | 销售 | | 6 | jingliyang | NULL | +----+------------+--------------+ 4 外链接之右连接：优先显示右表全部记录 #以右表为准，即找出所有部门信息，包括没有员工的部门 #本质就是：在内连接的基础上增加右边有左边没有的结果 mysql> select employee.id,employee.name,department.name as depart_name from employee right join department on employee.dep_id=department.id; +------+-----------+--------------+ | id | name | depart_name | +------+-----------+--------------+ | 1 | egon | 技术 | | 2 | alex | 人力资源 | | 3 | wupeiqi | 人力资源 | | 4 | yuanhao | 销售 | | 5 | liwenzhou | 技术 | | NULL | NULL | 运营 | +------+-----------+--------------+ 5 全外连接：显示左右两个表全部记录 全外连接：在内连接的基础上增加左边有右边没有的和右边有左边没有的结果 #注意：mysql不支持全外连接 full JOIN #强调：mysql可以使用此种方式间接实现全外连接 select * from employee left join department on employee.dep_id = department.id union select * from employee right join department on employee.dep_id = department.id ; #查看结果 +------+------------+--------+------+--------+------+--------------+ | id | name | sex | age | dep_id | id | name | +------+------------+--------+------+--------+------+--------------+ | 1 | egon | male | 18 | 200 | 200 | 技术 | | 5 | liwenzhou | male | 18 | 200 | 200 | 技术 | | 2 | alex | female | 48 | 201 | 201 | 人力资源 | | 3 | wupeiqi | male | 38 | 201 | 201 | 人力资源 | | 4 | yuanhao | female | 28 | 202 | 202 | 销售 | | 6 | jingliyang | female | 18 | 204 | NULL | NULL | | NULL | NULL | NULL | NULL | NULL | 203 | 运营 | +------+------------+--------+------+--------+------+--------------+ #注意 union与union all的区别：union会去掉相同的纪录 三 符合条件连接查询 #示例1：以内连接的方式查询employee和department表，并且employee表中的age字段值必须大于25,即找出年龄大于25岁的员工以及员工所在的部门 select employee.name,department.name from employee inner join department on employee.dep_id = department.id where age > 25; #示例2：以内连接的方式查询employee和department表，并且以age字段的升序方式显示 select employee.id,employee.name,employee.age,department.name from employee,department where employee.dep_id = department.id and age > 25 order by age asc; 四 子查询 #1：子查询是将一个查询语句嵌套在另一个查询语句中。 #2：内层查询语句的查询结果，可以为外层查询语句提供查询条件。 #3：子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS等关键字 #4：还可以包含比较运算符：= 、 !=、> 、1 带IN关键字的子查询 #查询平均年龄在25岁以上的部门名 select id,name from department where id in (select dep_id from employee group by dep_id having avg(age) > 25); #查看技术部员工姓名 select name from employee where dep_id in (select id from department where name='技术'); #查看不足1人的部门名(子查询得到的是有人的部门id) select name from department where id not in (select distinct dep_id from employee); 2 带比较运算符的子查询 #比较运算符：=、!=、>、>=、 #查询大于所有人平均年龄的员工名与年龄 mysql> select name,age from emp where age > (select avg(age) from emp); +---------+------+ | name | age | +---------+------+ | alex | 48 | | wupeiqi | 38 | +---------+------+ rows in set (0.00 sec) #查询大于部门内平均年龄的员工名、年龄 select t1.name,t1.age from emp t1 inner join (select dep_id,avg(age) avg_age from emp group by dep_id) t2 on t1.dep_id = t2.dep_id where t1.age > t2.avg_age; 3 带EXISTS关键字的子查询 EXISTS关字键字表示存在。在使用EXISTS关键字时，内层查询语句不返回查询的记录。 而是返回一个真假值。True或False 当返回True时，外层查询语句将进行查询；当返回值为False时，外层查询语句不进行查询 #department表中存在dept_id=203，Ture mysql> select * from employee -> where exists -> (select id from department where id=200); +----+------------+--------+------+--------+ | id | name | sex | age | dep_id | +----+------------+--------+------+--------+ | 1 | egon | male | 18 | 200 | | 2 | alex | female | 48 | 201 | | 3 | wupeiqi | male | 38 | 201 | | 4 | yuanhao | female | 28 | 202 | | 5 | liwenzhou | male | 18 | 200 | | 6 | jingliyang | female | 18 | 204 | +----+------------+--------+------+--------+ #department表中存在dept_id=205，False mysql> select * from employee -> where exists -> (select id from department where id=204); Empty set (0.00 sec) 练习：查询每个部门最新入职的那位员工 准备表和记录 company.employee 员工id id int 姓名 emp_name varchar 性别 sex enum 年龄 age int 入职日期 hire_date date 岗位 post varchar 职位描述 post_comment varchar 薪水 salary double 办公室 office int 部门编号 depart_id int #创建表 create table employee( id int not null unique auto_increment, name varchar(20) not null, sex enum('male','female') not null default 'male', #大部分是男的 age int(3) unsigned not null default 28, hire_date date not null, post varchar(50), post_comment varchar(100), salary double(15,2), office int, #一个部门一个屋子 depart_id int ); #查看表结构 mysql> desc employee; +--------------+-----------------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +--------------+-----------------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | name | varchar(20) | NO | | NULL | | | sex | enum('male','female') | NO | | male | | | age | int(3) unsigned | NO | | 28 | | | hire_date | date | NO | | NULL | | | post | varchar(50) | YES | | NULL | | | post_comment | varchar(100) | YES | | NULL | | | salary | double(15,2) | YES | | NULL | | | office | int(11) | YES | | NULL | | | depart_id | int(11) | YES | | NULL | | +--------------+-----------------------+------+-----+---------+----------------+ #插入记录 #三个部门：教学，销售，运营 insert into employee(name,sex,age,hire_date,post,salary,office,depart_id) values ('egon','male',18,'20170301','老男孩驻沙河办事处外交大使',7300.33,401,1), #以下是教学部 ('alex','male',78,'20150302','teacher',1000000.31,401,1), ('wupeiqi','male',81,'20130305','teacher',8300,401,1), ('yuanhao','male',73,'20140701','teacher',3500,401,1), ('liwenzhou','male',28,'20121101','teacher',2100,401,1), ('jingliyang','female',18,'20110211','teacher',9000,401,1), ('jinxin','male',18,'19000301','teacher',30000,401,1), ('成龙','male',48,'20101111','teacher',10000,401,1), ('歪歪','female',48,'20150311','sale',3000.13,402,2),#以下是销售部门 ('丫丫','female',38,'20101101','sale',2000.35,402,2), ('丁丁','female',18,'20110312','sale',1000.37,402,2), ('星星','female',18,'20160513','sale',3000.29,402,2), ('格格','female',28,'20170127','sale',4000.33,402,2), ('张野','male',28,'20160311','operation',10000.13,403,3), #以下是运营部门 ('程咬金','male',18,'19970312','operation',20000,403,3), ('程咬银','female',18,'20130311','operation',19000,403,3), ('程咬铜','male',18,'20150411','operation',18000,403,3), ('程咬铁','female',18,'20140512','operation',17000,403,3) ; #ps：如果在windows系统中，插入中文字符，select的结果为空白，可以将所有字符编码统一设置成gbk SELECT * FROM emp AS t1 INNER JOIN ( SELECT post, max(hire_date) max_date FROM emp GROUP BY post ) AS t2 ON t1.post = t2.post WHERE t1.hire_date = t2.max_date; 答案一（链表） mysql> select (select t2.name from emp as t2 where t2.post=t1.post order by hire_date desc limit 1) from emp as t1 group by post; +---------------------------------------------------------------------------------------+ | (select t2.name from emp as t2 where t2.post=t1.post order by hire_date desc limit 1) | +---------------------------------------------------------------------------------------+ | 张野 | | 格格 | | alex | | egon | +---------------------------------------------------------------------------------------+ rows in set (0.00 sec) mysql> select (select t2.id from emp as t2 where t2.post=t1.post order by hire_date desc limit 1) from emp as t1 group by post; +-------------------------------------------------------------------------------------+ | (select t2.id from emp as t2 where t2.post=t1.post order by hire_date desc limit 1) | +-------------------------------------------------------------------------------------+ | 14 | | 13 | | 2 | | 1 | +-------------------------------------------------------------------------------------+ rows in set (0.00 sec) #正确答案 mysql> select t3.name,t3.post,t3.hire_date from emp as t3 where id in (select (select id from emp as t2 where t2.post=t1.post order by hire_date desc limit 1) from emp as t1 group by post); +--------+-----------------------------------------+------------+ | name | post | hire_date | +--------+-----------------------------------------+------------+ | egon | 老男孩驻沙河办事处外交大使 | 2017-03-01 | | alex | teacher | 2015-03-02 | | 格格 | sale | 2017-01-27 | | 张野 | operation | 2016-03-11 | +--------+-----------------------------------------+------------+ rows in set (0.00 sec) 答案二（子查询） 五 综合练习 init.sql文件内容 /* 数据导入： Navicat Premium Data Transfer Source Server : localhost Source Server Type : MySQL Source Server Version : 50624 Source Host : localhost Source Database : sqlexam Target Server Type : MySQL Target Server Version : 50624 File Encoding : utf-8 Date: 10/21/2016 06:46:46 AM */ SET NAMES utf8; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for `class` -- ---------------------------- DROP TABLE IF EXISTS `class`; CREATE TABLE `class` ( `cid` int(11) NOT NULL AUTO_INCREMENT, `caption` varchar(32) NOT NULL, PRIMARY KEY (`cid`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of `class` -- ---------------------------- BEGIN; INSERT INTO `class` VALUES ('1', '三年二班'), ('2', '三年三班'), ('3', '一年二班'), ('4', '二年九班'); COMMIT; -- ---------------------------- -- Table structure for `course` -- ---------------------------- DROP TABLE IF EXISTS `course`; CREATE TABLE `course` ( `cid` int(11) NOT NULL AUTO_INCREMENT, `cname` varchar(32) NOT NULL, `teacher_id` int(11) NOT NULL, PRIMARY KEY (`cid`), KEY `fk_course_teacher` (`teacher_id`), CONSTRAINT `fk_course_teacher` FOREIGN KEY (`teacher_id`) REFERENCES `teacher` (`tid`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of `course` -- ---------------------------- BEGIN; INSERT INTO `course` VALUES ('1', '生物', '1'), ('2', '物理', '2'), ('3', '体育', '3'), ('4', '美术', '2'); COMMIT; -- ---------------------------- -- Table structure for `score` -- ---------------------------- DROP TABLE IF EXISTS `score`; CREATE TABLE `score` ( `sid` int(11) NOT NULL AUTO_INCREMENT, `student_id` int(11) NOT NULL, `course_id` int(11) NOT NULL, `num` int(11) NOT NULL, PRIMARY KEY (`sid`), KEY `fk_score_student` (`student_id`), KEY `fk_score_course` (`course_id`), CONSTRAINT `fk_score_course` FOREIGN KEY (`course_id`) REFERENCES `course` (`cid`), CONSTRAINT `fk_score_student` FOREIGN KEY (`student_id`) REFERENCES `student` (`sid`) ) ENGINE=InnoDB AUTO_INCREMENT=53 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of `score` -- ---------------------------- BEGIN; INSERT INTO `score` VALUES ('1', '1', '1', '10'), ('2', '1', '2', '9'), ('5', '1', '4', '66'), ('6', '2', '1', '8'), ('8', '2', '3', '68'), ('9', '2', '4', '99'), ('10', '3', '1', '77'), ('11', '3', '2', '66'), ('12', '3', '3', '87'), ('13', '3', '4', '99'), ('14', '4', '1', '79'), ('15', '4', '2', '11'), ('16', '4', '3', '67'), ('17', '4', '4', '100'), ('18', '5', '1', '79'), ('19', '5', '2', '11'), ('20', '5', '3', '67'), ('21', '5', '4', '100'), ('22', '6', '1', '9'), ('23', '6', '2', '100'), ('24', '6', '3', '67'), ('25', '6', '4', '100'), ('26', '7', '1', '9'), ('27', '7', '2', '100'), ('28', '7', '3', '67'), ('29', '7', '4', '88'), ('30', '8', '1', '9'), ('31', '8', '2', '100'), ('32', '8', '3', '67'), ('33', '8', '4', '88'), ('34', '9', '1', '91'), ('35', '9', '2', '88'), ('36', '9', '3', '67'), ('37', '9', '4', '22'), ('38', '10', '1', '90'), ('39', '10', '2', '77'), ('40', '10', '3', '43'), ('41', '10', '4', '87'), ('42', '11', '1', '90'), ('43', '11', '2', '77'), ('44', '11', '3', '43'), ('45', '11', '4', '87'), ('46', '12', '1', '90'), ('47', '12', '2', '77'), ('48', '12', '3', '43'), ('49', '12', '4', '87'), ('52', '13', '3', '87'); COMMIT; -- ---------------------------- -- Table structure for `student` -- ---------------------------- DROP TABLE IF EXISTS `student`; CREATE TABLE `student` ( `sid` int(11) NOT NULL AUTO_INCREMENT, `gender` char(1) NOT NULL, `class_id` int(11) NOT NULL, `sname` varchar(32) NOT NULL, PRIMARY KEY (`sid`), KEY `fk_class` (`class_id`), CONSTRAINT `fk_class` FOREIGN KEY (`class_id`) REFERENCES `class` (`cid`) ) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of `student` -- ---------------------------- BEGIN; INSERT INTO `student` VALUES ('1', '男', '1', '理解'), ('2', '女', '1', '钢蛋'), ('3', '男', '1', '张三'), ('4', '男', '1', '张一'), ('5', '女', '1', '张二'), ('6', '男', '1', '张四'), ('7', '女', '2', '铁锤'), ('8', '男', '2', '李三'), ('9', '男', '2', '李一'), ('10', '女', '2', '李二'), ('11', '男', '2', '李四'), ('12', '女', '3', '如花'), ('13', '男', '3', '刘三'), ('14', '男', '3', '刘一'), ('15', '女', '3', '刘二'), ('16', '男', '3', '刘四'); COMMIT; -- ---------------------------- -- Table structure for `teacher` -- ---------------------------- DROP TABLE IF EXISTS `teacher`; CREATE TABLE `teacher` ( `tid` int(11) NOT NULL AUTO_INCREMENT, `tname` varchar(32) NOT NULL, PRIMARY KEY (`tid`) ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of `teacher` -- ---------------------------- BEGIN; INSERT INTO `teacher` VALUES ('1', '张磊老师'), ('2', '李平老师'), ('3', '刘海燕老师'), ('4', '朱云海老师'), ('5', '李杰老师'); COMMIT; SET FOREIGN_KEY_CHECKS = 1; 从init.sql文件中导入数据 #准备表、记录 mysql> create database db1; mysql> use db1; mysql> source /root/init.sql 表结构为 SQL逻辑查询语句执行顺序 题目 1、查询所有的课程的名称以及对应的任课老师姓名 2、查询学生表中男女生各有多少人 3、查询物理成绩等于100的学生的姓名 4、查询平均成绩大于八十分的同学的姓名和平均成绩 5、查询所有学生的学号，姓名，选课数，总成绩 6、 查询姓李老师的个数 7、 查询没有报李平老师课的学生姓名 8、 查询物理课程比生物课程高的学生的学号 9、 查询没有同时选修物理课程和体育课程的学生姓名 10、查询挂科超过两门(包括两门)的学生姓名和班级 、查询选修了所有课程的学生姓名 12、查询李平老师教的课程的所有成绩记录 13、查询全部学生都选修了的课程号和课程名 14、查询每门课程被选修的次数 15、查询之选修了一门课程的学生姓名和学号 16、查询所有学生考出的成绩并按从高到低排序（成绩去重） 17、查询平均成绩大于85的学生姓名和平均成绩 18、查询生物成绩不及格的学生姓名和对应生物分数 19、查询在所有选修了李平老师课程的学生中，这些课程(李平老师的课程，不是所有课程)平均成绩最高的学生姓名 20、查询每门课程成绩最好的前两名学生姓名 21、查询不同课程但成绩相同的学号，课程号，成绩 22、查询没学过“叶平”老师课程的学生姓名以及选修的课程名称； 23、查询所有选修了学号为1的同学选修过的一门或者多门课程的同学学号和姓名； 24、任课最多的老师中学生单科成绩最高的学生姓名 参考答案 参考答案:http://www.cnblogs.com/linhaifeng/articles/7895711.html "},"MySQL学习/04-MySQL数据操作/4、MySQL逻辑查询语句执行顺序.html":{"url":"MySQL学习/04-MySQL数据操作/4、MySQL逻辑查询语句执行顺序.html","title":"4、MySQL逻辑查询语句执行顺序","keywords":"","body":"4、MySQL逻辑查询语句执行顺序 一 SELECT语句关键字的定义顺序 SELECT DISTINCT FROM JOIN ON WHERE GROUP BY HAVING ORDER BY LIMIT 二 SELECT语句关键字的执行顺序 (7) SELECT (8) DISTINCT (1) FROM (3) JOIN (2) ON (4) WHERE (5) GROUP BY (6) HAVING (9) ORDER BY (10) LIMIT 三 准备表和数据 新建一个测试数据库TestDB； create database TestDB; 2.创建测试表table1和table2； CREATE TABLE table1 ( customer_id VARCHAR(10) NOT NULL, city VARCHAR(10) NOT NULL, PRIMARY KEY(customer_id) )ENGINE=INNODB DEFAULT CHARSET=UTF8; CREATE TABLE table2 ( order_id INT NOT NULL auto_increment, customer_id VARCHAR(10), PRIMARY KEY(order_id) )ENGINE=INNODB DEFAULT CHARSET=UTF8; 3.插入测试数据； INSERT INTO table1(customer_id,city) VALUES('163','hangzhou'); INSERT INTO table1(customer_id,city) VALUES('9you','shanghai'); INSERT INTO table1(customer_id,city) VALUES('tx','hangzhou'); INSERT INTO table1(customer_id,city) VALUES('baidu','hangzhou'); INSERT INTO table2(customer_id) VALUES('163'); INSERT INTO table2(customer_id) VALUES('163'); INSERT INTO table2(customer_id) VALUES('9you'); INSERT INTO table2(customer_id) VALUES('9you'); INSERT INTO table2(customer_id) VALUES('9you'); INSERT INTO table2(customer_id) VALUES('tx'); INSERT INTO table2(customer_id) VALUES(NULL); 准备工作做完以后，table1和table2看起来应该像下面这样： mysql> select * from table1; +-------------+----------+ | customer_id | city | +-------------+----------+ | 163 | hangzhou | | 9you | shanghai | | baidu | hangzhou | | tx | hangzhou | +-------------+----------+ rows in set (0.00 sec) mysql> select * from table2; +----------+-------------+ | order_id | customer_id | +----------+-------------+ | 1 | 163 | | 2 | 163 | | 3 | 9you | | 4 | 9you | | 5 | 9you | | 6 | tx | | 7 | NULL | +----------+-------------+ rows in set (0.00 sec) 四 准备SQL逻辑查询测试语句 #查询来自杭州，并且订单数少于2的客户。 SELECT a.customer_id, COUNT(b.order_id) as total_orders FROM table1 AS a LEFT JOIN table2 AS b ON a.customer_id = b.customer_id WHERE a.city = 'hangzhou' GROUP BY a.customer_id HAVING count(b.order_id) 五 执行顺序分析 在这些SQL语句的执行过程中，都会产生一个虚拟表，用来保存SQL语句的执行结果（这是重点），我现在就来跟踪这个虚拟表的变化，得到最终的查询结果的过程，来分析整个SQL逻辑查询的执行顺序和过程。 执行FROM语句 第一步，执行FROM语句。我们首先需要知道最开始从哪个表开始的，这就是FROM告诉我们的。现在有了和两个表，我们到底从哪个表开始，还是从两个表进行某种联系以后再开始呢？它们之间如何产生联系呢？——笛卡尔积 关于什么是笛卡尔积，请自行Google补脑。经过FROM语句对两个表执行笛卡尔积，会得到一个虚拟表，暂且叫VT1（vitual table 1），内容如下： +-------------+----------+----------+-------------+ | customer_id | city | order_id | customer_id | +-------------+----------+----------+-------------+ | 163 | hangzhou | 1 | 163 | | 9you | shanghai | 1 | 163 | | baidu | hangzhou | 1 | 163 | | tx | hangzhou | 1 | 163 | | 163 | hangzhou | 2 | 163 | | 9you | shanghai | 2 | 163 | | baidu | hangzhou | 2 | 163 | | tx | hangzhou | 2 | 163 | | 163 | hangzhou | 3 | 9you | | 9you | shanghai | 3 | 9you | | baidu | hangzhou | 3 | 9you | | tx | hangzhou | 3 | 9you | | 163 | hangzhou | 4 | 9you | | 9you | shanghai | 4 | 9you | | baidu | hangzhou | 4 | 9you | | tx | hangzhou | 4 | 9you | | 163 | hangzhou | 5 | 9you | | 9you | shanghai | 5 | 9you | | baidu | hangzhou | 5 | 9you | | tx | hangzhou | 5 | 9you | | 163 | hangzhou | 6 | tx | | 9you | shanghai | 6 | tx | | baidu | hangzhou | 6 | tx | | tx | hangzhou | 6 | tx | | 163 | hangzhou | 7 | NULL | | 9you | shanghai | 7 | NULL | | baidu | hangzhou | 7 | NULL | | tx | hangzhou | 7 | NULL | +-------------+----------+----------+-------------+ 总共有28（table1的记录条数 * table2的记录条数）条记录。这就是VT1的结果，接下来的操作就在VT1的基础上进行。 执行ON过滤 执行完笛卡尔积以后，接着就进行ON a.customer_id = b.customer_id条件过滤，根据ON中指定的条件，去掉那些不符合条件的数据，得到VT2表，内容如下： +-------------+----------+----------+-------------+ | customer_id | city | order_id | customer_id | +-------------+----------+----------+-------------+ | 163 | hangzhou | 1 | 163 | | 163 | hangzhou | 2 | 163 | | 9you | shanghai | 3 | 9you | | 9you | shanghai | 4 | 9you | | 9you | shanghai | 5 | 9you | | tx | hangzhou | 6 | tx | +-------------+----------+----------+-------------+ VT2就是经过ON条件筛选以后得到的有用数据，而接下来的操作将在VT2的基础上继续进行。 添加外部行 这一步只有在连接类型为OUTER JOIN时才发生，如LEFT OUTER JOIN、RIGHT OUTER JOIN和FULL OUTER JOIN。在大多数的时候，我们都是会省略掉OUTER关键字的，但OUTER表示的就是外部行的概念。 LEFT OUTER JOIN把左表记为保留表，得到的结果为： +-------------+----------+----------+-------------+ | customer_id | city | order_id | customer_id | +-------------+----------+----------+-------------+ | 163 | hangzhou | 1 | 163 | | 163 | hangzhou | 2 | 163 | | 9you | shanghai | 3 | 9you | | 9you | shanghai | 4 | 9you | | 9you | shanghai | 5 | 9you | | tx | hangzhou | 6 | tx | | baidu | hangzhou | NULL | NULL | +-------------+----------+----------+-------------+ RIGHT OUTER JOIN把右表记为保留表，得到的结果为： +-------------+----------+----------+-------------+ | customer_id | city | order_id | customer_id | +-------------+----------+----------+-------------+ | 163 | hangzhou | 1 | 163 | | 163 | hangzhou | 2 | 163 | | 9you | shanghai | 3 | 9you | | 9you | shanghai | 4 | 9you | | 9you | shanghai | 5 | 9you | | tx | hangzhou | 6 | tx | | NULL | NULL | 7 | NULL | +-------------+----------+----------+-------------+ FULL OUTER JOIN把左右表都作为保留表，得到的结果为： +-------------+----------+----------+-------------+ | customer_id | city | order_id | customer_id | +-------------+----------+----------+-------------+ | 163 | hangzhou | 1 | 163 | | 163 | hangzhou | 2 | 163 | | 9you | shanghai | 3 | 9you | | 9you | shanghai | 4 | 9you | | 9you | shanghai | 5 | 9you | | tx | hangzhou | 6 | tx | | baidu | hangzhou | NULL | NULL | | NULL | NULL | 7 | NULL | +-------------+----------+----------+-------------+ 添加外部行的工作就是在VT2表的基础上添加保留表中被过滤条件过滤掉的数据，非保留表中的数据被赋予NULL值，最后生成虚拟表VT3。 由于我在准备的测试SQL查询逻辑语句中使用的是LEFT JOIN，过滤掉了以下这条数据： | baidu | hangzhou | NULL | NULL | 现在就把这条数据添加到VT2表中，得到的VT3表如下： +-------------+----------+----------+-------------+ | customer_id | city | order_id | customer_id | +-------------+----------+----------+-------------+ | 163 | hangzhou | 1 | 163 | | 163 | hangzhou | 2 | 163 | | 9you | shanghai | 3 | 9you | | 9you | shanghai | 4 | 9you | | 9you | shanghai | 5 | 9you | | tx | hangzhou | 6 | tx | | baidu | hangzhou | NULL | NULL | +-------------+----------+----------+-------------+ 接下来的操作都会在该VT3表上进行。 执行WHERE过滤 对添加外部行得到的VT3进行WHERE过滤，只有符合的记录才会输出到虚拟表VT4中。当我们执行WHERE a.city = 'hangzhou'的时候，就会得到以下内容，并存在虚拟表VT4中： +-------------+----------+----------+-------------+ | customer_id | city | order_id | customer_id | +-------------+----------+----------+-------------+ | 163 | hangzhou | 1 | 163 | | 163 | hangzhou | 2 | 163 | | tx | hangzhou | 6 | tx | | baidu | hangzhou | NULL | NULL | +-------------+----------+----------+-------------+ 但是在使用WHERE子句时，需要注意以下两点： 由于数据还没有分组，因此现在还不能在WHERE过滤器中使用where_condition=MIN(col)这类对分组统计的过滤； 由于还没有进行列的选取操作，因此在SELECT中使用列的别名也是不被允许的，如：SELECT city as c FROM t WHERE c='shanghai';是不允许出现的。 执行GROUP BY分组 GROU BY子句主要是对使用WHERE子句得到的虚拟表进行分组操作。我们执行测试语句中的GROUP BY a.customer_id，就会得到以下内容(默认只显示组内第一条)： +-------------+----------+----------+-------------+ | customer_id | city | order_id | customer_id | +-------------+----------+----------+-------------+ | 163 | hangzhou | 1 | 163 | | baidu | hangzhou | NULL | NULL | | tx | hangzhou | 6 | tx | +-------------+----------+----------+-------------+ 得到的内容会存入虚拟表VT5中，此时，我们就得到了一个VT5虚拟表，接下来的操作都会在该表上完成。 执行HAVING过滤 HAVING子句主要和GROUP BY子句配合使用，对分组得到的VT5虚拟表进行条件过滤。当我执行测试语句中的HAVING count(b.order_id) +-------------+----------+----------+-------------+ | customer_id | city | order_id | customer_id | +-------------+----------+----------+-------------+ | baidu | hangzhou | NULL | NULL | | tx | hangzhou | 6 | tx | +-------------+----------+----------+-------------+ 这就是虚拟表VT6。 SELECT列表 现在才会执行到SELECT子句，不要以为SELECT子句被写在第一行，就是第一个被执行的。 我们执行测试语句中的SELECT a.customer_id, COUNT(b.order_id) as total_orders，从虚拟表VT6中选择出我们需要的内容。我们将得到以下内容： +-------------+--------------+ | customer_id | total_orders | +-------------+--------------+ | baidu | 0 | | tx | 1 | +-------------+--------------+ 还没有完，这只是虚拟表VT7。 执行DISTINCT子句 如果在查询中指定了DISTINCT子句，则会创建一张内存临时表（如果内存放不下，就需要存放在硬盘了）。这张临时表的表结构和上一步产生的虚拟表VT7是一样的，不同的是对进行DISTINCT操作的列增加了一个唯一索引，以此来除重复数据。 由于我的测试SQL语句中并没有使用DISTINCT，所以，在该查询中，这一步不会生成一个虚拟表。 执行ORDER BY子句 对虚拟表中的内容按照指定的列进行排序，然后返回一个新的虚拟表，我们执行测试SQL语句中的ORDER BY total_orders DESC，就会得到以下内容： +-------------+--------------+ | customer_id | total_orders | +-------------+--------------+ | tx | 1 | | baidu | 0 | +-------------+--------------+ 可以看到这是对total_orders列进行降序排列的。上述结果会存储在VT8中。 执行LIMIT子句 LIMIT子句从上一步得到的VT8虚拟表中选出从指定位置开始的指定行数据。对于没有应用ORDER BY的LIMIT子句，得到的结果同样是无序的，所以，很多时候，我们都会看到LIMIT子句会和ORDER BY子句一起使用。 MySQL数据库的LIMIT支持如下形式的选择： LIMIT n, m 表示从第n条记录开始选择m条记录。而很多开发人员喜欢使用该语句来解决分页问题。对于小数据，使用LIMIT子句没有任何问题，当数据量非常大的时候，使用LIMIT n, m是非常低效的。因为LIMIT的机制是每次都是从头开始扫描，如果需要从第60万行开始，读取3条数据，就需要先扫描定位到60万行，然后再进行读取，而扫描的过程是一个非常低效的过程。所以，对于大数据处理时，是非常有必要在应用层建立一定的缓存机制（现在的大数据处理，大都使用缓存） "},"MySQL学习/04-MySQL数据操作/5、多表查询解析.html":{"url":"MySQL学习/04-MySQL数据操作/5、多表查询解析.html","title":"5、多表查询解析","keywords":"","body":"多表查询作业答案 一 题目 1、查询所有的课程的名称以及对应的任课老师姓名 2、查询学生表中男女生各有多少人 3、查询物理成绩等于100的学生的姓名 4、查询平均成绩大于八十分的同学的姓名和平均成绩 5、查询所有学生的学号，姓名，选课数，总成绩 6、 查询姓李老师的个数 7、 查询没有报李平老师课的学生姓名 8、 查询物理课程比生物课程高的学生的学号 9、 查询没有同时选修物理课程和体育课程的学生姓名 10、查询挂科超过两门(包括两门)的学生姓名和班级 、查询选修了所有课程的学生姓名 12、查询李平老师教的课程的所有成绩记录 13、查询全部学生都选修了的课程号和课程名 14、查询每门课程被选修的次数 15、查询之选修了一门课程的学生姓名和学号 16、查询所有学生考出的成绩并按从高到低排序（成绩去重） 17、查询平均成绩大于85的学生姓名和平均成绩 18、查询生物成绩不及格的学生姓名和对应生物分数 19、查询在所有选修了李平老师课程的学生中，这些课程(李平老师的课程，不是所有课程)平均成绩最高的学生姓名 20、查询每门课程成绩最好的前两名学生姓名 21、查询不同课程但成绩相同的学号，课程号，成绩 22、查询没学过“叶平”老师课程的学生姓名以及选修的课程名称； 23、查询所有选修了学号为1的同学选修过的一门或者多门课程的同学学号和姓名； 24、任课最多的老师中学生单科成绩最高的学生姓名 二 答案 #1、查询所有的课程的名称以及对应的任课老师姓名 SELECT course.cname, teacher.tname FROM course INNER JOIN teacher ON course.teacher_id = teacher.tid; #2、查询学生表中男女生各有多少人 SELECT gender 性别, count(1) 人数 FROM student GROUP BY gender; #3、查询物理成绩等于100的学生的姓名 SELECT student.sname FROM student WHERE sid IN ( SELECT student_id FROM score INNER JOIN course ON score.course_id = course.cid WHERE course.cname = '物理' AND score.num = 100 ); #4、查询平均成绩大于八十分的同学的姓名和平均成绩 SELECT student.sname, t1.avg_num FROM student INNER JOIN ( SELECT student_id, avg(num) AS avg_num FROM score GROUP BY student_id HAVING avg(num) > 80 ) AS t1 ON student.sid = t1.student_id; #5、查询所有学生的学号，姓名，选课数，总成绩(注意：对于那些没有选修任何课程的学生也算在内) SELECT student.sid, student.sname, t1.course_num, t1.total_num FROM student LEFT JOIN ( SELECT student_id, COUNT(course_id) course_num, sum(num) total_num FROM score GROUP BY student_id ) AS t1 ON student.sid = t1.student_id; #6、 查询姓李老师的个数 SELECT count(tid) FROM teacher WHERE tname LIKE '李%'; #7、 查询没有报李平老师课的学生姓名(找出报名李平老师课程的学生，然后取反就可以) SELECT student.sname FROM student WHERE sid NOT IN ( SELECT DISTINCT student_id FROM score WHERE course_id IN ( SELECT course.cid FROM course INNER JOIN teacher ON course.teacher_id = teacher.tid WHERE teacher.tname = '李平老师' ) ); #8、 查询物理课程比生物课程高的学生的学号(分别得到物理成绩表与生物成绩表，然后连表即可) SELECT t1.student_id FROM ( SELECT student_id, num FROM score WHERE course_id = ( SELECT cid FROM course WHERE cname = '物理' ) ) AS t1 INNER JOIN ( SELECT student_id, num FROM score WHERE course_id = ( SELECT cid FROM course WHERE cname = '生物' ) ) AS t2 ON t1.student_id = t2.student_id WHERE t1.num > t2.num; #9、 查询没有同时选修物理课程和体育课程的学生姓名(没有同时选修指的是选修了一门的，思路是得到物理+体育课程的学生信息表，然后基于学生分组，统计count(课程)=1) SELECT student.sname FROM student WHERE sid IN ( SELECT student_id FROM score WHERE course_id IN ( SELECT cid FROM course WHERE cname = '物理' OR cname = '体育' ) GROUP BY student_id HAVING COUNT(course_id) = 1 ); #10、查询挂科超过两门(包括两门)的学生姓名和班级(求出=2) SELECT student.sname, class.caption FROM student INNER JOIN ( SELECT student_id FROM score WHERE num = 2 ) AS t1 INNER JOIN class ON student.sid = t1.student_id AND student.class_id = class.cid; #11、查询选修了所有课程的学生姓名(先从course表统计课程的总数，然后基于score表按照student_id分组，统计课程数据等于课程总数即可) SELECT student.sname FROM student WHERE sid IN ( SELECT student_id FROM score GROUP BY student_id HAVING COUNT(course_id) = (SELECT count(cid) FROM course) ); #12、查询李平老师教的课程的所有成绩记录 SELECT * FROM score WHERE course_id IN ( SELECT cid FROM course INNER JOIN teacher ON course.teacher_id = teacher.tid WHERE teacher.tname = '李平老师' ); #13、查询全部学生都选修了的课程号和课程名(取所有学生数，然后基于score表的课程分组，找出count(student_id)等于学生数即可) SELECT cid, cname FROM course WHERE cid IN ( SELECT course_id FROM score GROUP BY course_id HAVING COUNT(student_id) = ( SELECT COUNT(sid) FROM student ) ); #14、查询每门课程被选修的次数 SELECT course_id, COUNT(student_id) FROM score GROUP BY course_id; #15、查询之选修了一门课程的学生姓名和学号 SELECT sid, sname FROM student WHERE sid IN ( SELECT student_id FROM score GROUP BY student_id HAVING COUNT(course_id) = 1 ); #16、查询所有学生考出的成绩并按从高到低排序（成绩去重） SELECT DISTINCT num FROM score ORDER BY num DESC; #17、查询平均成绩大于85的学生姓名和平均成绩 SELECT sname, t1.avg_num FROM student INNER JOIN ( SELECT student_id, avg(num) avg_num FROM score GROUP BY student_id HAVING AVG(num) > 85 ) t1 ON student.sid = t1.student_id; #18、查询生物成绩不及格的学生姓名和对应生物分数 SELECT sname 姓名, num 生物成绩 FROM score LEFT JOIN course ON score.course_id = course.cid LEFT JOIN student ON score.student_id = student.sid WHERE course.cname = '生物' AND score.num = t3.second_num AND score.num = t3.second_num AND score.num 导出现有数据库数据： mysqldump -u用户名 -p密码 数据库名称 >导出文件路径 # 结构+数据 mysqldump -u用户名 -p密码 -d 数据库名称 >导出文件路径 # 结构 导入现有数据库数据： mysqldump -uroot -p密码 数据库名称 /* Navicat Premium Data Transfer Source Server : localhost Source Server Type : MySQL Source Server Version : 50624 Source Host : localhost Source Database : sqlexam Target Server Type : MySQL Target Server Version : 50624 File Encoding : utf-8 Date: 10/21/2016 06:46:46 AM */ SET NAMES utf8; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for `class` -- ---------------------------- DROP TABLE IF EXISTS `class`; CREATE TABLE `class` ( `cid` int(11) NOT NULL AUTO_INCREMENT, `caption` varchar(32) NOT NULL, PRIMARY KEY (`cid`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of `class` -- ---------------------------- BEGIN; INSERT INTO `class` VALUES ('1', '三年二班'), ('2', '三年三班'), ('3', '一年二班'), ('4', '二年九班'); COMMIT; -- ---------------------------- -- Table structure for `course` -- ---------------------------- DROP TABLE IF EXISTS `course`; CREATE TABLE `course` ( `cid` int(11) NOT NULL AUTO_INCREMENT, `cname` varchar(32) NOT NULL, `teacher_id` int(11) NOT NULL, PRIMARY KEY (`cid`), KEY `fk_course_teacher` (`teacher_id`), CONSTRAINT `fk_course_teacher` FOREIGN KEY (`teacher_id`) REFERENCES `teacher` (`tid`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of `course` -- ---------------------------- BEGIN; INSERT INTO `course` VALUES ('1', '生物', '1'), ('2', '物理', '2'), ('3', '体育', '3'), ('4', '美术', '2'); COMMIT; -- ---------------------------- -- Table structure for `score` -- ---------------------------- DROP TABLE IF EXISTS `score`; CREATE TABLE `score` ( `sid` int(11) NOT NULL AUTO_INCREMENT, `student_id` int(11) NOT NULL, `course_id` int(11) NOT NULL, `num` int(11) NOT NULL, PRIMARY KEY (`sid`), KEY `fk_score_student` (`student_id`), KEY `fk_score_course` (`course_id`), CONSTRAINT `fk_score_course` FOREIGN KEY (`course_id`) REFERENCES `course` (`cid`), CONSTRAINT `fk_score_student` FOREIGN KEY (`student_id`) REFERENCES `student` (`sid`) ) ENGINE=InnoDB AUTO_INCREMENT=53 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of `score` -- ---------------------------- BEGIN; INSERT INTO `score` VALUES ('1', '1', '1', '10'), ('2', '1', '2', '9'), ('5', '1', '4', '66'), ('6', '2', '1', '8'), ('8', '2', '3', '68'), ('9', '2', '4', '99'), ('10', '3', '1', '77'), ('11', '3', '2', '66'), ('12', '3', '3', '87'), ('13', '3', '4', '99'), ('14', '4', '1', '79'), ('15', '4', '2', '11'), ('16', '4', '3', '67'), ('17', '4', '4', '100'), ('18', '5', '1', '79'), ('19', '5', '2', '11'), ('20', '5', '3', '67'), ('21', '5', '4', '100'), ('22', '6', '1', '9'), ('23', '6', '2', '100'), ('24', '6', '3', '67'), ('25', '6', '4', '100'), ('26', '7', '1', '9'), ('27', '7', '2', '100'), ('28', '7', '3', '67'), ('29', '7', '4', '88'), ('30', '8', '1', '9'), ('31', '8', '2', '100'), ('32', '8', '3', '67'), ('33', '8', '4', '88'), ('34', '9', '1', '91'), ('35', '9', '2', '88'), ('36', '9', '3', '67'), ('37', '9', '4', '22'), ('38', '10', '1', '90'), ('39', '10', '2', '77'), ('40', '10', '3', '43'), ('41', '10', '4', '87'), ('42', '11', '1', '90'), ('43', '11', '2', '77'), ('44', '11', '3', '43'), ('45', '11', '4', '87'), ('46', '12', '1', '90'), ('47', '12', '2', '77'), ('48', '12', '3', '43'), ('49', '12', '4', '87'), ('52', '13', '3', '87'); COMMIT; -- ---------------------------- -- Table structure for `student` -- ---------------------------- DROP TABLE IF EXISTS `student`; CREATE TABLE `student` ( `sid` int(11) NOT NULL AUTO_INCREMENT, `gender` char(1) NOT NULL, `class_id` int(11) NOT NULL, `sname` varchar(32) NOT NULL, PRIMARY KEY (`sid`), KEY `fk_class` (`class_id`), CONSTRAINT `fk_class` FOREIGN KEY (`class_id`) REFERENCES `class` (`cid`) ) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of `student` -- ---------------------------- BEGIN; INSERT INTO `student` VALUES ('1', '男', '1', '理解'), ('2', '女', '1', '钢蛋'), ('3', '男', '1', '张三'), ('4', '男', '1', '张一'), ('5', '女', '1', '张二'), ('6', '男', '1', '张四'), ('7', '女', '2', '铁锤'), ('8', '男', '2', '李三'), ('9', '男', '2', '李一'), ('10', '女', '2', '李二'), ('11', '男', '2', '李四'), ('12', '女', '3', '如花'), ('13', '男', '3', '刘三'), ('14', '男', '3', '刘一'), ('15', '女', '3', '刘二'), ('16', '男', '3', '刘四'); COMMIT; -- ---------------------------- -- Table structure for `teacher` -- ---------------------------- DROP TABLE IF EXISTS `teacher`; CREATE TABLE `teacher` ( `tid` int(11) NOT NULL AUTO_INCREMENT, `tname` varchar(32) NOT NULL, PRIMARY KEY (`tid`) ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of `teacher` -- ---------------------------- BEGIN; INSERT INTO `teacher` VALUES ('1', '张磊老师'), ('2', '李平老师'), ('3', '刘海燕老师'), ('4', '朱云海老师'), ('5', '李杰老师'); COMMIT; SET FOREIGN_KEY_CHECKS = 1; 2、查询“生物”课程比“物理”课程成绩高的所有学生的学号； 思路： 获取所有有生物课程的人（学号，成绩） - 临时表 获取所有有物理课程的人（学号，成绩） - 临时表 根据【学号】连接两个临时表： 学号 物理成绩 生物成绩 然后再进行筛选 select A.student_id,sw,ty from (select student_id,num as sw from score left join course on score.course_id = course.cid where course.cname = '生物') as A left join (select student_id,num as ty from score left join course on score.course_id = course.cid where course.cname = '体育') as B on A.student_id = B.student_id where sw > if(isnull(ty),0,ty); 3、查询平均成绩大于60分的同学的学号和平均成绩； 思路： 根据学生分组，使用avg获取平均值，通过having对avg进行筛选 select student_id,avg(num) from score group by student_id having avg(num) > 60 4、查询所有同学的学号、姓名、选课数、总成绩； select score.student_id,sum(score.num),count(score.student_id),student.sname from score left join student on score.student_id = student.sid group by score.student_id 5、查询姓“李”的老师的个数； select count(tid) from teacher where tname like '李%' select count(1) from (select tid from teacher where tname like '李%') as B 6、查询没学过“叶平”老师课的同学的学号、姓名； 思路： 先查到“李平老师”老师教的所有课ID 获取选过课的所有学生ID 学生表中筛选 select * from student where sid not in ( select DISTINCT student_id from score where score.course_id in ( select cid from course left join teacher on course.teacher_id = teacher.tid where tname = '李平老师' ) ) 7、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名； 思路： 先查到既选择001又选择002课程的所有同学 根据学生进行分组，如果学生数量等于2表示，两门均已选择 select student_id,sname from (select student_id,course_id from score where course_id = 1 or course_id = 2) as B left join student on B.student_id = student.sid group by student_id HAVING count(student_id) > 1 8、查询学过“叶平”老师所教的所有课的同学的学号、姓名； 同上，只不过将001和002变成 in (叶平老师的所有课) 9、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名； 同第1题 10、查询有课程成绩小于60分的同学的学号、姓名； select sid,sname from student where sid in ( select distinct student_id from score where num 60 then 1 else 0 END)/count(1)*100 as percent from score group by course_id order by avgnum asc,percent desc; 20、课程平均分从高到低显示（现实任课老师）； select avg(if(isnull(score.num),0,score.num)),teacher.tname from course left join score on course.cid = score.course_id left join teacher on course.teacher_id = teacher.tid group by score.course_id 21、查询各科成绩前三名的记录:(不考虑成绩并列情况) select score.sid,score.course_id,score.num,T.first_num,T.second_num from score left join ( select sid, (select num from score as s2 where s2.course_id = s1.course_id order by num desc limit 0,1) as first_num, (select num from score as s2 where s2.course_id = s1.course_id order by num desc limit 3,1) as second_num from score as s1 ) as T on score.sid =T.sid where score.num = T.second_num 22、查询每门课程被选修的学生数； select course_id, count(1) from score group by course_id; 23、查询出只选修了一门课程的全部学生的学号和姓名； select student.sid, student.sname, count(1) from score left join student on score.student_id = student.sid group by course_id having count(1) = 1 24、查询男生、女生的人数； select * from (select count(1) as man from student where gender='男') as A , (select count(1) as feman from student where gender='女') as B 25、查询姓“张”的学生名单； select sname from student where sname like '张%'; 26、查询同名同姓学生名单，并统计同名人数； select sname,count(1) as count from student group by sname; 27、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列； select course_id,avg(if(isnull(num), 0 ,num)) as avg from score group by course_id order by avg asc,course_id desc; 28、查询平均成绩大于85的所有学生的学号、姓名和平均成绩； select student_id,sname, avg(if(isnull(num), 0 ,num)) from score left join student on score.student_id = student.sid group by student_id; 29、查询课程名称为“数学”，且分数低于60的学生姓名和分数； select student.sname,score.num from score left join course on score.course_id = course.cid left join student on score.student_id = student.sid where score.num 80 31、求选了课程的学生人数 select count(distinct student_id) from score select count(c) from ( select count(student_id) as c from score group by student_id) as A 32、查询选修“杨艳”老师所授课程的学生中，成绩最高的学生姓名及其成绩； select sname,num from score left join student on score.student_id = student.sid where score.course_id in (select course.cid from course left join teacher on course.teacher_id = teacher.tid where tname='张磊老师') order by num desc limit 1; 33、查询各个课程及相应的选修人数； select course.cname,count(1) from score left join course on score.course_id = course.cid group by course_id; 34、查询不同课程但成绩相同的学生的学号、课程号、学生成绩； select DISTINCT s1.course_id,s2.course_id,s1.num,s2.num from score as s1, score as s2 where s1.num = s2.num and s1.course_id != s2.course_id; 35、查询每门课程成绩最好的前两名； select score.sid,score.course_id,score.num,T.first_num,T.second_num from score left join ( select sid, (select num from score as s2 where s2.course_id = s1.course_id order by num desc limit 0,1) as first_num, (select num from score as s2 where s2.course_id = s1.course_id order by num desc limit 1,1) as second_num from score as s1 ) as T on score.sid =T.sid where score.num = T.second_num 36、检索至少选修两门课程的学生学号； select student_id from score group by student_id having count(student_id) > 1 37、查询全部学生都选修的课程的课程号和课程名； select course_id,count(1) from score group by course_id having count(1) = (select count(1) from student); 38、查询没学过“叶平”老师讲授的任一门课程的学生姓名； select student_id,student.sname from score left join student on score.student_id = student.sid where score.course_id not in ( select cid from course left join teacher on course.teacher_id = teacher.tid where tname = '张磊老师' ) group by student_id 39、查询两门以上不及格课程的同学的学号及其平均成绩； select student_id,count(1) from score where num 2 40、检索“004”课程分数小于60，按分数降序排列的同学学号； select student_id from score where num "},"MySQL学习/Python3连接MySQL.html":{"url":"MySQL学习/Python3连接MySQL.html","title":"Python3连接MySQL","keywords":"","body":"Python3连接MySQL 本文介绍Python3连接MySQL的第三方库--PyMySQL的基本使用。 PyMySQL介绍 PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。 Django中也可以使用PyMySQL连接MySQL数据库。 PyMySQL安装 pip install pymysql 连接数据库 注意事项 在进行本文以下内容之前需要注意： 你有一个MySQL数据库，并且已经启动。 你有可以连接该数据库的用户名和密码 你有一个有权限操作的database 基本使用 # 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=“你的数据库地址”, user=“用户名”,password=“密码”,database=“数据库名”,charset=“utf8”) # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() # 定义要执行的SQL语句 sql = \"\"\" CREATE TABLE USER1 ( id INT auto_increment PRIMARY KEY , name CHAR(10) NOT NULL UNIQUE, age TINYINT NOT NULL )ENGINE=innodb DEFAULT CHARSET=utf8; \"\"\" # 执行SQL语句 cursor.execute(sql) # 关闭光标对象 cursor.close() # 关闭数据库连接 conn.close() 注意： ==charset=“utf8”，编码不要写成\"utf-8\"== 增删改查操作 增 # 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=“你的数据库地址”, user=“用户名”,password=“密码”,database=“数据库名”,charset=“utf8”) # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() sql = \"INSERT INTO USER1(name, age) VALUES (%s, %s);\" username = \"Alex\" age = 18 # 执行SQL语句 cursor.execute(sql, [username, age]) # 提交事务 conn.commit() cursor.close() conn.close() 插入数据失败回滚 # 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=“你的数据库地址”, user=“用户名”,password=“密码”,database=“数据库名”,charset=“utf8”) # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() sql = \"INSERT INTO USER1(name, age) VALUES (%s, %s);\" username = \"Alex\" age = 18 try: # 执行SQL语句 cursor.execute(sql, [username, age]) # 提交事务 conn.commit() except Exception as e: # 有异常，回滚事务 conn.rollback() cursor.close() conn.close() 获取插入数据的ID(关联操作时会用到) # 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=“你的数据库地址”, user=“用户名”,password=“密码”,database=“数据库名”,charset=“utf8”) # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() sql = \"INSERT INTO USER1(name, age) VALUES (%s, %s);\" username = \"Alex\" age = 18 try: # 执行SQL语句 cursor.execute(sql, [username, age]) # 提交事务 conn.commit() # 提交之后，获取刚插入的数据的ID last_id = cursor.lastrowid except Exception as e: # 有异常，回滚事务 conn.rollback() cursor.close() conn.close() 批量执行 # 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=“你的数据库地址”, user=“用户名”,password=“密码”,database=“数据库名”,charset=“utf8”) # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() sql = \"INSERT INTO USER1(name, age) VALUES (%s, %s);\" data = [(\"Alex\", 18), (\"Egon\", 20), (\"Yuan\", 21)] try: # 批量执行多条插入SQL语句 cursor.executemany(sql, data) # 提交事务 conn.commit() except Exception as e: # 有异常，回滚事务 conn.rollback() cursor.close() conn.close() 删 # 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=“你的数据库地址”, user=“用户名”,password=“密码”,database=“数据库名”,charset=“utf8”) # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() sql = \"DELETE FROM USER1 WHERE id=%s;\" try: cursor.execute(sql, [4]) # 提交事务 conn.commit() except Exception as e: # 有异常，回滚事务 conn.rollback() cursor.close() conn.close() 改 # 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=“你的数据库地址”, user=“用户名”,password=“密码”,database=“数据库名”,charset=“utf8”) # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() # 修改数据的SQL语句 sql = \"UPDATE USER1 SET age=%s WHERE name=%s;\" username = \"Alex\" age = 80 try: # 执行SQL语句 cursor.execute(sql, [age, username]) # 提交事务 conn.commit() except Exception as e: # 有异常，回滚事务 conn.rollback() cursor.close() conn.close() 查 # 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=“你的数据库地址”, user=“用户名”,password=“密码”,database=“数据库名”,charset=“utf8”) # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() # 查询数据的SQL语句 sql = \"SELECT id,name,age from USER1 WHERE id=1;\" # 执行SQL语句 cursor.execute(sql) # 获取单条查询数据 ret = cursor.fetchone() cursor.close() conn.close() # 打印下查询结果 print(ret) 查询多条数据 # 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=“你的数据库地址”, user=“用户名”,password=“密码”,database=“数据库名”,charset=“utf8”) # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() # 查询数据的SQL语句 sql = \"SELECT id,name,age from USER1;\" # 执行SQL语句 cursor.execute(sql) # 获取多条查询数据 ret = cursor.fetchall() cursor.close() conn.close() # 打印下查询结果 print(ret) 进阶用法 # 可以获取指定数量的数据 cursor.fetchmany(3) # 光标按绝对位置移动1 cursor.scroll(1, mode=\"absolute\") # 光标按照相对位置(当前位置)移动1 cursor.scroll(1, mode=\"relative\") "},"python/":{"url":"python/","title":"python","keywords":"","body":"# articles ├──────python之web框架Django ├──────01.Django初识.md ├──────02.Web框架本质及第一个Django实例.md ├──────03.HTTP协议.md ├──────04.Django框架简介.md ├──────05.Django的视图.md ├──────06.Django的路由系统.md ├──────07.Django模板系统.md ├──────08.Django模型ORM.md ├──────111.ORM版学员管理系统.md(单表API汇总,单表查询之神奇的双下划线,Django的日志配置 ├───── Form组件.markdown "},"python/Django/01.Django初识.html":{"url":"python/Django/01.Django初识.html","title":"Django初识","keywords":"","body":"MTV模型 Django的MTV分别代表： Model(模型)：负责业务对象与数据库的对象(ORM) Template(模版)：负责如何把页面展示给用户 View(视图)：负责业务逻辑，并在适当的时候调用Model和Template 此外，Django还有一个urls分发器，它的作用是将一个个URL的页面请求 分发给不同的view处理，view再调用相应的Model和Template Django基本命令 1、下载Django： pip3 install django 2、创建一个django project django-admin.py startproject mysite 当前目录下会生成mysite的工程，目录结构如下： mysite ├── manage.py └── mysite ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py manage.py ----- Django项目里面的工具，通过它可以调用django shell和数据库等。 settings.py ---- 包含了项目的默认设置，包括数据库信息，调试标志 以及其他一些工作的变量。 urls.py ----- 负责把URL模式映射到应用程序。 3、在mysite目录下创建应用 python manage.py startapp blog 4、启动django项目 python manage.py runserver 8080 5、同步更改数据库表或字段 python manage.py syncdb 注意：Django 1.7.1 及以上的版本需要用以下命令 python manage.py makemigrations python manage.py migrate 这种方法可以创建表，当你在models.py中新增了类时，运行它就可以自动在数据库中创建表了，不用手动创建。 6、清空数据库 python manage.py flush 此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表。 7、创建超级管理员 python manage.py createsuperuser # 按照提示输入用户名和对应的密码就好了邮箱可以留空，用户名和密码必填 # 修改 用户密码可以用： python manage.py changepassword username 8、Django 项目环境终端 python manage.py shell 这个命令和 直接运行 python 进入 shell 的区别是：你可以在这个 shell 里面调用当前项目的 models.py 中的 API，对于操作数据的测试非常方便。 9、Django 项目环境终端 ython manage.py dbshell Django 会自动进入在settings.py中设置的数据库，如果是 MySQL 或 postgreSQL,会要求输入数据库用户密码。 在这个终端可以执行数据库的SQL语句。如果您对SQL比较熟悉，可能喜欢这种方式。 10、更多命令 python manage.py 查看所有的命令，忘记子名称的时候特别有用。 11 静态文件配置 概述： 静态文件交由Web服务器处理，Django本身不处理静态文件。 简单的处理逻辑如下(以nginx为例)： URI请求-----> 按照Web服务器里面的配置规则先处理，以nginx为例， 主要求配置在nginx. conf里的location |---------->如果是静态文件，则由nginx直接处理 |---------->如果不是则交由Django处理， Django根据urls.py里面的规则进行匹配 以上是部署到Web服务器后的处理方式，为了便于开发， Django提供了在开发环境的对静态文件的处理机制，方法是这样： static配置： STATIC主要指的是如css,js,images这样文件： STATIC_URL = '/static/' # 别名 STATICFILES_DIRS = ( os.path.join(BASE_DIR,\"static\"), #实际名 ,即实际文件夹的名字 ) ''' 注意点1: django对引用名和实际名进行映射,引用时,只能按照引用名来,不能按实际名去找 ------error－－－－－不能直接用，必须用STATIC_URL = '/static/': 注意点2: STATICFILES_DIRS = ( (\"app01\",os.path.join(BASE_DIR, \"app01/statics\")), ) 视图层之路由配置系统(views) URL配置(URLconf)就像Django 所支撑网站的目录。它的本质是URL与要为该URL调用的视图函数之间的映射表； 你就是以这种方式告诉Django，对于这个URL调用这段代码，对于那个URL调用 那段代码。 urlpatterns = [ url(正则表达式, views视图函数，参数，别名), ] 参数说明： 一个正则表达式字符串 一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串 可选的要传递给视图函数的默认参数（字典形式） 一个可选的name参数 1 URLconf的正则字符串参数 1.1 简单配置 from django.conf.urls import url from . import views urlpatterns = [ url(r'^articles/2003/$', views.special_case_2003), url(r'^articles/([0-9]{4})/$', views.year_archive), url(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive), url(r'^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$', views.article_detail), ] NOTE: 1 一旦匹配成功则不再继续 2 若要从URL 中捕获一个值，只需要在它周围放置一对圆括号。 3 不需要添加一个前导的反斜杠，因为每个URL 都有。例如，应该是^articles 而不是 ^/articles。 4 每个正则表达式前面的'r' 是可选的但是建议加上。 一些请求的例子： /articles/2005/3/ 不匹配任何URL 模式，因为列表中的第三个模式要求月份应该是两个数字。 /articles/2003/ 将匹配列表中的第一个模式不是第二个，因为模式按顺序匹配，第一个会首先测试是否匹配。 /articles/2005/03/ 请求将匹配列表中的第三个模式。Django 将调用函数 views.month_archive(request, '2005', '03')。 #设置项是否开启URL访问地址后面不为/跳转至带有/的路径 APPEND_SLASH=True 1.2 有名分组(named group) 上面的示例使用简单的、没有命名的正则表达式组（通过圆括号）来捕获URL 中的值并以位置 参数传递给视图。在更高级的用法中，可以使用命名的 正则表达式组来捕获URL 中的值并以关键字 参数传递给视图。 在Python 正则表达式中，命名正则表达式组的语法是(?Ppattern)， 其中name 是组的名称，pattern 是要匹配的模式。 下面是以上URLconf 使用命名组的重写： from django.conf.urls import url from . import views urlpatterns = [ url(r'^articles/2003/$', views.special_case_2003), url(r'^articles/(?P[0-9]{4})/$', views.year_archive), url(r'^articles/(?P[0-9]{4})/(?P[0-9]{2})/$', views.month_archive), url(r'^articles/(?P[0-9]{4})/(?P[0-9]{2})/(?P[0-9]{2})/$', views.article_detail), ] 这个实现与前面的示例完全相同，只有一个细微的差别：捕获的值作为关键字 参数而不是位置参数传递给视图函数。例如： /articles/2005/03/ 请求将调用views.month_archive(request, year='2005', month='03')函数 /articles/2003/03/03/ 请求将调用函数views.article_detail(request, year='2003', month='03', day='03')。 在实际应用中，这意味你的URLconf 会更加明晰且不容易产生参数顺序问题的 错误 —— 你可以在你的视图函数定义中重新安排参数的顺序。当然，这些好处 是以简洁为代价；有些开发人员认为命名组语法丑陋而繁琐。 1.3 URLconf 在什么上查找 URLconf 在请求的URL 上查找，将它当做一个普通的Python 字符串。不包括GET和POST参数以及域名。 例如，http://www.example.com/myapp/ 请求中，URLconf 将查找myapp/。 在http://www.example.com/myapp/?page=3 请求中，URLconf 仍将查找myapp/。 URLconf 不检查请求的方法。换句话讲，所有的请求方法 —— 同一个URL的POST、GET、HEAD等等 —— 都将路由到相同的函数。 1.4 捕获的参数永远是字符串 每个捕获的参数都作为一个普通的Python 字符串传递给视图，无论正则表达式使用的是什么匹配方式。例如， 下面这行URLconf 中： url(r'^articles/(?P[0-9]{4})/$', views.year_archive), views.year_archive() 的year 参数将是一个字符串 1.5 指定视图参数的默认值 有一个方便的小技巧是指定视图参数的默认值。 下面是一个URLconf 和视图的示例： # URLconf from django.conf.urls import url from . import views urlpatterns = [ url(r'^blog/$', views.page), url(r'^blog/page(?P[0-9]+)/$', views.page), ] # View (in blog/views.py) def page(request, num=\"1\"): 在上面的例子中，两个URL模式指向同一个视图views.page —— 但是第一个模式不会从URL 中捕获任何值。如果第一个模式匹配，page() 函数将使用num参数的默认值\"1\"。如果第二个模式匹配，page() 将使用正则表达式捕获的num 值。 1.6 Including other URLconfs #At any point, your urlpatterns can “include” other URLconf modules. This #essentially “roots” a set of URLs below other ones. #For example, here’s an excerpt of the URLconf for the Django website itself. #It includes a number of other URLconfs: from django.conf.urls import include, url urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^blog/', include('blog.urls')), ] 2 传递额外的选项给视图函数(了解) URLconfs 具有一个钩子，让你传递一个Python 字典作为额外的参数传递给视图函数。 django.conf.urls.url() 函数可以接收一个可选的第三个参数，它是一个字典，表示想要传递给视图函数的额外关键字参数。 例如： from django.conf.urls import url from . import views urlpatterns = [ url(r'^blog/(?P[0-9]{4})/$', views.year_archive, {'foo': 'bar'}), ] 在这个例子中，对于/blog/2005/请求，Django 将调用views.year_archive(request, year='2005', foo='bar')。 这个技术在Syndication 框架中使用，来传递元数据和选项给视图。 3 URL 的反向解析 在使用Django 项目时，一个常见的需求是获得URL 的最终形式，以用于嵌入到生成的内容中（视图中和显示给用户的URL等）或者用于处理服务器端的导航（重定向等）。 人们强烈希望不要硬编码这些URL（费力、不可扩展且容易产生错误）或者设计一种与URLconf 毫不相关的专门的URL 生成机制，因为这样容易导致一定程度上产生过期的URL。 换句话讲，需要的是一个DRY 机制。除了其它有点，它还允许设计的URL 可以自动更新而不用遍历项目的源代码来搜索并替换过期的URL。 获取一个URL 最开始想到的信息是处理它视图的标识（例如名字），查找正确的URL 的其它必要的信息有视图参数的类型（位置参数、关键字参数）和值。 Django 提供一个办法是让URL 映射是URL 设计唯一的地方。你填充你的URLconf，然后可以双向使用它： 根据用户/浏览器发起的URL 请求，它调用正确的Django 视图，并从URL 中提取它的参数需要的值。 根据Django 视图的标识和将要传递给它的参数的值，获取与之关联的URL。 第一种方式是我们在前面的章节中一直讨论的用法。第二种方式叫做反向解析URL、反向URL 匹配、反向URL 查询或者简单的URL 反查。 在需要URL 的地方，对于不同层级，Django 提供不同的工具用于URL 反查： 在模板中：使用url 模板标签。 在Python 代码中：使用django.core.urlresolvers.reverse() 函数。 在更高层的与处理Django 模型实例相关的代码中：使用get_absolute_url() 方法。 例子： 考虑下面的URLconf： from django.conf.urls import url from . import views urlpatterns = [ #... url(r'^articles/([0-9]{4})/$', views.year_archive, name='news-year-archive'), #... ] 根据这里的设计，某一年nnnn对应的归档的URL是/articles/nnnn/。 你可以在模板的代码中使用下面的方法获得它们： 2012 Archive {% for yearvar in year_list %} {{ yearvar }} Archive {% endfor %} 在Python 代码中，这样使用： from django.core.urlresolvers import reverse from django.http import HttpResponseRedirect def redirect_to_year(request): # ... year = 2006 # ... return HttpResponseRedirect(reverse('news-year-archive', args=(year,))) 如果出于某种原因决定按年归档文章发布的URL应该调整一下，那么你将只需要 修改URLconf 中的内容。 在某些场景中，一个视图是通用的，所以在URL 和视图之间存在多对一的关系。对于这些情况，当反查URL 时，只有视图的名字还不够。 4 名称空间（Namespace） 命名空间（英语：Namespace）是表示标识符的可见范围。一个标识符可在多 个命名空间中定义，它在不同命名空间中的含义是互不相干的。这样，在一 个新的命名空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突， 因为已有的定义都处于其它命名空间中。 由于name没有作用域，Django在反解URL时，会在项目全局顺序搜索，当查找 到第一个name指定URL时，立即返回 我们在开发项目时，会经常使用name属性反解出URL，当不小心在不同的app的 urls中定义相同的name时，可能会导致URL反解错误，为了避免这种事情发生， 引入了命名空间。 project.urls: urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^app01/', include(\"app01.urls\",namespace=\"app01\")), url(r'^app02/', include(\"app02.urls\",namespace=\"app02\")), ] app01.urls: urlpatterns = [ url(r'^index/', index,name=\"index\"), ] app02.urls: urlpatterns = [ url(r'^index/', index,name=\"index\"), ] app01.views from django.core.urlresolvers import reverse def index(request): return HttpResponse(reverse(\"app01:index\")) app02.views from django.core.urlresolvers import reverse def index(request): return HttpResponse(reverse(\"app02:index\")) "},"python/Django/02.Web框架本质及第一个Django实例.html":{"url":"python/Django/02.Web框架本质及第一个Django实例.html","title":"Web框架本质及第一个Django实例","keywords":"","body":"Web框架本质及第一个Django实例 Web框架本质 我们可以这样理解：所有的Web应用本质上就是一个socket服务端，而用户的浏览器就是一个socket客户端。 这样我们就可以自己实现Web框架了。 半成品自定义web框架 import socket sk = socket.socket() sk.bind((\"127.0.0.1\", 80)) sk.listen() while True: conn, addr = sk.accept() data = conn.recv(8096) conn.send(b\"OK\") conn.close() 可以说Web服务本质上都是在这十几行代码基础上扩展出来的。这段代码就是它们的祖宗。 用户的浏览器一输入网址，会给服务端发送数据，那浏览器会发送什么数据？怎么发？这个谁来定？ 你这个网站是这个规定，他那个网站按照他那个规定，这互联网还能玩么？ 所以，必须有一个统一的规则，让大家发送消息、接收消息的时候有个格式依据，不能随便写。 这个规则就是HTTP协议，以后浏览器发送请求信息也好，服务器回复响应信息也罢，都要按照这个规则来。 HTTP协议主要规定了客户端和服务器之间的通信格式，那HTTP协议是怎么规定消息格式的呢？ 让我们首先打印下我们在服务端接收到的消息是什么。 import socket sk = socket.socket() sk.bind((\"127.0.0.1\", 80)) sk.listen() while True: conn, addr = sk.accept() data = conn.recv(8096) print(data) # 将浏览器FA来的消息打印出来 conn.send(b\"OK\") conn.close() 输出: b'GET / HTTP/1.1\\r\\nHost: 127.0.0.1:8080\\r\\nConnection: keep-alive\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\nDNT: 1\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\nCookie: csrftoken=RKBXh1d3M97iz03Rpbojx1bR6mhHudhyX5PszUxxG3bOEwh1lxFpGOgWN93ZH3zv\\r\\n\\r\\n' 然后我们再看一下我们访问博客园官网时浏览器收到的响应信息是什么。 响应相关信息可以在浏览器调试窗口的network标签页中看到。 点击view source之后显示如下图： 我们发现收发的消息需要按照一定的格式来，这里就需要了解一下HTTP协议了。 HTTP协议介绍HTTP协议介绍 HTTP协议对收发消息的格式要求 每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。 HTTP响应的Header中有一个 Content-Type表明响应的内容格式。如 text/html表示HTML网页。 HTTP GET请求的格式： HTTP响应的格式： 处女版自定义web框架 经过上面的补充学习，我们知道了要想让我们自己写的web server端正经起来，必须要让我们的Web server在给客户端回复消息的时候按照HTTP协议的规则加上响应状态行，这样我们就实现了一个正经的Web框架了。 import socket sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.bind(('127.0.0.1', 8000)) sock.listen() while True: conn, addr = sock.accept() data = conn.recv(8096) # 给回复的消息加上响应状态行 conn.send(b\"HTTP/1.1 200 OK\\r\\n\\r\\n\") conn.send(b\"OK\") conn.close() 我们通过十几行代码简单地演示了web 框架的本质。 接下来就让我们继续完善我们的自定义web框架吧！ 根据不同的路径返回不同的内容 这样就结束了吗？ 如何让我们的Web服务根据用户请求的URL不同而返回不同的内容呢？ 小事一桩，我们可以从请求相关数据里面拿到请求URL的路径，然后拿路径做一个判断... \"\"\" 根据URL中不同的路径返回不同的内容 \"\"\" import socket sk = socket.socket() sk.bind((\"127.0.0.1\", 8080)) # 绑定IP和端口 sk.listen() # 监听 while 1: # 等待连接 conn, add = sk.accept() data = conn.recv(8096) # 接收客户端发来的消息 # 从data中取到路径 data = str(data, encoding=\"utf8\") # 把收到的字节类型的数据转换成字符串 # 按\\r\\n分割 data1 = data.split(\"\\r\\n\")[0] url = data1.split()[1] # url是我们从浏览器发过来的消息中分离出的访问路径 conn.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n') # 因为要遵循HTTP协议，所以回复的消息也要加状态行 # 根据不同的路径返回不同内容 if url == \"/index/\": response = b\"index\" elif url == \"/home/\": response = b\"home\" else: response = b\"404 not found!\" conn.send(response) conn.close() 根据不同的路径返回不同的内容--函数版 上面的代码解决了不同URL路径返回不同内容的需求。 但是问题又来了，如果有很多很多路径要判断怎么办？难道要挨个写if判断？ 当然不用，我们有更聪明的办法。 \"\"\" 根据URL中不同的路径返回不同的内容--函数版 \"\"\" import socket sk = socket.socket() sk.bind((\"127.0.0.1\", 8080)) # 绑定IP和端口 sk.listen() # 监听 # 将返回不同的内容部分封装成函数 def index(url): s = \"这是{}页面！\".format(url) return bytes(s, encoding=\"utf8\") def home(url): s = \"这是{}页面！\".format(url) return bytes(s, encoding=\"utf8\") while 1: # 等待连接 conn, add = sk.accept() data = conn.recv(8096) # 接收客户端发来的消息 # 从data中取到路径 data = str(data, encoding=\"utf8\") # 把收到的字节类型的数据转换成字符串 # 按\\r\\n分割 data1 = data.split(\"\\r\\n\")[0] url = data1.split()[1] # url是我们从浏览器发过来的消息中分离出的访问路径 conn.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n') # 因为要遵循HTTP协议，所以回复的消息也要加状态行 # 根据不同的路径返回不同内容，response是具体的响应体 if url == \"/index/\": response = index(url) elif url == \"/home/\": response = home(url) else: response = b\"404 not found!\" conn.send(response) conn.close() 根据不同的路径返回不同的内容--函数进阶版 看起来上面的代码还是要挨个写if判断，怎么办？我们还是有办法！（只要思想不滑坡，方法总比问题多！） \"\"\" 根据URL中不同的路径返回不同的内容--函数进阶版 \"\"\" import socket sk = socket.socket() sk.bind((\"127.0.0.1\", 8080)) # 绑定IP和端口 sk.listen() # 监听 # 将返回不同的内容部分封装成函数 def index(url): s = \"这是{}页面！\".format(url) return bytes(s, encoding=\"utf8\") def home(url): s = \"这是{}页面！\".format(url) return bytes(s, encoding=\"utf8\") # 定义一个url和实际要执行的函数的对应关系 list1 = [ (\"/index/\", index), (\"/home/\", home), ] while 1: # 等待连接 conn, add = sk.accept() data = conn.recv(8096) # 接收客户端发来的消息 # 从data中取到路径 data = str(data, encoding=\"utf8\") # 把收到的字节类型的数据转换成字符串 # 按\\r\\n分割 data1 = data.split(\"\\r\\n\")[0] url = data1.split()[1] # url是我们从浏览器发过来的消息中分离出的访问路径 conn.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n') # 因为要遵循HTTP协议，所以回复的消息也要加状态行 # 根据不同的路径返回不同内容 func = None # 定义一个保存将要执行的函数名的变量 for i in list1: if i[0] == url: func = i[1] break if func: response = func(url) else: response = b\"404 not found!\" # 返回具体的响应消息 conn.send(response) conn.close() 返回具体的HTML文件 完美解决了不同URL返回不同内容的问题。 但是我不想仅仅返回几个字符串，我想给浏览器返回完整的HTML内容，这又该怎么办呢？ 没问题，不管是什么内容，最后都是转换成字节数据发送出去的。 我们可以打开HTML文件，读取出它内部的二进制数据，然后再发送给浏览器。 \"\"\" 根据URL中不同的路径返回不同的内容--函数进阶版 返回独立的HTML页面 \"\"\" import socket sk = socket.socket() sk.bind((\"127.0.0.1\", 8080)) # 绑定IP和端口 sk.listen() # 监听 # 将返回不同的内容部分封装成函数 def index(url): # 读取index.html页面的内容 with open(\"index.html\", \"r\", encoding=\"utf8\") as f: s = f.read() # 返回字节数据 return bytes(s, encoding=\"utf8\") def home(url): with open(\"home.html\", \"r\", encoding=\"utf8\") as f: s = f.read() return bytes(s, encoding=\"utf8\") # 定义一个url和实际要执行的函数的对应关系 list1 = [ (\"/index/\", index), (\"/home/\", home), ] while 1: # 等待连接 conn, add = sk.accept() data = conn.recv(8096) # 接收客户端发来的消息 # 从data中取到路径 data = str(data, encoding=\"utf8\") # 把收到的字节类型的数据转换成字符串 # 按\\r\\n分割 data1 = data.split(\"\\r\\n\")[0] url = data1.split()[1] # url是我们从浏览器发过来的消息中分离出的访问路径 conn.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n') # 因为要遵循HTTP协议，所以回复的消息也要加状态行 # 根据不同的路径返回不同内容 func = None # 定义一个保存将要执行的函数名的变量 for i in list1: if i[0] == url: func = i[1] break if func: response = func(url) else: response = b\"404 not found!\" # 返回具体的响应消息 conn.send(response) conn.close() 让网页动态起来 这网页能够显示出来了，但是都是静态的啊。页面的内容都不会变化的，我想要的是动态网站。 没问题，我也有办法解决。我选择使用字符串替换来实现这个需求。（这里使用时间戳来模拟动态的数据） \"\"\" 根据URL中不同的路径返回不同的内容--函数进阶版 返回HTML页面 让网页动态起来 \"\"\" import socket import time sk = socket.socket() sk.bind((\"127.0.0.1\", 8080)) # 绑定IP和端口 sk.listen() # 监听 # 将返回不同的内容部分封装成函数 def index(url): with open(\"index.html\", \"r\", encoding=\"utf8\") as f: s = f.read() now = str(time.time()) s = s.replace(\"@@oo@@\", now) # 在网页中定义好特殊符号，用动态的数据去替换提前定义好的特殊符号 return bytes(s, encoding=\"utf8\") def home(url): with open(\"home.html\", \"r\", encoding=\"utf8\") as f: s = f.read() return bytes(s, encoding=\"utf8\") # 定义一个url和实际要执行的函数的对应关系 list1 = [ (\"/index/\", index), (\"/home/\", home), ] while 1: # 等待连接 conn, add = sk.accept() data = conn.recv(8096) # 接收客户端发来的消息 # 从data中取到路径 data = str(data, encoding=\"utf8\") # 把收到的字节类型的数据转换成字符串 # 按\\r\\n分割 data1 = data.split(\"\\r\\n\")[0] url = data1.split()[1] # url是我们从浏览器发过来的消息中分离出的访问路径 conn.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n') # 因为要遵循HTTP协议，所以回复的消息也要加状态行 # 根据不同的路径返回不同内容 func = None # 定义一个保存将要执行的函数名的变量 for i in list1: if i[0] == url: func = i[1] break if func: response = func(url) else: response = b\"404 not found!\" # 返回具体的响应消息 conn.send(response) conn.close() 服务器程序和应用程序 对于真实开发中的python web程序来说，一般会分为两部分：服务器程序和应用程序。 服务器程序负责对socket服务器进行封装，并在请求到来时，对请求的各种数据进行整理。 应用程序则负责具体的逻辑处理。为了方便应用程序的开发，就出现了众多的Web框架，例如：Django、Flask、web.py 等。不同的框架有不同的开发方式，但是无论如何，开发出的应用程序都要和服务器程序配合，才能为用户提供服务。 这样，服务器程序就需要为不同的框架提供不同的支持。这样混乱的局面无论对于服务器还是框架，都是不好的。对服务器来说，需要支持各种不同框架，对框架来说，只有支持它的服务器才能被开发出的应用使用。 这时候，标准化就变得尤为重要。我们可以设立一个标准，只要服务器程序支持这个标准，框架也支持这个标准，那么他们就可以配合使用。一旦标准确定，双方各自实现。这样，服务器可以支持更多支持标准的框架，框架也可以使用更多支持标准的服务器。 WSGI（Web Server Gateway Interface）就是一种规范，它定义了使用Python编写的web应用程序与web服务器程序之间的接口格式，实现web应用程序与web服务器程序间的解耦。 常用的WSGI服务器有uwsgi、Gunicorn。而Python标准库提供的独立WSGI服务器叫wsgiref，Django开发环境用的就是这个模块来做服务器。 wsgiref 我们利用wsgiref模块来替换我们自己写的web框架的socket server部分： \"\"\" 根据URL中不同的路径返回不同的内容--函数进阶版 返回HTML页面 让网页动态起来 wsgiref模块版 \"\"\" import time from wsgiref.simple_server import make_server # 将返回不同的内容部分封装成函数 def index(url): with open(\"index.html\", \"r\", encoding=\"utf8\") as f: s = f.read() now = str(time.time()) s = s.replace(\"@@oo@@\", now) return bytes(s, encoding=\"utf8\") def home(url): with open(\"home.html\", \"r\", encoding=\"utf8\") as f: s = f.read() return bytes(s, encoding=\"utf8\") # 定义一个url和实际要执行的函数的对应关系 list1 = [ (\"/index/\", index), (\"/home/\", home), ] def run_server(environ, start_response): start_response('200 OK', [('Content-Type', 'text/html;charset=utf8'), ]) # 设置HTTP响应的状态码和头信息 url = environ['PATH_INFO'] # 取到用户输入的url func = None for i in list1: if i[0] == url: func = i[1] break if func: response = func(url) else: response = b\"404 not found!\" return [response, ] if __name__ == '__main__': httpd = make_server('127.0.0.1', 8090, run_server) print(\"我在8090等你哦...\") httpd.serve_forever() jinja2 上面的代码实现了一个简单的动态，我完全可以从数据库中查询数据，然后去替换我html中的对应内容，然后再发送给浏览器完成渲染。 这个过程就相当于HTML模板渲染数据。 本质上就是HTML内容中利用一些特殊的符号来替换要展示的数据。 我这里用的特殊符号是我定义的，其实模板渲染有个现成的工具： jinja2 下载jinja2: pip3 install jinja2 版本可以加其它的 Title 姓名：{{name}} 爱好： {% for hobby in hobby_list %} {{hobby}} {% endfor %} 使用jinja2渲染index2.html文件： from wsgiref.simple_server import make_server from jinja2 import Template def index(): with open(\"index2.html\", \"r\") as f: data = f.read() template = Template(data) # 生成模板文件 ret = template.render({\"name\": \"Alex\", \"hobby_list\": [\"烫头\", \"泡吧\"]}) # 把数据填充到模板里面 return [bytes(ret, encoding=\"utf8\"), ] def home(): with open(\"home.html\", \"rb\") as f: data = f.read() return [data, ] # 定义一个url和函数的对应关系 URL_LIST = [ (\"/index/\", index), (\"/home/\", home), ] def run_server(environ, start_response): start_response('200 OK', [('Content-Type', 'text/html;charset=utf8'), ]) # 设置HTTP响应的状态码和头信息 url = environ['PATH_INFO'] # 取到用户输入的url func = None # 将要执行的函数 for i in URL_LIST: if i[0] == url: func = i[1] # 去之前定义好的url列表里找url应该执行的函数 break if func: # 如果能找到要执行的函数 return func() # 返回函数的执行结果 else: return [bytes(\"404没有该页面\", encoding=\"utf8\"), ] if __name__ == '__main__': httpd = make_server('', 8000, run_server) print(\"Serving HTTP on port 8000...\") httpd.serve_forever() 现在的数据是我们自己手写的，那可不可以从数据库中查询数据，来填充页面呢？ 使用pymysql连接数据库： conn = pymysql.connect(host=\"127.0.0.1\", port=3306, user=\"root\", passwd=\"xxx\", db=\"xxx\", charset=\"utf8\") cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) cursor.execute(\"select name, age, department_id from userinfo\") user_list = cursor.fetchall() cursor.close() conn.close() 创建一个测试的user表： CREATE TABLE user( id int auto_increment PRIMARY KEY, name CHAR(10) NOT NULL, hobby CHAR(20) NOT NULL )engine=innodb DEFAULT charset=UTF8; 模板的原理就是字符串替换，我们只要在HTML页面中遵循jinja2的语法规则写上，其内部就会按照指定的语法进行相应的替换，从而达到动态的返回内容。 Django 安装（安装最新LTS版）： pip3 install django==1.11.9 创建一个django项目： 下面的命令创建了一个名为\"mysite\"的Django 项目： django-admin startproject mysite 目录介绍： mysite/ ├── manage.py # 管理文件 └── mysite # 项目目录 ├── __init__.py ├── settings.py # 配置 ├── urls.py # 路由 --> URL和函数的对应关系 └── wsgi.py # runserver命令就使用wsgiref模块做简单的web server 运行Django项目： python manage.py runserver 127.0.0.1:8000 模板文件配置： TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, \"template\")], # template文件夹位置 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 静态文件配置： STATIC_URL = '/static/' # HTML中使用的静态文件夹前缀 STATICFILES_DIRS = [ os.path.join(BASE_DIR, \"static\"), # 静态文件存放位置 ] 看不明白？有图有真相： 刚开始学习时可在配置文件中暂时禁用csrf中间件，方便表单提交测试。 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] Django基础必备三件套： from django.shortcuts import HttpResponse, render, redirect HttpResponse 内部传入一个字符串参数，返回给浏览器。 例如： def index(request): # 业务逻辑代码 return HttpResponse(\"OK\") render 除request参数外还接受一个待渲染的模板文件和一个保存具体数据的字典参数。 将数据填充进模板文件，最后把结果返回给浏览器。（类似于我们上面用到的jinja2） 例如： def index(request): # 业务逻辑代码 return render(request, \"index.html\", {\"name\": \"alex\", \"hobby\": [\"烫头\", \"泡吧\"]}) redirect 接受一个URL参数，表示跳转到指定的URL。 例如： def index(request): # 业务逻辑代码 return redirect(\"/home/\") 重定向是怎么回事？ 启动Django报错： Django 启动时报错 UnicodeEncodeError ... 报这个错误通常是因为计算机名为中文，改成英文的计算机名重启下电脑就可以了。 "},"python/Django/03.HTTP协议.html":{"url":"python/Django/03.HTTP协议.html","title":"HTTP协议","keywords":"","body":"HTTP协议 HTTP协议简介 超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。 HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。 2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。 HTTP协议概述 HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。 尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如\"HTTP/1.1 200 OK\"，以及返回的内容，如请求的文件、错误消息、或者其它信息。 HTTP工作原理 HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 以下是 HTTP 请求/响应的步骤： 客户端连接到Web服务器 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.luffycity.com。 发送HTTP请求 通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 服务器接受请求并返回HTTP响应 Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 释放连接TCP连接 若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 客户端浏览器解析HTML内容 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 1.浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 2.解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 3.浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 4.服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 5.释放 TCP连接; 6.浏览器将该 html 文本并显示内容; HTTP请求方法 HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源： GET 向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。 HEAD 与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。 POST 向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。 PUT 向指定资源位置上传其最新内容。 DELETE 请求服务器删除Request-URI所标识的资源。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 OPTIONS 这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用'*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。 注意事项： 1.方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。 2.HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如PATCH（由 RFC 5789 指定的方法）用于将局部修改应用到资源。 HTTP状态码 所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。 状态代码的第一个数字代表当前响应的类型： 1xx消息——请求已被服务器接收，继续处理 2xx成功——请求已成功被服务器接收、理解、并接受 3xx重定向——需要后续操作才能完成这一请求 4xx请求错误——请求含有词法错误或者无法被执行 5xx服务器错误——服务器在处理某个正确请求时发生错误 虽然 RFC 2616 中已经推荐了描述状态的短语，例如\"200 OK\"，\"404 Not Found\"，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。 URL 超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中： 传送协议。 层级URL标记符号(为[//],固定不变) 访问资源需要的凭证信息（可省略） 服务器。（通常为域名，有时为IP地址） 端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略） 路径。（以“/”字符区别路径中的每一个目录名称） 查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题） 片段。以“#”字符为起点 以http://www.luffycity.com:80/news/index.html?id=250&page=1 为例, 其中： http，是协议； www.luffycity.com，是服务器； 80，是服务器上的网络端口号； /news/index.html，是路径； ?id=250&page=1，是查询。 大多数网页浏览器不要求用户输入网页中“http://”的部分，因为绝大多数网页内容是超文本传输协议文件。同样，“80”是超文本传输协议文件的常用端口号，因此一般也不必写明。一般来说用户只要键入统一资源定位符的一部分（www.luffycity.com:80/news/index.html?id=250&page=1）就可以了。 由于超文本传输协议允许服务器将浏览器重定向到另一个网页地址，因此许多服务器允许用户省略网页地址中的部分，比如 www。从技术上来说这样省略后的网页地址实际上是一个不同的网页地址，浏览器本身无法决定这个新地址是否通，服务器必须完成重定向的任务。 HTTP请求格式 HTTP响应格式 "},"python/Django/04.Django框架简介.html":{"url":"python/Django/04.Django框架简介.html","title":"Django框架简介","keywords":"","body":"Django框架简介 MVC框架和MTV框架（了解即可） MVC，全名是Model View Controller，是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型(Model)、视图(View)和控制器(Controller)，具有耦合性低、重用性高、生命周期成本低等优点。 想要更详细的了解MVC模式? >> 点我 Django框架的设计模式借鉴了MVC框架的思想，也是分成三部分，来降低各个部分之间的耦合性。 Django框架的不同之处在于它拆分的三部分为：Model（模型）、Template（模板）和View（视图），也就是MTV框架。 Django的MTV模式 Model(模型)：负责业务对象与数据库的对象(ORM) Template(模版)：负责如何把页面展示给用户 View(视图)：负责业务逻辑，并在适当的时候调用Model和Template 此外，Django还有一个urls分发器，它的作用是将一个个URL的页面请求分发给不同的view处理，view再调用相应的Model和Template Django框架图示 APP 一个Django项目可以分为很多个APP，用来隔离不同功能模块的代码。 命令行创建 python manage.py startapp app01 使用PyCharm创建 在下方弹出的命令窗口输入： startapp app01 路由系统 Django路由系统 >> 点我 视图系统 Django视图系统 >> 点我 模板 模板（Template）系统 >> 点我 模型 模型（model）系统 >> 点我 "},"python/Django/05.Django的视图.html":{"url":"python/Django/05.Django的视图.html","title":"Django的视图","keywords":"","body":"Django的View（视图） 一个视图函数（类），简称视图，是一个简单的Python 函数（类），它接受Web请求并且返回Web响应。 响应可以是一张网页的HTML内容，一个重定向，一个404错误，一个XML文档，或者一张图片。 无论视图本身包含什么逻辑，都要返回响应。代码写在哪里也无所谓，只要它在你当前项目目录下面。除此之外没有更多的要求了——可以说“没有什么神奇的地方”。为了将代码放在某处，大家约定成俗将视图放置在项目（project）或应用程序（app）目录中的名为views.py的文件中。 一个简单的视图 下面是一个以HTML文档的形式返回当前日期和时间的视图： from django.http import HttpResponse import datetime def current_datetime(request): now = datetime.datetime.now() html = \"It is now %s.\" % now return HttpResponse(html) 让我们来逐行解释下上面的代码： 首先，我们从 django.http模块导入了HttpResponse类，以及Python的datetime库。 接着，我们定义了current_datetime函数。它就是视图函数。每个视图函数都使用HttpRequest对象作为第一个参数，并且通常称之为request。 注意，视图函数的名称并不重要；不需要用一个统一的命名方式来命名，以便让Django识别它。我们将其命名为current_datetime，是因为这个名称能够比较准确地反映出它实现的功能。 这个视图会返回一个HttpResponse对象，其中包含生成的响应。每个视图函数都负责返回一个HttpResponse对象。 Django使用请求和响应对象来通过系统传递状态。 当浏览器向服务端请求一个页面时，Django创建一个HttpRequest对象，该对象包含关于请求的元数据。然后，Django加载相应的视图，将这个HttpRequest对象作为第一个参数传递给视图函数。 每个视图负责返回一个HttpResponse对象。 CBV和FBV 我们之前写过的都是基于函数的view，就叫FBV。还可以把view写成基于类的。 就拿我们之前写过的添加班级为例： FBV版： FBV版添加班级 def add_class(request): if request.method == \"POST\": class_name = request.POST.get(\"class_name\") models.Classes.objects.create(name=class_name) return redirect(\"/class_list/\") return render(request, \"add_class.html\") CBV版： CBV版添加班级 from django.views import View class AddClass(View): def get(self, request): return render(request, \"add_class.html\") def post(self, request): class_name = request.POST.get(\"class_name\") models.Classes.objects.create(name=class_name) return redirect(\"/class_list/\") 注意： 使用CBV时，urls.py中也做对应的修改： # urls.py中 url(r'^add_class/$', views.AddClass.as_view()), 给视图加装饰器 使用装饰器装饰FBV FBV本身就是一个函数，所以和给普通的函数加装饰器无差： def wrapper(func): def inner(*args, **kwargs): start_time = time.time() ret = func(*args, **kwargs) end_time = time.time() print(\"used:\", end_time-start_time) return ret return inner # FBV版添加班级 @wrapper def add_class(request): if request.method == \"POST\": class_name = request.POST.get(\"class_name\") models.Classes.objects.create(name=class_name) return redirect(\"/class_list/\") return render(request, \"add_class.html\") 使用装饰器装饰CBV 类中的方法与独立函数不完全相同，因此不能直接将函数装饰器应用于类中的方法 ，我们需要先将其转换为方法装饰器。 Django中提供了method_decorator装饰器用于将函数装饰器转换为方法装饰器。 # CBV版添加班级 from django.views import View from django.utils.decorators import method_decorator class AddClass(View): @method_decorator(wrapper) def get(self, request): return render(request, \"add_class.html\") def post(self, request): class_name = request.POST.get(\"class_name\") models.Classes.objects.create(name=class_name) return redirect(\"/class_list/\") # 使用CBV时要注意，请求过来后会先执行dispatch()这个方法，如果需要批量对具体的请求处理方法，如get，post等做一些操作的时候，这里我们可以手动改写dispatch方法，这个dispatch方法就和在FBV上加装饰器的效果一样。 class Login(View): def dispatch(self, request, *args, **kwargs): print('before') obj = super(Login,self).dispatch(request, *args, **kwargs) print('after') return obj def get(self,request): return render(request,'login.html') def post(self,request): print(request.POST.get('user')) return HttpResponse('Login.post') Request对象 官方文档 请求相关的常用值 path_info 返回用户访问url，不包括域名 method 请求中使用的HTTP方法的字符串表示，全大写表示。 GET 包含所有HTTP GET参数的类字典对象 POST 包含所有HTTP POST参数的类字典对象 body 请求体，byte类型 request.POST的数据就是从body里面提取到的 属性 所有的属性应该被认为是只读的，除非另有说明。 复制代码 属性： 　　django将请求报文中的请求行、头部信息、内容主体封装成 HttpRequest 类中的属性。 除了特殊说明的之外，其他均为只读的。 0.HttpRequest.scheme 表示请求方案的字符串（通常为http或https） 1.HttpRequest.body 　　一个字符串，代表请求报文的主体。在处理非 HTTP 形式的报文时非常有用，例如：二进制图片、XML,Json等。 　　但是，如果要处理表单数据的时候，推荐还是使用 HttpRequest.POST 。 　　另外，我们还可以用 python 的类文件方法去操作它，详情参考 HttpRequest.read() 。 2.HttpRequest.path 　　一个字符串，表示请求的路径组件（不含域名）。 　　例如：\"/music/bands/the_beatles/\" 3.HttpRequest.method 　　一个字符串，表示请求使用的HTTP 方法。必须使用大写。 　　例如：\"GET\"、\"POST\" 4.HttpRequest.encoding 　　一个字符串，表示提交的数据的编码方式（如果为 None 则表示使用 DEFAULT_CHARSET 的设置，默认为 'utf-8'）。 这个属性是可写的，你可以修改它来修改访问表单数据使用的编码。 接下来对属性的任何访问（例如从 GET 或 POST 中读取数据）将使用新的 encoding 值。 如果你知道表单数据的编码不是 DEFAULT_CHARSET ，则使用它。 5.HttpRequest.GET 　　一个类似于字典的对象，包含 HTTP GET 的所有参数。详情请参考 QueryDict 对象。 6.HttpRequest.POST 　　一个类似于字典的对象，如果请求中包含表单数据，则将这些数据封装成 QueryDict 对象。 　　POST 请求可以带有空的 POST 字典 —— 如果通过 HTTP POST 方法发送一个表单，但是表单中没有任何的数据，QueryDict 对象依然会被创建。 因此，不应该使用 if request.POST 来检查使用的是否是POST 方法；应该使用 if request.method == \"POST\" 　　另外：如果使用 POST 上传文件的话，文件信息将包含在 FILES 属性中。 7.HttpRequest.COOKIES 　　一个标准的Python 字典，包含所有的cookie。键和值都为字符串。 8.HttpRequest.FILES 　　一个类似于字典的对象，包含所有的上传文件信息。 FILES 中的每个键为 中的name，值则为对应的数据。 　　注意，FILES 只有在请求的方法为POST 且提交的 带有enctype=\"multipart/form-data\" 的情况下才会 包含数据。否则，FILES 将为一个空的类似于字典的对象。 9.HttpRequest.META 　　一个标准的Python 字典，包含所有的HTTP 首部。具体的头部信息取决于客户端和服务器，下面是一些示例： CONTENT_LENGTH —— 请求的正文的长度（是一个字符串）。 CONTENT_TYPE —— 请求的正文的MIME 类型。 HTTP_ACCEPT —— 响应可接收的Content-Type。 HTTP_ACCEPT_ENCODING —— 响应可接收的编码。 HTTP_ACCEPT_LANGUAGE —— 响应可接收的语言。 HTTP_HOST —— 客服端发送的HTTP Host 头部。 HTTP_REFERER —— Referring 页面。 HTTP_USER_AGENT —— 客户端的user-agent 字符串。 QUERY_STRING —— 单个字符串形式的查询字符串（未解析过的形式）。 REMOTE_ADDR —— 客户端的IP 地址。 REMOTE_HOST —— 客户端的主机名。 REMOTE_USER —— 服务器认证后的用户。 REQUEST_METHOD —— 一个字符串，例如\"GET\" 或\"POST\"。 SERVER_NAME —— 服务器的主机名。 SERVER_PORT —— 服务器的端口（是一个字符串）。 　　从上面可以看到，除 CONTENTLENGTH 和 CONTENT_TYPE 之外，请求中的任何 HTTP 首部转换为 META 的键时， 都会将所有字母大写并将连接符替换为下划线最后加上 HTTP 前缀。 所以，一个叫做 X-Bender 的头部将转换成 META 中的 HTTP_X_BENDER 键。 10.HttpRequest.user 　　一个 AUTH_USER_MODEL 类型的对象，表示当前登录的用户。 　　如果用户当前没有登录，user 将设置为 django.contrib.auth.models.AnonymousUser 的一个实例。你可以通过 is_authenticated() 区分它们。 例如： if request.user.is_authenticated(): # Do something for logged-in users. else: # Do something for anonymous users. 　　user 只有当Django 启用 AuthenticationMiddleware 中间件时才可用。 ------------------------------------------------------------------------------------- 匿名用户 class models.AnonymousUser django.contrib.auth.models.AnonymousUser 类实现了django.contrib.auth.models.User 接口，但具有下面几个不同点： id 永远为None。 username 永远为空字符串。 get_username() 永远返回空字符串。 is_staff 和 is_superuser 永远为False。 is_active 永远为 False。 groups 和 user_permissions 永远为空。 is_anonymous() 返回True 而不是False。 is_authenticated() 返回False 而不是True。 set_password()、check_password()、save() 和delete() 引发 NotImplementedError。 New in Django 1.8: 新增 AnonymousUser.get_username() 以更好地模拟 django.contrib.auth.models.User。 11.HttpRequest.session 　　一个既可读又可写的类似于字典的对象，表示当前的会话。只有当Django 启用会话的支持时才可用。 完整的细节参见会话的文档。 复制代码 上传文件示例 复制代码 def upload(request): \"\"\" 保存上传文件前，数据需要存放在某个位置。默认当上传文件小于2.5M时，django会将上传文件的全部内容读进内存。从内存读取一次，写磁盘一次。 但当上传文件很大时，django会把上传文件写到临时文件中，然后存放到系统临时文件夹中。 :param request: :return: \"\"\" if request.method == \"POST\": # 从请求的FILES中获取上传文件的文件名，file为页面上type=files类型input的name属性值 filename = request.FILES[\"file\"].name # 在项目目录下新建一个文件 with open(filename, \"wb\") as f: # 从上传的文件对象中一点一点读 for chunk in request.FILES[\"file\"].chunks(): # 写入本地文件 f.write(chunk) return HttpResponse(\"上传OK\") 复制代码 方法 复制代码 1.HttpRequest.get_host() 　　根据从HTTP_X_FORWARDED_HOST（如果打开 USE_X_FORWARDED_HOST，默认为False）和 HTTP_HOST 头部信息返回请求的原始主机。 如果这两个头部没有提供相应的值，则使用SERVER_NAME 和SERVER_PORT，在PEP 3333 中有详细描述。 　　USE_X_FORWARDED_HOST：一个布尔值，用于指定是否优先使用 X-Forwarded-Host 首部，仅在代理设置了该首部的情况下，才可以被使用。 　　例如：\"127.0.0.1:8000\" 　　注意：当主机位于多个代理后面时，get_host() 方法将会失败。除非使用中间件重写代理的首部。 2.HttpRequest.get_full_path() 　　返回 path，如果可以将加上查询字符串。 　　例如：\"/music/bands/the_beatles/?print=true\" 3.HttpRequest.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None) 　　返回签名过的Cookie 对应的值，如果签名不再合法则返回django.core.signing.BadSignature。 　　如果提供 default 参数，将不会引发异常并返回 default 的值。 　　可选参数salt 可以用来对安全密钥强力攻击提供额外的保护。max_age 参数用于检查Cookie 对应的时间戳以确保Cookie 的时间不会超过max_age 秒。 复制代码 >>> request.get_signed_cookie('name') 'Tony' >>> request.get_signed_cookie('name', salt='name-salt') 'Tony' # 假设在设置cookie的时候使用的是相同的salt >>> request.get_signed_cookie('non-existing-cookie') ... KeyError: 'non-existing-cookie' # 没有相应的键时触发异常 >>> request.get_signed_cookie('non-existing-cookie', False) False >>> request.get_signed_cookie('cookie-that-was-tampered-with') ... BadSignature: ... >>> request.get_signed_cookie('name', max_age=60) ... SignatureExpired: Signature age 1677.3839159 > 60 seconds >>> request.get_signed_cookie('name', False, max_age=60) False 复制代码 4.HttpRequest.is_secure() 　　如果请求时是安全的，则返回True；即请求通是过 HTTPS 发起的。 5.HttpRequest.is_ajax() 　　如果请求是通过XMLHttpRequest 发起的，则返回True，方法是检查 HTTP_X_REQUESTED_WITH 相应的首部是否是字符串'XMLHttpRequest'。 　　大部分现代的 JavaScript 库都会发送这个头部。如果你编写自己的 XMLHttpRequest 调用（在浏览器端），你必须手工设置这个值来让 is_ajax() 可以工作。 　　如果一个响应需要根据请求是否是通过AJAX 发起的，并且你正在使用某种形式的缓存例如Django 的 cache middleware， 你应该使用 vary_on_headers('HTTP_X_REQUESTED_WITH') 装饰你的视图以让响应能够正确地缓存。 复制代码 注意：键值对的值是多个的时候,比如checkbox类型的input标签，select标签，需要用： request.POST.getlist(\"hobby\") Response对象 与由Django自动创建的HttpRequest对象相比，HttpResponse对象是我们的职责范围了。我们写的每个视图都需要实例化，填充和返回一个HttpResponse。 HttpResponse类位于django.http模块中。 使用 传递字符串 from django.http import HttpResponse response = HttpResponse(\"Here's the text of the Web page.\") response = HttpResponse(\"Text only, please.\", content_type=\"text/plain\") 设置或删除响应头信息 response = HttpResponse() response['Content-Type'] = 'text/html; charset=UTF-8' del response['Content-Type'] 属性 HttpResponse.content：响应内容 HttpResponse.charset：响应内容的编码 HttpResponse.status_code：响应的状态码 JsonResponse对象 JsonResponse是HttpResponse的子类，专门用来生成JSON编码的响应。 from django.http import JsonResponse response = JsonResponse({'foo': 'bar'}) print(response.content) b'{\"foo\": \"bar\"}' 默认只能传递字典类型，如果要传递非字典类型需要设置一下safe关键字参数。 response = JsonResponse([1, 2, 3], safe=False) Django shortcut functions 官方文档 render() 结合一个给定的模板和一个给定的上下文字典，并返回一个渲染后的 HttpResponse 对象。 参数： request： 用于生成响应的请求对象。 template_name：要使用的模板的完整名称，可选的参数 context：添加到模板上下文的一个字典。默认是一个空字典。如果字典中的某个值是可调用的，视图将在渲染模板之前调用它。 content_type：生成的文档要使用的MIME类型。默认为 DEFAULT_CONTENT_TYPE 设置的值。默认为'text/html' status：响应的状态码。默认为200。 　　　useing: 用于加载模板的模板引擎的名称。 一个简单的例子： from django.shortcuts import render def my_view(request): # 视图的代码写在这里 return render(request, 'myapp/index.html', {'foo': 'bar'}) 上面的代码等于： 复制代码 from django.http import HttpResponse from django.template import loader def my_view(request): # 视图代码写在这里 t = loader.get_template('myapp/index.html') c = {'foo': 'bar'} return HttpResponse(t.render(c, request)) 复制代码 redirect() 参数可以是： 一个模型：将调用模型的get_absolute_url() 函数 一个视图，可以带有参数：将使用urlresolvers.reverse 来反向解析名称 一个绝对的或相对的URL，将原封不动的作为重定向的位置。 默认返回一个临时的重定向；传递permanent=True 可以返回一个永久的重定向。 示例: 你可以用多种方式使用redirect() 函数。 传递一个具体的ORM对象（了解即可） 将调用具体ORM对象的get_absolute_url() 方法来获取重定向的URL： from django.shortcuts import redirect def my_view(request): ... object = MyModel.objects.get(...) return redirect(object) 传递一个视图的名称 def my_view(request): ... return redirect('some-view-name', foo='bar') 传递要重定向到的一个具体的网址 def my_view(request): ... return redirect('/some/url/') 当然也可以是一个完整的网址 def my_view(request): ... return redirect('http://example.com/') 默认情况下，redirect() 返回一个临时重定向。以上所有的形式都接收一个permanent 参数；如果设置为True，将返回一个永久的重定向： def my_view(request): ... object = MyModel.objects.get(...) return redirect(object, permanent=True)　　 扩展阅读： 临时重定向（响应状态码：302）和永久重定向（响应状态码：301）对普通用户来说是没什么区别的，它主要面向的是搜索引擎的机器人。 A页面临时重定向到B页面，那搜索引擎收录的就是A页面。 A页面永久重定向到B页面，那搜索引擎收录的就是B页面。 "},"python/Django/06.Django的路由系统.html":{"url":"python/Django/06.Django的路由系统.html","title":"Django的路由系统","keywords":"","body":"Django的路由系统 Django 1.11版本 URLConf官方文档 URL配置(URLconf)就像Django 所支撑网站的目录。它的本质是URL与要为该URL调用的视图函数之间的映射表. 你就是以这种方式告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。 URLconf配置 基本格式： from django.conf.urls import url urlpatterns = [ url(正则表达式, views视图函数，参数，别名), ] 注意： Django 2.0版本中的路由系统已经替换成下面的写法（官方文档）： from django.urls import path urlpatterns = [ path('articles/2003/', views.special_case_2003), path('articles//', views.year_archive), path('articles///', views.month_archive), path('articles////', views.article_detail), ] 参数说明： 正则表达式：一个正则表达式字符串 views视图函数：一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串 参数：可选的要传递给视图函数的默认参数（字典形式） 别名：一个可选的name参数 正则表达式详解 基本配置 from django.conf.urls import url from . import views urlpatterns = [ url(r'^articles/2003/$', views.special_case_2003), url(r'^articles/([0-9]{4})/$', views.year_archive), url(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive), url(r'^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$', views.article_detail), ] 注意事项 urlpatterns中的元素按照书写顺序从上往下逐一匹配正则表达式，一旦匹配成功则不再继续。 若要从URL中捕获一个值，只需要在它周围放置一对圆括号（分组匹配）。 不需要添加一个前导的反斜杠，因为每个URL 都有。例如，应该是^articles 而不是 ^/articles。 每个正则表达式前面的'r' 是可选的但是建议加上。 补充说明 # 是否开启URL访问地址后面不为/跳转至带有/的路径的配置项 APPEND_SLASH=True Django settings.py配置文件中默认没有 APPEND_SLASH 这个参数，但 Django 默认这个参数为 APPEND_SLASH = True。 其作用就是自动在网址结尾加'/'。 其效果就是： 我们定义了urls.py： from django.conf.urls import url from app01 import views urlpatterns = [ url(r'^blog/$', views.blog), ] 访问 http://www.example.com/blog 时，默认将网址自动转换为 http://www.example/com/blog/ 。 如果在settings.py中设置了 APPEND_SLASH=False，此时我们再请求 http://www.example.com/blog 时就会提示找不到页面。 分组命名匹配 上面的示例使用简单的正则表达式分组匹配（通过圆括号）来捕获URL中的值并以位置参数形式传递给视图。 在更高级的用法中，可以使用分组命名匹配的正则表达式组来捕获URL中的值并以关键字参数形式传递给视图。 在Python的正则表达式中，分组命名正则表达式组的语法是(?Ppattern)，其中name是组的名称，pattern是要匹配的模式。 下面是以上URLconf 使用命名组的重写： from django.conf.urls import url from . import views urlpatterns = [ url(r'^articles/2003/$', views.special_case_2003), url(r'^articles/(?P[0-9]{4})/$', views.year_archive), url(r'^articles/(?P[0-9]{4})/(?P[0-9]{2})/$', views.month_archive), url(r'^articles/(?P[0-9]{4})/(?P[0-9]{2})/(?P[0-9]{2})/$', views.article_detail), ] 这个实现与前面的示例完全相同，只有一个细微的差别：捕获的值作为关键字参数而不是位置参数传递给视图函数。 例如，针对url /articles/2017/12/相当于按以下方式调用视图函数： views.month_archive(request, year=\"2017\", month=\"12\") 在实际应用中，使用分组命名匹配的方式可以让你的URLconf 更加明晰且不容易产生参数顺序问题的错误，但是有些开发人员则认为分组命名组语法太丑陋、繁琐。 至于究竟应该使用哪一种，你可以根据自己的喜好来决定。 URLconf匹配的位置 URLconf 在请求的URL 上查找，将它当做一个普通的Python 字符串。不包括GET和POST参数以及域名。 例如，http://www.example.com/myapp/ 请求中，URLconf 将查找myapp/。 在http://www.example.com/myapp/?page=3 请求中，URLconf 仍将查找myapp/。 URLconf 不检查请求的方法。换句话讲，所有的请求方法 —— 同一个URL的POST、GET、HEAD等等 —— 都将路由到相同的函数。 捕获的参数永远都是字符串 每个在URLconf中捕获的参数都作为一个普通的Python字符串传递给视图，无论正则表达式使用的是什么匹配方式。例如，下面这行URLconf 中： url(r'^articles/(?P[0-9]{4})/$', views.year_archive), 传递到视图函数views.year_archive() 中的year 参数永远是一个字符串类型。 视图函数中指定默认值 # urls.py中 from django.conf.urls import url from . import views urlpatterns = [ url(r'^blog/$', views.page), url(r'^blog/page(?P[0-9]+)/$', views.page), ] # views.py中，可以为num指定默认值 def page(request, num=\"1\"): pass 在上面的例子中，两个URL模式指向相同的view - views.page - 但是第一个模式并没有从URL中捕获任何东西。 如果第一个模式匹配上了，page()函数将使用其默认参数num=“1”,如果第二个模式匹配，page()将使用正则表达式捕获到的num值。 include其他的URLconfs #At any point, your urlpatterns can “include” other URLconf modules. This 在任何时候，你的URLconf模式可以“包括”其他的URLconf模块。 #essentially “roots” a set of URLs below other ones. 基本上“root”一组匹配的URLS低于其他。 #For example, here’s an excerpt of the URLconf for the Django website itself. 例如，以下是Django网站的网址摘要。 #It includes a number of other URLconfs: 它包括许多其他网址 from django.conf.urls import include, url urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^blog/', include('blog.urls')), # 可以包含其他的URLconfs文件 ] 传递额外的参数给视图函数（了解） URLconfs 具有一个钩子，让你传递一个Python 字典作为额外的参数传递给视图函数。 django.conf.urls.url() 函数可以接收一个可选的第三个参数，它是一个字典，表示想要传递给视图函数的额外关键字参数。 例如： from django.conf.urls import url from . import views urlpatterns = [ url(r'^blog/(?P[0-9]{4})/$', views.year_archive, {'foo': 'bar'}), ] 在这个例子中，对于/blog/2005/请求，Django 将调用views.year_archive(request, year='2005', foo='bar')。 这个技术在Syndication 框架中使用，来传递元数据和选项给视图。 命名URL和URL反向解析 在使用Django 项目时，一个常见的需求是获得URL的最终形式，以用于嵌入到生成的内容中（视图中和显示给用户的URL等）或者用于处理服务器端的导航（重定向等）。 人们强烈希望不要硬编码这些URL（费力、不可扩展且容易产生错误）或者设计一种与URLconf 毫不相关的专门的URL 生成机制，因为这样容易导致一定程度上产生过期的URL。 换句话讲，需要的是一个DRY 机制。除了其它有点，它还允许设计的URL 可以自动更新而不用遍历项目的源代码来搜索并替换过期的URL。 获取一个URL 最开始想到的信息是处理它视图的标识（例如名字），查找正确的URL 的其它必要的信息有视图参数的类型（位置参数、关键字参数）和值。 Django 提供一个办法是让URL 映射是URL 设计唯一的地方。你填充你的URLconf，然后可以双向使用它： 根据用户/浏览器发起的URL 请求，它调用正确的Django 视图，并从URL 中提取它的参数需要的值。 根据Django 视图的标识和将要传递给它的参数的值，获取与之关联的URL。 第一种方式是我们在前面的章节中一直讨论的用法。第二种方式叫做反向解析URL、反向URL 匹配、反向URL 查询或者简单的URL 反查。 在需要URL 的地方，对于不同层级，Django 提供不同的工具用于URL 反查： 在模板中：使用url模板标签。 在Python 代码中：使用django.core.urlresolvers.reverse() 函数。 在更高层的与处理Django 模型实例相关的代码中：使用get_absolute_url() 方法。 上面说了一大堆，你可能并没有看懂。（那是官方文档的生硬翻译）。 咱们简单来说就是可以给我们的URL匹配规则起个名字，一个URL匹配模式起一个名字。 这样我们以后就不需要写死URL代码了，只需要通过名字来调用当前的URL。 举个简单的例子： url(r'^home', views.home, name='home'), # 给我的url匹配模式起名为 home url(r'^index/(\\d*)', views.index, name='index'), # 给我的url匹配模式起名为index 这样： 在模板里面可以这样引用： {% url 'home' %} 在views函数中可以这样引用： from django.urls import reverse reverse(\"index\", args=(\"2018\", )) 例子： 考虑下面的URLconf： from django.conf.urls import url from . import views urlpatterns = [ # ... url(r'^articles/([0-9]{4})/$', views.year_archive, name='news-year-archive'), # ... ] 根据这里的设计，某一年nnnn对应的归档的URL是/articles/nnnn/。 你可以在模板的代码中使用下面的方法获得它们： 2012 Archive {% for yearvar in year_list %} {{ yearvar }} Archive {% endfor %} 在Python 代码中，这样使用： from django.urls import reverse from django.shortcuts import redirect def redirect_to_year(request): # ... year = 2006 # ... return redirect(reverse('news-year-archive', args=(year,))) 如果出于某种原因决定按年归档文章发布的URL应该调整一下，那么你将只需要修改URLconf 中的内容。 在某些场景中，一个视图是通用的，所以在URL 和视图之间存在多对一的关系。对于这些情况，当反查URL 时，只有视图的名字还不够。 注意： 为了完成上面例子中的URL 反查，你将需要使用命名的URL 模式。URL 的名称使用的字符串可以包含任何你喜欢的字符。不只限制在合法的Python 名称。 当命名你的URL 模式时，请确保使用的名称不会与其它应用中名称冲突。如果你的URL 模式叫做comment，而另外一个应用中也有一个同样的名称，当你在模板中使用这个名称的时候不能保证将插入哪个URL。 在URL 名称中加上一个前缀，比如应用的名称，将减少冲突的可能。我们建议使用myapp-comment 而不是comment。 命名空间模式 即使不同的APP使用相同的URL名称，URL的命名空间模式也可以让你唯一反转命名的URL。 举个例子： project中的urls.py from django.conf.urls import url, include urlpatterns = [ url(r'^app01/', include('app01.urls', namespace='app01')), url(r'^app02/', include('app02.urls', namespace='app02')), ] app01中的urls.py from django.conf.urls import url from app01 import views app_name = 'app01' urlpatterns = [ url(r'^(?P\\d+)/$', views.detail, name='detail') ] app02中的urls.py from django.conf.urls import url from app02 import views app_name = 'app02' urlpatterns = [ url(r'^(?P\\d+)/$', views.detail, name='detail') ] 现在，我的两个app中 url名称重复了，我反转URL的时候就可以通过命名空间的名称得到我当前的URL。 语法： '命名空间名称:URL名称' 模板中使用： {% url 'app01:detail' pk=12 pp=99 %} views中的函数中使用 v = reverse('app01:detail', kwargs={'pk':11}) 这样即使app中URL的命名相同，我也可以反转得到正确的URL了。 "},"python/Django/07.Django模板系统.html":{"url":"python/Django/07.Django模板系统.html","title":"Django模板系统","keywords":"","body":"Django模板系统 常用语法 只需要记两种特殊符号： {{ }}和 {% %} 变量相关的用{{}}，逻辑相关的用{%%}. 变量 {{ 变量名 }} 变量名由字母数字和下划线组成。 点（.）在模板语言中有特殊的含义，用来获取对象的相应属性值。 几个例子： view中代码： def template_test(request): l = [11, 22, 33] d = {\"name\": \"alex\"} class Person(object): def __init__(self, name, age): self.name = name self.age = age def dream(self): return \"{} is dream...\".format(self.name) Alex = Person(name=\"Alex\", age=34) Egon = Person(name=\"Egon\", age=9000) Eva_J = Person(name=\"Eva_J\", age=18) person_list = [Alex, Egon, Eva_J] return render(request, \"template_test.html\", {\"l\": l, \"d\": d, \"person_list\": person_list}) 模板中支持的写法： {# 取l中的第一个参数 #} {{ l.0 }} {# 取字典中key的值 #} {{ d.name }} {# 取对象的name属性 #} {{ person_list.0.name }} {# .操作只能调用不带参数的方法 #} {{ person_list.0.dream }} Filters过滤器 语法： {{ value|filter_name:参数 }} default {{ value:default: \"nothing\"}} 如果value值没传的话就显示nothing length {{ value|length }} '|'左右没有空格没有空格没有空格 返回value的长度，如 value=['a', 'b', 'c', 'd']的话，就显示4. filesizeformat 将值格式化为一个 “人类可读的” 文件尺寸 （例如 '13 KB', '4.1 MB', '102 bytes', 等等）。例如： {{ value|filesizeformat }} 如果 value 是 123456789，输出将会是 117.7 MB。 slice 切片 {{value|slice:\"2:-1\"}} date 格式化 {{ value|date:\"Y-m-d H:i:s\"}} safe Django的模板中会对HTML标签和JS等语法标签进行自动转义，原因显而易见，这样是为了安全。但是有的时候我们可能不希望这些HTML元素被转义，比如我们做一个内容管理系统，后台添加的文章中是经过修饰的，这些修饰可能是通过一个类似于FCKeditor编辑加注了HTML修饰符的文本，如果自动转义的话显示的就是保护HTML标签的源文件。为了在Django中关闭HTML的自动转义有两种方式，如果是一个单独的变量我们可以通过过滤器“|safe”的方式告诉Django这段代码是安全的不必转义。 比如： value = \"点我\" {{ value|safe}} truncatechars 如果字符串字符多于指定的字符数量，那么会被截断。截断的字符串将以可翻译的省略号序列（“...”）结尾。 参数：截断的字符数 {{ value|truncatechars:9}} 自定义filter 自定义过滤器只是带有一个或两个参数的Python函数: 变量（输入）的值 - -不一定是一个字符串 参数的值 - 这可以有一个默认值，或完全省略 例如，在过滤器{{var | foo：“bar”}}中，过滤器`foo`将传递变量`var`和参数`“bar”`。 自定义filter代码文件摆放位置： app01/ __init__.py models.py templatetags/ # 在app01下面新建一个package package __init__.py # 这个文件没有会不能引入文件 app01_filters.py # 建一个存放自定义filter的文件 views.py 编写自定义filter from django import template # register这个'变量'不能改变 register = template.Library() # 自定义过滤器 @register.filter(name=\"cut\") def cut(value, arg): return value.replace(arg, \"\") # 自定义带参数的过滤器 @register.filter(name=\"addSB\") def add_sb(value): return \"{} SB\".format(value) # 自定义标签 @register.simple_tag def simple_tag_multi(v1,v2): return v1 * v2 使用自定义filter {# 先导入我们自定义filter那个文件 #} {% load app01_filters %} {# 使用我们自定义的filter #} {{ somevariable|cut:\"0\" }} {{ d.name|addSB }} Tags for {% for user in user_list %} {{ user.name }} {% endfor %} for循环可用的一些参数： Variable Description forloop.counter 当前循环的索引值（从1开始） forloop.counter0 当前循环的索引值（从0开始） forloop.revcounter 当前循环的倒序索引值（从1开始） forloop.revcounter0 当前循环的倒序索引值（从0开始） forloop.first 当前循环是不是第一次循环（布尔值） forloop.last 当前循环是不是最后一次循环（布尔值） forloop.parentloop 本层循环的外层循环 for ... empty {% for user in user_list %} {{ user.name }} {% empty %} 空空如也 {% endfor %} if,elif和else {% if user_list %} 用户人数：{{ user_list|length }} {% elif black_list %} 黑名单数：{{ black_list|length }} {% else %} 没有用户 {% endif %} 当然也可以只有if和else {% if user_list|length > 5 %} 七座豪华SUV {% else %} 黄包车 {% endif %} if语句支持 and 、or、==、>、=、in、not in、is、is not判断。 with 定义一个中间变量 {% with total=business.employees.count %} {{ total }} employee{{ total|pluralize }} {% endwith %} ` csrf_token 这个标签用于跨站请求伪造保护。 在页面的form表单里面写上{% csrf_token %} 注释 {# ... #} 母板 Title {% block page-css %} {% endblock %} 这是母板的标题 {% block page-main %} {% endblock %} 母板底部内容 {% block page-js %} {% endblock %} 注意：我们通常会在母板中定义页面专用的CSS块和JS块，方便子页面替换。 继承母板 在子页面中在页面最上方使用下面的语法来继承母板。 {% extends 'layouts.html' %} 块（block） 通过在母板中使用{% block xxx %}来定义\"块\"。 在子页面中通过定义母板中的block名来对应替换母板中相应的内容。 {% block page-main %} 世情薄 人情恶 雨送黄昏花易落 {% endblock %} 组件 可以将常用的页面内容如导航条，页尾信息等组件保存在单独的文件中，然后在需要使用的地方按如下语法导入即可。 {% include 'navbar.html' %} 静态文件相关 {% load static %} 引用JS文件时使用： {% load static %} 某个文件多处被用到可以存为一个变量 {% load static %} {% static \"images/hi.jpg\" as myphoto %} 使用get_static_prefix {% load static %} 或者 {% load static %} {% get_static_prefix as STATIC_PREFIX %} 自定义simpletag 和自定义filter类似，只不过接收更灵活的参数。 定义注册simple tag @register.simple_tag(name=\"plus\") def plus(a, b, c): return \"{} + {} + {}\".format(a, b, c) 使用自定义simple tag {% load app01_demo %} {# simple tag #} {% plus \"1\" \"2\" \"abc\" %} inclusion_tag 多用于返回html代码片段 示例： templatetags/my_inclusion.py from django import template register = template.Library() @register.inclusion_tag('result.html') def show_results(n): n = 1 if n templates/snippets/result.html {% for choice in data %} {{ choice }} {% endfor %} templates/index.html inclusion_tag test {% load inclusion_tag_test %} {% show_results 10 %} "},"python/Django/08.Django模型ORM.html":{"url":"python/Django/08.Django模型ORM.html","title":"Django模型ORM","keywords":"","body":"Object Relational Mapping(ORM) ORM介绍 ORM概念 对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。 简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。 ORM在业务逻辑层和数据库层之间充当了桥梁的作用。 ORM由来 让我们从O/R开始。字母O起源于\"对象\"(Object),而R则来自于\"关系\"(Relational)。 几乎所有的软件开发过程中都会涉及到对象和关系数据库。在用户层面和业务逻辑层面，我们是面向对象的。当对象的信息发生变化的时候，我们就需要把对象的信息保存在关系数据库中。 按照之前的方式来进行开发就会出现程序员会在自己的业务逻辑代码中夹杂很多SQL语句用来增加、读取、修改、删除相关数据，而这些代码通常都是重复的。 ORM的优势 ORM解决的主要问题是对象和关系的映射。它通常把一个类和一个表一一对应，类的每个实例对应表中的一条记录，类的每个属性对应表中的每个字段。 ORM提供了对数据库的映射，不用直接编写SQL代码，只需像操作对象一样从数据库操作数据。 让软件开发人员专注于业务逻辑的处理，提高了开发效率。 ORM的劣势 ORM的缺点是会在一定程度上牺牲程序的执行效率。 ORM用多了SQL语句就不会写了，关系数据库相关技能退化... ORM总结 ORM只是一种工具，工具确实能解决一些重复，简单的劳动。这是不可否认的。 但我们不能指望某个工具能一劳永逸地解决所有问题，一些特殊问题还是需要特殊处理的。 但是在整个软件开发过程中需要特殊处理的情况应该都是很少的，否则所谓的工具也就失去了它存在的意义。 Django中的ORM Django项目使用MySQL数据库 1.在Django项目的settings.py文件中，配置数据库连接信息： DATABASES = { \"default\": { \"ENGINE\": \"django.db.backends.mysql\", \"NAME\": \"你的数据库名称\", # 需要自己手动创建数据库 \"USER\": \"数据库用户名\", \"PASSWORD\": \"数据库密码\", \"HOST\": \"数据库IP\", \"POST\": 3306 } } 2.在Django项目的init.py文件中写如下代码，告诉Django使用pymysql模块连接MySQL数据库: import pymysql pymysql.install_as_MySQLdb() Model 在Django中model是你数据的单一、明确的信息来源。它包含了你存储的数据的重要字段和行为。通常，一个模型（model）映射到一个数据库表， 基本情况： 每个模型都是一个Python类，它是django.db.models.Model的子类。 模型的每个属性都代表一个数据库字段。 综上所述，Django为您提供了一个自动生成的数据库访问API，详询官方文档链接。 快速入门 下面这个例子定义了一个 Person 模型，包含first_name 和 last_name。 from django.db import models class Person(models.Model): first_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30) first_name 和 last_name 是模型的字段。每个字段被指定为一个类属性，每个属性映射到一个数据库列。 上面的 Person 模型将会像这样创建一个数据库表： CREATE TABLE myapp_person ( \"id\" serial NOT NULL PRIMARY KEY, \"first_name\" varchar(30) NOT NULL, \"last_name\" varchar(30) NOT NULL ); 一些说明： 表myapp_person的名称是自动生成的，如果你要自定义表名，需要在model的Meta类中指定 db_table 参数，强烈建议使用小写表名，特别是使用MySQL作为后端数据库时。 id字段是自动添加的，如果你想要指定自定义主键，只需在其中一个字段中指定 primary_key=True 即可。如果Django发现你已经明确地设置了Field.primary_key，它将不会添加自动ID列。 本示例中的CREATE TABLE SQL使用PostgreSQL语法进行格式化，但值得注意的是，Django会根据配置文件中指定的数据库后端类型来生成相应的SQL语句。 Django支持MySQL5.5及更高版本。 字段 AutoField(Field) - int自增列，必须填入参数 primary_key=True BigAutoField(AutoField) - bigint自增列，必须填入参数 primary_key=True 注：当model中如果没有自增列，则自动会创建一个列名为id的列 from django.db import models class UserInfo(models.Model): # 自动创建一个列名为id的且为自增的整数列 username = models.CharField(max_length=32) class Group(models.Model): # 自定义自增列 nid = models.AutoField(primary_key=True) name = models.CharField(max_length=32) SmallIntegerField(IntegerField): - 小整数 -32768 ～ 32767 PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField) - 正小整数 0 ～ 32767 IntegerField(Field) - 整数列(有符号的) -2147483648 ～ 2147483647 PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField) - 正整数 0 ～ 2147483647 BigIntegerField(IntegerField): - 长整型(有符号的) -9223372036854775808 ～ 9223372036854775807 BooleanField(Field) - 布尔值类型 NullBooleanField(Field): - 可以为空的布尔值 CharField(Field) - 字符类型 - 必须提供max_length参数， max_length表示字符长度 TextField(Field) - 文本类型 EmailField(CharField)： - 字符串类型，Django Admin以及ModelForm中提供验证机制 IPAddressField(Field) - 字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制 GenericIPAddressField(Field) - 字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6 - 参数： protocol，用于指定Ipv4或Ipv6， 'both',\"ipv4\",\"ipv6\" unpack_ipv4， 如果指定为True，则输入::ffff:192.0.2.1时候，可解析为192.0.2.1，开启此功能，需要protocol=\"both\" URLField(CharField) - 字符串类型，Django Admin以及ModelForm中提供验证 URL SlugField(CharField) - 字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号） CommaSeparatedIntegerField(CharField) - 字符串类型，格式必须为逗号分割的数字 UUIDField(Field) - 字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证 FilePathField(Field) - 字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能 - 参数： path, 文件夹路径 match=None, 正则匹配 recursive=False, 递归下面的文件夹 allow_files=True, 允许文件 allow_folders=False, 允许文件夹 FileField(Field) - 字符串，路径保存在数据库，文件上传到指定目录 - 参数： upload_to = \"\" 上传文件的保存路径 storage = None 存储组件，默认django.core.files.storage.FileSystemStorage ImageField(FileField) - 字符串，路径保存在数据库，文件上传到指定目录 - 参数： upload_to = \"\" 上传文件的保存路径 storage = None 存储组件，默认django.core.files.storage.FileSystemStorage width_field=None, 上传图片的高度保存的数据库字段名（字符串） height_field=None 上传图片的宽度保存的数据库字段名（字符串） DateTimeField(DateField) - 日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] DateField(DateTimeCheckMixin, Field) - 日期格式 YYYY-MM-DD TimeField(DateTimeCheckMixin, Field) - 时间格式 HH:MM[:ss[.uuuuuu]] DurationField(Field) - 长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型 FloatField(Field) - 浮点型 DecimalField(Field) - 10进制小数 - 参数： max_digits，小数总长度 decimal_places，小数位长度 BinaryField(Field) - 二进制类型 自定义字段 class UnsignedIntegerField(models.IntegerField): def db_type(self, connection): return 'integer UNSIGNED' PS: 返回值为字段在数据库中的属性，Django字段默认的值为： 'AutoField': 'integer AUTO_INCREMENT', 'BigAutoField': 'bigint AUTO_INCREMENT', 'BinaryField': 'longblob', 'BooleanField': 'bool', 'CharField': 'varchar(%(max_length)s)', 'CommaSeparatedIntegerField': 'varchar(%(max_length)s)', 'DateField': 'date', 'DateTimeField': 'datetime', 'DecimalField': 'numeric(%(max_digits)s, %(decimal_places)s)', 'DurationField': 'bigint', 'FileField': 'varchar(%(max_length)s)', 'FilePathField': 'varchar(%(max_length)s)', 'FloatField': 'double precision', 'IntegerField': 'integer', 'BigIntegerField': 'bigint', 'IPAddressField': 'char(15)', 'GenericIPAddressField': 'char(39)', 'NullBooleanField': 'bool', 'OneToOneField': 'integer', 'PositiveIntegerField': 'integer UNSIGNED', 'PositiveSmallIntegerField': 'smallint UNSIGNED', 'SlugField': 'varchar(%(max_length)s)', 'SmallIntegerField': 'smallint', 'TextField': 'longtext', 'TimeField': 'time', 'UUIDField': 'char(32)', 自定义char类型字段： class FixedCharField(models.Field): \"\"\" 自定义的char类型的字段类 \"\"\" def __init__(self, max_length, *args, **kwargs): self.max_length = max_length super(FixedCharField, self).__init__(max_length=max_length, *args, **kwargs) def db_type(self, connection): \"\"\" 限定生成数据库表的字段类型为char，长度为max_length指定的值 \"\"\" return 'char(%s)' % self.max_length class Class(models.Model): id = models.AutoField(primary_key=True) title = models.CharField(max_length=25) # 使用自定义的char类型的字段 cname = FixedCharField(max_length=25) 创建的表结构： `mysql> desc app01_class; Field Type Null Key Default Extra id int(11) NO PRI NULL auto_increment title varchar(25) NO NULL cname char(25) NO NULL 注意事项 1.触发Model中的验证和错误提示有两种方式： a. Django Admin中的错误信息会优先根据Admiin内部的ModelForm错误信息提示，如果都成功，才来检查Model的字段并显示指定错误信息 b. 使用ModelForm c. 调用Model对象的 clean_fields 方法，如： # models.py class UserInfo(models.Model): nid = models.AutoField(primary_key=True) username = models.CharField(max_length=32) email = models.EmailField(error_messages={'invalid': '格式错了.'}) # views.py def index(request): obj = models.UserInfo(username='11234', email='uu') try: print(obj.clean_fields()) except Exception as e: print(e) return HttpResponse('ok') # Model的clean方法是一个钩子，可用于定制操作，如：上述的异常处理。 2.Admin中修改错误提示 # admin.py from django.contrib import admin from model_club import models from django import forms class UserInfoForm(forms.ModelForm): age = forms.IntegerField(initial=1, error_messages={'required': '请输入数值.', 'invalid': '年龄必须为数值.'}) class Meta: model = models.UserInfo # fields = ('username',) fields = \"__all__\" exclude = ['title'] labels = { 'name':'Writer', } help_texts = {'name':'some useful help text.',} error_messages={ 'name':{'max_length':\"this writer name is too long\"} } widgets={'name':Textarea(attrs={'cols':80,'rows':20})} class UserInfoAdmin(admin.ModelAdmin): form = UserInfoForm admin.site.register(models.UserInfo, UserInfoAdmin) 字段参数 null 数据库中字段是否可以为空 db_column 数据库中字段的列名 default 数据库中字段的默认值 primary_key 数据库中字段是否为主键 db_index 数据库中字段是否可以建立索引 unique 数据库中字段是否可以建立唯一索引 unique_for_date 数据库中字段【日期】部分是否可以建立唯一索引 unique_for_month 数据库中字段【月】部分是否可以建立唯一索引 unique_for_year 数据库中字段【年】部分是否可以建立唯一索引 verbose_name Admin中显示的字段名称 blank Admin中是否允许用户输入为空 editable Admin中是否可以编辑 help_text Admin中该字段的提示信息 choices Admin中显示选择框的内容，用不变动的数据放在内存中从而避免跨表操作 如：gf = models.IntegerField(choices=[(0, '何穗'),(1, '大表姐'),],default=1) error_messages 自定义错误信息（字典类型），从而定制想要显示的错误信息； 字典健：null, blank, invalid, invalid_choice, unique, and unique_for_date 如：{'null': \"不能为空.\", 'invalid': '格式错误'} validators 自定义错误验证（列表类型），从而定制想要的验证规则 from django.core.validators import RegexValidator from django.core.validators import EmailValidator,URLValidator,DecimalValidator,\\ MaxLengthValidator,MinLengthValidator,MaxValueValidator,MinValueValidator 如： test = models.CharField( max_length=32, error_messages={ 'c1': '优先错信息1', 'c2': '优先错信息2', 'c3': '优先错信息3', }, validators=[ RegexValidator(regex='root_\\d+', message='错误了', code='c1'), RegexValidator(regex='root_112233\\d+', message='又错误了', code='c2'), EmailValidator(message='又错误了', code='c3'), ] ) 元信息 class UserInfo(models.Model): nid = models.AutoField(primary_key=True) username = models.CharField(max_length=32) class Meta: # 数据库中生成的表名称 默认 app名称 + 下划线 + 类名 db_table = \"table_name\" # 联合索引 index_together = [ (\"pub_date\", \"deadline\"), ] # 联合唯一索引 unique_together = ((\"driver\", \"restaurant\"),) # admin中显示的表名称 verbose_name # verbose_name加s verbose_name_plural 多表关系和参数 ForeignKey(ForeignObject) # ForeignObject(RelatedField) to, # 要进行关联的表名 to_field=None, # 要关联的表中的字段名称 on_delete=None, # 当删除关联表中的数据时，当前表与其关联的行的行为 - models.CASCADE，删除关联数据，与之关联也删除 - models.DO_NOTHING，删除关联数据，引发错误IntegrityError - models.PROTECT，删除关联数据，引发错误ProtectedError - models.SET_NULL，删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空） - models.SET_DEFAULT，删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值） - models.SET，删除关联数据， a. 与之关联的值设置为指定值，设置：models.SET(值) b. 与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象) def func(): return 10 class MyModel(models.Model): user = models.ForeignKey( to=\"User\", to_field=\"id\" on_delete=models.SET(func),) related_name=None, # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all() related_query_name=None, # 反向操作时，使用的连接前缀，用于替换【表名】 如： models.UserGroup.objects.filter(表名__字段名=1).values('表名__字段名') limit_choices_to=None, # 在Admin或ModelForm中显示关联数据时，提供的条件： # 如： - limit_choices_to={'nid__gt': 5} - limit_choices_to=lambda : {'nid__gt': 5} from django.db.models import Q - limit_choices_to=Q(nid__gt=10) - limit_choices_to=Q(nid=8) | Q(nid__gt=10) - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) & Q(caption='root') db_constraint=True # 是否在数据库中创建外键约束 parent_link=False # 在Admin中是否显示关联数据 OneToOneField(ForeignKey) to, # 要进行关联的表名 to_field=None # 要关联的表中的字段名称 on_delete=None, # 当删除关联表中的数据时，当前表与其关联的行的行为 ###### 对于一对一 ###### # 1. 一对一其实就是 一对多 + 唯一索引 # 2.当两个类之间有继承关系时，默认会创建一个一对一字段 # 如下会在A表中额外增加一个c_ptr_id列且唯一： class C(models.Model): nid = models.AutoField(primary_key=True) part = models.CharField(max_length=12) class A(C): id = models.AutoField(primary_key=True) code = models.CharField(max_length=1) ManyToManyField(RelatedField) to, # 要进行关联的表名 related_name=None, # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all() related_query_name=None, # 反向操作时，使用的连接前缀，用于替换【表名】 如： models.UserGroup.objects.filter(表名__字段名=1).values('表名__字段名') limit_choices_to=None, # 在Admin或ModelForm中显示关联数据时，提供的条件： # 如： - limit_choices_to={'nid__gt': 5} - limit_choices_to=lambda : {'nid__gt': 5} from django.db.models import Q - limit_choices_to=Q(nid__gt=10) - limit_choices_to=Q(nid=8) | Q(nid__gt=10) - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) & Q(caption='root') symmetrical=None, # 仅用于多对多自关联时，symmetrical用于指定内部是否创建反向操作的字段 # 做如下操作时，不同的symmetrical会有不同的可选字段 models.BB.objects.filter(...) # 可选字段有：code, id, m1 class BB(models.Model): code = models.CharField(max_length=12) m1 = models.ManyToManyField('self',symmetrical=True) # 可选字段有: bb, code, id, m1 class BB(models.Model): code = models.CharField(max_length=12) m1 = models.ManyToManyField('self',symmetrical=False) through=None, # 自定义第三张表时，使用字段用于指定关系表 through_fields=None, # 自定义第三张表时，使用字段用于指定关系表中那些字段做多对多关系表 from django.db import models class Person(models.Model): name = models.CharField(max_length=50) class Group(models.Model): name = models.CharField(max_length=128) members = models.ManyToManyField( Person, through='Membership', through_fields=('group', 'person'), ) class Membership(models.Model): group = models.ForeignKey(Group, on_delete=models.CASCADE) person = models.ForeignKey(Person, on_delete=models.CASCADE) inviter = models.ForeignKey( Person, on_delete=models.CASCADE, related_name=\"membership_invites\", ) invite_reason = models.CharField(max_length=64) db_constraint=True, # 是否在数据库中创建外键约束 db_table=None, # 默认创建第三张表时，数据库中表的名称 ORM操作 基本操作 # 增 models.Tb1.objects.create(c1='xx', c2='oo') # 增加一条数据，可以接受字典类型数据 **kwargs obj = models.Tb1(c1='xx', c2='oo') obj.save() # 查 models.Tb1.objects.get(id=123) # 获取单条数据，不存在则报错（不建议） models.Tb1.objects.all() # 获取全部 models.Tb1.objects.filter(name='seven') # 获取指定条件的数据 models.Tb1.objects.exclude(name='seven') # 去除指定条件的数据 # 删 # models.Tb1.objects.filter(name='seven').delete() # 删除指定条件的数据 # 改 models.Tb1.objects.filter(name='seven').update(gender='0') # 将指定条件的数据更新，均支持 **kwargs obj = models.Tb1.objects.get(id=1) obj.c1 = '111' obj.save() # 修改单条数据 进阶操作 # 获取个数 # # models.Tb1.objects.filter(name='seven').count() # 大于，小于 # # models.Tb1.objects.filter(id__gt=1) # 获取id大于1的值 # models.Tb1.objects.filter(id__gte=1) # 获取id大于等于1的值 # models.Tb1.objects.filter(id__lt=10) # 获取id小于10的值 # models.Tb1.objects.filter(id__lte=10) # 获取id小于10的值 # models.Tb1.objects.filter(id__lt=10, id__gt=1) # 获取id大于1 且 小于10的值 # in # # models.Tb1.objects.filter(id__in=[11, 22, 33]) # 获取id等于11、22、33的数据 # models.Tb1.objects.exclude(id__in=[11, 22, 33]) # not in # isnull # Entry.objects.filter(pub_date__isnull=True) # contains # # models.Tb1.objects.filter(name__contains=\"ven\") # models.Tb1.objects.filter(name__icontains=\"ven\") # icontains大小写不敏感 # models.Tb1.objects.exclude(name__icontains=\"ven\") # range # # models.Tb1.objects.filter(id__range=[1, 2]) # 范围bettwen and # 其他类似 # # startswith，istartswith, endswith, iendswith, # order by # # models.Tb1.objects.filter(name='seven').order_by('id') # asc # models.Tb1.objects.filter(name='seven').order_by('-id') # desc # group by # # from django.db.models import Count, Min, Max, Sum # models.Tb1.objects.filter(c1=1).values('id').annotate(c=Count('num')) # SELECT \"app01_tb1\".\"id\", COUNT(\"app01_tb1\".\"num\") AS \"c\" FROM \"app01_tb1\" WHERE \"app01_tb1\".\"c1\" = 1 GROUP BY \"app01_tb1\".\"id\" # limit 、offset # # models.Tb1.objects.all()[10:20] # regex正则匹配，iregex 不区分大小写 # # Entry.objects.get(title__regex=r'^(An?|The) +') # Entry.objects.get(title__iregex=r'^(an?|the) +') # date # # Entry.objects.filter(pub_date__date=datetime.date(2005, 1, 1)) # Entry.objects.filter(pub_date__date__gt=datetime.date(2005, 1, 1)) # year # # Entry.objects.filter(pub_date__year=2005) # Entry.objects.filter(pub_date__year__gte=2005) # month # # Entry.objects.filter(pub_date__month=12) # Entry.objects.filter(pub_date__month__gte=6) # day # # Entry.objects.filter(pub_date__day=3) # Entry.objects.filter(pub_date__day__gte=3) # week_day # # Entry.objects.filter(pub_date__week_day=2) # Entry.objects.filter(pub_date__week_day__gte=2) # hour # # Event.objects.filter(timestamp__hour=23) # Event.objects.filter(time__hour=5) # Event.objects.filter(timestamp__hour__gte=12) # minute # # Event.objects.filter(timestamp__minute=29) # Event.objects.filter(time__minute=46) # Event.objects.filter(timestamp__minute__gte=29) # second # # Event.objects.filter(timestamp__second=31) # Event.objects.filter(time__second=2) # Event.objects.filter(timestamp__second__gte=31) 高级操作 # extra # 在QuerySet的基础上继续执行子语句 # extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None) # select和select_params是一组，where和params是一组，tables用来设置from哪个表 # Entry.objects.extra(select={'new_id': \"select col from sometable where othercol > %s\"}, select_params=(1,)) # Entry.objects.extra(where=['headline=%s'], params=['Lennon']) # Entry.objects.extra(where=[\"foo='a' OR bar = 'a'\", \"baz = 'a'\"]) # Entry.objects.extra(select={'new_id': \"select id from tb where id > %s\"}, select_params=(1,), order_by=['-nid']) 举个例子： models.UserInfo.objects.extra( select={'newid':'select count(1) from app01_usertype where id>%s'}, select_params=[1,], where = ['age>%s'], params=[18,], order_by=['-age'], tables=['app01_usertype'] ) \"\"\" select app01_userinfo.id, (select count(1) from app01_usertype where id>1) as newid from app01_userinfo,app01_usertype where app01_userinfo.age > 18 order by app01_userinfo.age desc \"\"\" # 执行原生SQL # 更高灵活度的方式执行原生SQL语句 # from django.db import connection, connections # cursor = connection.cursor() # cursor = connections['default'].cursor() # cursor.execute(\"\"\"SELECT * from auth_user where id = %s\"\"\", [1]) # row = cursor.fetchone() QuerySet相关方法 ################################################################## # PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET # ################################################################## def all(self) # 获取所有的数据对象 def filter(self, *args, **kwargs) # 条件查询 # 条件可以是：参数，字典，Q def exclude(self, *args, **kwargs) # 条件查询 # 条件可以是：参数，字典，Q def select_related(self, *fields) 性能相关：表之间进行join连表操作，一次性获取关联的数据。 总结： 1. select_related主要针一对一和多对一关系进行优化。 2. select_related使用SQL的JOIN语句进行优化，通过减少SQL查询的次数来进行优化、提高性能。 def prefetch_related(self, *lookups) 性能相关：多表连表操作时速度会慢，使用其执行多次SQL查询在Python代码中实现连表操作。 总结： 1. 对于多对多字段（ManyToManyField）和一对多字段，可以使用prefetch_related()来进行优化。 2. prefetch_related()的优化方式是分别查询每个表，然后用Python处理他们之间的关系。 def annotate(self, *args, **kwargs) # 用于实现聚合group by查询 from django.db.models import Count, Avg, Max, Min, Sum v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id')) # SELECT u_id, COUNT(ui) AS `uid` FROM UserInfo GROUP BY u_id v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id')).filter(uid__gt=1) # SELECT u_id, COUNT(ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1 v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id',distinct=True)).filter(uid__gt=1) # SELECT u_id, COUNT( DISTINCT ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1 def distinct(self, *field_names) # 用于distinct去重 models.UserInfo.objects.values('nid').distinct() # select distinct nid from userinfo 注：只有在PostgreSQL中才能使用distinct进行去重 def order_by(self, *field_names) # 用于排序 models.UserInfo.objects.all().order_by('-id','age') def extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None) # 构造额外的查询条件或者映射，如：子查询 Entry.objects.extra(select={'new_id': \"select col from sometable where othercol > %s\"}, select_params=(1,)) Entry.objects.extra(where=['headline=%s'], params=['Lennon']) Entry.objects.extra(where=[\"foo='a' OR bar = 'a'\", \"baz = 'a'\"]) Entry.objects.extra(select={'new_id': \"select id from tb where id > %s\"}, select_params=(1,), order_by=['-nid']) def reverse(self): # 倒序 models.UserInfo.objects.all().order_by('-nid').reverse() # 注：如果存在order_by，reverse则是倒序，如果多个排序则一一倒序 def defer(self, *fields): models.UserInfo.objects.defer('username','id') 或 models.UserInfo.objects.filter(...).defer('username','id') #映射中排除某列数据 def only(self, *fields): #仅取某个表中的数据 models.UserInfo.objects.only('username','id') 或 models.UserInfo.objects.filter(...).only('username','id') def using(self, alias): 指定使用的数据库，参数为别名（setting中的设置） ################################################## # PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS # ################################################## def raw(self, raw_query, params=None, translations=None, using=None): # 执行原生SQL models.UserInfo.objects.raw('select * from userinfo') # 如果SQL是其他表时，必须将名字设置为当前UserInfo对象的主键列名 models.UserInfo.objects.raw('select id as nid from 其他表') # 为原生SQL设置参数 models.UserInfo.objects.raw('select id as nid from userinfo where nid>%s', params=[12,]) # 将获取的到列名转换为指定列名 name_map = {'first': 'first_name', 'last': 'last_name', 'bd': 'birth_date', 'pk': 'id'} Person.objects.raw('SELECT * FROM some_other_table', translations=name_map) # 指定数据库 models.UserInfo.objects.raw('select * from userinfo', using=\"default\") ################### 原生SQL ################### from django.db import connection, connections cursor = connection.cursor() # cursor = connections['default'].cursor() cursor.execute(\"\"\"SELECT * from auth_user where id = %s\"\"\", [1]) row = cursor.fetchone() # fetchall()/fetchmany(..) def values(self, *fields): # 获取每行数据为字典格式 def values_list(self, *fields, **kwargs): # 获取每行数据为元祖 def dates(self, field_name, kind, order='ASC'): # 根据时间进行某一部分进行去重查找并截取指定内容 # kind只能是：\"year\"（年）, \"month\"（年-月）, \"day\"（年-月-日） # order只能是：\"ASC\" \"DESC\" # 并获取转换后的时间 - year : 年-01-01 - month: 年-月-01 - day : 年-月-日 models.DatePlus.objects.dates('ctime','day','DESC') def datetimes(self, field_name, kind, order='ASC', tzinfo=None): # 根据时间进行某一部分进行去重查找并截取指定内容，将时间转换为指定时区时间 # kind只能是 \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\" # order只能是：\"ASC\" \"DESC\" # tzinfo时区对象 models.DDD.objects.datetimes('ctime','hour',tzinfo=pytz.UTC) models.DDD.objects.datetimes('ctime','hour',tzinfo=pytz.timezone('Asia/Shanghai')) \"\"\" pip3 install pytz import pytz pytz.all_timezones pytz.timezone(‘Asia/Shanghai’) \"\"\" def none(self): # 空QuerySet对象 #################################### # METHODS THAT DO DATABASE QUERIES # #################################### def aggregate(self, *args, **kwargs): # 聚合函数，获取字典类型聚合结果 from django.db.models import Count, Avg, Max, Min, Sum result = models.UserInfo.objects.aggregate(k=Count('u_id', distinct=True), n=Count('nid')) ===> {'k': 3, 'n': 4} def count(self): # 获取个数 def get(self, *args, **kwargs): # 获取单个对象 def create(self, **kwargs): # 创建对象 def bulk_create(self, objs, batch_size=None): # 批量插入 # batch_size表示一次插入的个数 objs = [ models.DDD(name='r11'), models.DDD(name='r22') ] models.DDD.objects.bulk_create(objs, 10) def get_or_create(self, defaults=None, **kwargs): # 如果存在，则获取，否则，创建 # defaults 指定创建时，其他字段的值 obj, created = models.UserInfo.objects.get_or_create(username='root1', defaults={'email': '1111111','u_id': 2, 't_id': 2}) def update_or_create(self, defaults=None, **kwargs): # 如果存在，则更新，否则，创建 # defaults 指定创建时或更新时的其他字段 obj, created = models.UserInfo.objects.update_or_create(username='root1', defaults={'email': '1111111','u_id': 2, 't_id': 1}) def first(self): # 获取第一个 def last(self): # 获取最后一个 def in_bulk(self, id_list=None): # 根据主键ID进行查找 id_list = [11,21,31] models.DDD.objects.in_bulk(id_list) def delete(self): # 删除 def update(self, **kwargs): # 更新 def exists(self): # 是否有结果 其他操作 "},"python/Django/09.Django路由系统.html":{"url":"python/Django/09.Django路由系统.html","title":"Django路由系统","keywords":"","body":"Django路由系统 URL 概要 我们要在Django项目中为应用程序设计URL，我们可以创建一个名为URLconf（通常为urls.py）的Python模块。 这个模块是纯Python代码，是一个简单的正则表达式到Python函数（视图）之间的映射。 这种映射关系可以很简短也可以很复杂。它还可以引用其他的映射关系。 Django如何处理一个请求 如果用户请求一个由Django提供服务的站点，它将按照以下逻辑决定执行哪些代码： 1.通常不考虑中间件的情况下，Django将会确定要使用的根URLconf模块。 2.Django加载该Python模块并查找变量--urlpatterns，这个变量应该是一个由django.conf.urls.url()实例组成的列表。 3.Django按照顺序遍历每一个URL模式，并停在与本次请求的URL匹配的第一个URL模式。 4.一旦一个正则表达式匹配上用户请求的URL，Django就会导入并调用给定的视图，该视图是一个简单的Python函数（或基于类的视图）。 该视图将被传入以下参数： 一个请求示例--`request`。 正则表达式中使用`分组`捕获的值将作为位置参数传递给视图。 正则表达式中的`命名分组`捕获的值将会以关键字方式传递给视图，但是它可以被直接传参方式覆盖。 5.如果没有正则表达式匹配或者在此过程中发生了异常，Django都会调用适当的错误处理视图。 注意： 分组和命名分组不能同时使用。 请求URL: http://127.0.0.1:8000/kwargs_test/123/abc/ url(r'^kwargs_test/(\\d+)/(?P\\w+)/', views.kwargs_test) 视图： def kwargs_test(request, *args, **kwargs): print(args, kwargs) return HttpResponse(\"OK\") 输出： () {'name': 'abc',} django.conf.urls.url()的关键字参数会覆盖正则表达式中命名分组捕获的值。 请求URL: http://127.0.0.1:8000/kwargs_test/123/abc/ url(r'^kwargs_test/(\\d+)/(?P\\w+)/', views.kwargs_test, {\"name1\": \"Q1mi\"}), 视图： def kwargs_test(request, args, *kwargs): print(args, kwargs) return HttpResponse(\"OK\") 输出： () {'name': 'abc', 'name1': 'Q1mi'} 小总结： 我们现在掌握了三种向视图函数传递参数的方法： 在正则匹配模式中使用分组模式从请求的URL中捕获参数并以位置参数的形式传递给视图。 在正则匹配模式中使用命名分组模式从请求的URL中捕获参数并以关键字参数的形式传递给视图。 通过给django.conf.urls.url()传递参数。 反向解析URL 在我们的Django项目中，我们经常会遇到要在视图中返回一个重定向到具体URL的响应，或者要将具体的URL地址嵌入到HTML页面中（如：a标签的href属性等）的情况。 我们之前通常都会选择硬编码（写死）的方式来实现类似上述的需求，但是这并不是最优的解决办法。 例如： 在视图函数中： def add_student(request): if request.method == \"POST\": ... return redirect(\"/student_list/\") # 将URL硬编码到视图中 ... 在模板文件的HTML文件中： 点击查看所有学生信息 Django框架充分考虑了这种需求，所以提供了工具来反向解析（推导）出具体的URL。 name模式 在Django的URLconf中，我们可以通过给匹配模式起别名，然后我们可以通过别名来反向推导出具体的URL。 例如： 在urls.py中： urlpatterns = [ url(r'^student_list/', views.student_list, name=\"students\"), # 为匹配模式起别名 ... ] 在视图中： 通过使用django.urls.reverse根据上面的别名反向推导出URL。 from django.urls import reverse def add_student(request): if request.method == \"POST\": ... # 根据别名反向推导出具体的URL，避免出现硬编码URL的情况。 url = reverse(\"students\") # 得到URL: /student_list/ return redirect(url) ... 在模板语言的HTML文件中，使用下面的语法来反向推导出URL： 点击查看所有学生信息 当我们的匹配模式中的正则表达式有分组或命名分组的时候该怎么办呢？ 也就是我们仅仅通过别名无法推导出具体的URL时，该怎么办呢？ 我们可以在反向推导URL的时候传递URL中需要的参数： URL中需要位置参数 例如： 在urls.py中： urlpatterns = [ # 为匹配模式起别名，并且正则表达式中有分组匹配 url(r'^student/(\\d+)', views.student_detail, name=\"student_detail\"), ... ] 像上面的情况，我们就没法简单的通过别名来推导出具体的URL。 我们在反向推导URL的时候就需要传递参数了。 在视图中： 通过使用django.urls.reverse根据上面的别名反向推导出URL。 from django.urls import reverse def add_student(request): if request.method == \"POST\": ... # 根据别名和位置参数反向推导出具体的URL，避免出现硬编码URL的情况。 url = reverse(\"student_detail\", args=(1,)) # 得到URL:/student/1/ return redirect(url) ... 在模板语言的HTML文件中，使用下面的语法来反向推导出URL： 点击查看学生详细信息 URL中需要关键字参数 例如： 在urls.py中： urlpatterns = [ # 为匹配模式起别名，并且正则表达式中有分组匹配 url(r'^student/(?P\\d+)', views.student_detail, name=\"student_detail\"), ... ] 像上面的情况，我们就没法简单的通过别名来推导出具体的URL。 我们在反向推导URL的时候就需要传递参数了。 在视图中： 通过使用django.urls.reverse根据上面的别名反向推导出URL。 from django.urls import reverse def add_student(request): if request.method == \"POST\": ... # 根据别名和位置参数反向推导出具体的URL，避免出现硬编码URL的情况。 url = reverse(\"student_detail\", kwargs={\"num\": 10}) # 得到URL:/student/10/ return redirect(url) ... 在模板语言的HTML文件中，使用下面的语法来反向推导出URL： 点击查看学生详细信息 namespace模式 我们可以为每个URL的匹配模式设置一个别名，然后通过别名来反向推导出URL。这样的设置在小型项目也就是URL比较少的情况下是完全够用的。 但是一旦我们的项目比较庞大，其URL可能成百上千，不可避免的会出现别名重复的情况。 这个时候就需要使用namespace了，我们可以为不同的urlpatterns设置一个namespace（命名空间），这样在不同的命名空间下即使别名相同，还是可以通过namespace来区分不同的URL匹配模式。 在urls.py中： urlpatterns = [ ... # 为app01.urls设置命名空间名：beijing url(r'^beijing/', include(\"app01.urls\", namespace=\"beijing\")), # 为app02.urls设置命名空间名：shanghai url(r'^shanghai/', include(\"app02.urls\", namespace=\"shanghai\")), ... ] app01/urls.py urlpatterns = [ # app01/urls.py中有一个别名为index的匹配模式 url(r'^index/$', views.index, name=\"index\"), ] app02/urls.py urlpatterns = [ # app02/urls.py中也有一个别名为index的匹配模式 url(r'^index/$', views.index, name=\"index\"), ] 现在我们就可以通过namespace来区分上面两个别名为index的匹配模式来反向推导出准确的URL了。 在视图中： def index(request): # 通过 namespce:name 的方式来反向推导出准确的URL url = reverse(\"shanghai:index\") ... 在模板语言的HTML中： 上海分公司首页 也可以通过在app/urls.py中定义app_name来设置app级别的namespace。 例如： 在上面示例的app01/urls.py文件中： app_name = \"beijing\" urlpatterns = [ url(r'^index/$', views.index, name=\"index\"), ... ] 在这种情况下反向推导URL的语法同上。 "},"python/Django/10.ORM相关操作.html":{"url":"python/Django/10.ORM相关操作.html","title":"ORM相关操作","keywords":"","body":"Django ORM相关操作 一般操作 官网地址 ORM必知必会13条 all(): 查询所有结果 filter(**kwargs): 它包含了与所给筛选条件相匹配的对象 get(**kwargs): 返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误。 exclude(**kwargs): 它包含了与所给筛选条件不匹配的对象 values(*field): 返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列model的实例化对象，而是一个可迭代的字典序列 values_list(*field): 它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列 order_by(*field): 对查询结果排序 reverse(): 对查询结果反向排序，请注意reverse()通常只能在具有已定义顺序的QuerySet上调用(在model类的Meta中指定ordering或调用order_by()方法)。 distinct(): 从返回结果中剔除重复纪录(如果你查询跨越多个表，可能在计算QuerySet时得到重复的结果。此时可以使用distinct()，注意只有在PostgreSQL中支持按字段去重。) count(): 返回数据库中匹配查询(QuerySet)的对象数量。 first(): 返回第一条记录 last(): 返回最后一条记录 exists(): 如果QuerySet包含数据，就返回True，否则返回False 返回QuerySet对象的方法有 all() filter() exelude() order_by() reverse() distinct() 特殊的QuerySet values() 返回一个可迭代的字典序列 values_list() 返回一个可迭代的元祖序列 返回具体对象的 get() first() last() 返回布尔值的方法有： exists() 返回数字的方法有 count() 单表查询之神奇的双下划线 models.Tb1.objects.filter(idlt=10, idgt=1) # 获取id大于1 且 小于10的值 models.Tb1.objects.filter(id__in=[11, 22, 33]) # 获取id等于11、22、33的数据 models.Tb1.objects.exclude(id__in=[11, 22, 33]) # not in models.Tb1.objects.filter(name__contains=\"ven\") # 获取name字段包含\"ven\"的 models.Tb1.objects.filter(name__icontains=\"ven\") # icontains大小写不敏感 models.Tb1.objects.filter(id__range=[1, 3]) # id范围是1到3的，等价于SQL的bettwen and 类似的还有：startswith，istartswith, endswith, iendswith　 date字段还可以： models.Class.objects.filter(first_day__year=2017) ForeignKey操作 正向查找 对象查找（跨表） 语法： 对象.关联字段.字段 示例： book_obj = models.Book.objects.first() # 第一本书对象 print(book_obj.publisher) # 得到这本书关联的出版社对象 print(book_obj.publisher.name) # 得到出版社对象的名称 字段查找（跨表） 语法： 关联字段__字段 示例： print(models.Book.objects.values_list(\"publisher__name\") ) 反向操作 对象查找 语法： obj.表名_set 示例： publisher_obj = models.Publisher.objects.first() # 找到第一个出版社对象 books = publisher_obj.book_set.all() # 找到第一个出版社出版的所有书 titles = books.values_list(\"title\") # 找到第一个出版社出版的所有书的书名 字段查找 语法： 表名__字段 示例： titles = models.Publisher.objects.values_list(\"book__title\") ManyToManyField class RelatedManager \"关联管理器\"是在一对多或者多对多的关联上下文中使用的管理器。 它存在于下面两种情况： 外键关系的反向查询 多对多关联关系 简单来说就是当 点后面的对象 可能存在多个的时候就可以使用以下的方法。 方法 create() 创建一个新的对象，保存对象，并将它添加到关联对象集之中，返回新创建的对象。 import datetime models.Author.objects.first().book_set.create(title=\"番茄物语\", publish_date=datetime.date.today()) add() 把指定的model对象添加到关联对象集中。 添加对象 author_objs = models.Author.objects.filter(id__lt=3) models.Book.objects.first().authors.add(*author_objs) 添加id models.Book.objects.first().authors.add(*[1, 2]) set() 更新model对象的关联对象。 book_obj = models.Book.objects.first() book_obj.authors.set([2, 3]) remove() 从关联对象集中移除执行的model对象 book_obj = models.Book.objects.first() book_obj.authors.remove(3) clear() 从关联对象集中移除一切对象。 book_obj = models.Book.objects.first() book_obj.authors.clear() 注意： 对于ForeignKey对象，clear()和remove()方法仅在null=True时存在。 举个例子： ForeignKey字段没设置null=True时， class Book(models.Model): title = models.CharField(max_length=32) publisher = models.ForeignKey(to=Publisher) 没有clear()和remove()方法： >>> models.Publisher.objects.first().book_set.clear() Traceback (most recent call last): File \"\", line 1, in AttributeError: 'RelatedManager' object has no attribute 'clear' 当ForeignKey字段设置null=True时， class Book(models.Model): name = models.CharField(max_length=32) publisher = models.ForeignKey(to=Class, null=True) ` 此时就有clear()和remove()方法： >>> models.Publisher.objects.first().book_set.clear() 注意： 对于所有类型的关联字段，add()、create()、remove()和clear(),set()都会马上更新数据库。换句话说，在关联的任何一端，都不需要再调用save()方法。 聚合查询和分组查询 聚合 aggregate()是QuerySet 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。 键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。 示例： >>> models.Book.objects.all().aggregate(Avg(\"price\")) {'price__avg': 13.233333} 如果你想要为聚合值指定一个名称，可以向聚合子句提供它。 >>> models.Book.objects.aggregate(average_price=Avg('price')) {'average_price': 13.233333} 如果你希望生成不止一个聚合，你可以向aggregate()子句中添加另一个参数。所以，如果你也想知道所有图书价格的最大值和最小值，可以这样查询： >>> models.Book.objects.all().aggregate(Avg(\"price\"), Max(\"price\"), Min(\"price\")) {'price__avg': 13.233333, 'price__max': Decimal('19.90'), 'price__min': Decimal('9.90')} 分组 为调用的QuerySet中每一个对象都生成一个独立的统计值。 示例1：统计每一本书的作者个数 >>> book_list = models.Book.objects.all().annotate(author_num=Count(\"author\")) >>> for obj in book_list: ... print(obj.author_num) ... 2 1 1 示例2：统计出每个出版社买的最便宜的书的价格 >>> publisher_list = models.Publisher.objects.annotate(min_price=Min(\"book__price\")) >>> for obj in publisher_list: ... print(obj.min_price) ... 9.90 19.90 方法二： >>> models.Book.objects.values(\"publisher__name\").annotate(min_price=Min(\"price\")) 示例3：统计不止一个作者的图书 >>> models.Book.objects.annotate(author_num=Count(\"author\")).filter(author_num__gt=1) ]> 示例4：根据一本图书作者数量的多少对查询集 QuerySet进行排序 >>> models.Book.objects.annotate(author_num=Count(\"author\")).order_by(\"author_num\") , , ]> 示例5：查询各个作者出的书的总价格 >>> models.Author.objects.annotate(sum_price=Sum(\"book__price\")).values(\"name\", \"sum_price\") F查询和Q查询 F查询 在上面所有的例子中，我们构造的过滤器都只是将字段值与某个常量做比较。如果我们要对两个字段的值做比较，那该怎么做呢？ Django 提供 F() 来做这样的比较。F() 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。 示例1： 查询评论数大于收藏数的书籍 from django.db.models import F models.Book.objects.filter(commnet_num__lt=F('keep_num')) Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取模的操作。 models.Book.objects.filter(commnet_num__lt=F('keep_num')*2) 修改操作也可以使用F函数,比如将每一本书的价格提高30元 models.Book.objects.all().update(price=F(\"price\")+30) 引申： 如果要修改char字段咋办？ 如：把所有书名后面加上(第一版) >>> from django.db.models.functions import Concat >>> from django.db.models import Value >>> models.Book.objects.all().update(title=Concat(F(\"title\"), Value(\"(\"), Value(\"第一版\"), Value(\")\"))) Q查询 filter() 等方法中的关键字参数查询都是一起进行“AND” 的。 如果你需要执行更复杂的查询（例如OR语句），你可以使用Q对象。 示例1： 查询作者名是小仙女或小魔女的 models.Book.objects.filter(Q(authors__name=\"小仙女\")|Q(authors__name=\"小魔女\")) 你可以组合& 和| 操作符以及使用括号进行分组来编写任意复杂的Q 对象。同时，Q 对象可以使用~ 操作符取反，这允许组合正常的查询和取反(NOT) 查询。 示例：查询作者名字是小仙女并且不是2018年出版的书的书名。 >>> models.Book.objects.filter(Q(author__name=\"小仙女\") & ~Q(publish_date__year=2018)).values_list(\"title\") 查询函数可以混合使用Q 对象和关键字参数。所有提供给查询函数的参数（关键字参数或Q 对象）都将\"AND”在一起。但是，如果出现Q 对象，它必须位于所有关键字参数的前面。 例如：查询出版年份是2017或2018，书名中带物语的所有书。 >>> models.Book.objects.filter(Q(publish_date__year=2018) | Q(publish_date__year=2017), title__contains=\"物语\") , , ]> 事务 导入 from django.db import transaction 使用 with transaction.atomic(): 代码块包裹代码 import os if __name__ == '__main__': os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"BMS.settings\") import django django.setup() import datetime from app01 import models try: from django.db import transaction with transaction.atomic(): new_publisher = models.Publisher.objects.create(name=\"火星出版社\") models.Book.objects.create(title=\"橘子物语\", publish_date=datetime.date.today(), publisher_id=10) # 指定一个不存在的出版社id except Exception as e: print(str(e)) Django ORM执行原生SQL 使用extra写入原生SQL语句 # extra # 在QuerySet的基础上继续执行子语句 # extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None) # select和select_params是一组，where和params是一组，tables用来设置from哪个表 # Entry.objects.extra(select={'new_id': \"select col from sometable where othercol > %s\"}, select_params=(1,)) # Entry.objects.extra(where=['headline=%s'], params=['Lennon']) # Entry.objects.extra(where=[\"foo='a' OR bar = 'a'\", \"baz = 'a'\"]) # Entry.objects.extra(select={'new_id': \"select id from tb where id > %s\"}, select_params=(1,), order_by=['-nid']) 举个例子： models.UserInfo.objects.extra( select={'newid':'select count(1) from app01_usertype where id>%s'}, select_params=[1,], where = ['age>%s'], params=[18,], order_by=['-age'], tables=['app01_usertype'] ) \"\"\" select app01_userinfo.id, (select count(1) from app01_usertype where id>1) as newid from app01_userinfo,app01_usertype where app01_userinfo.age > 18 order by app01_userinfo.age desc \"\"\" # 执行原生SQL # 更高灵活度的方式执行原生SQL语句 # from django.db import connection, connections # cursor = connection.cursor() # cursor = connections['default'].cursor() # cursor.execute(\"\"\"SELECT * from auth_user where id = %s\"\"\", [1]) # row = cursor.fetchone() QuerySet方法大全 ################################################################## # PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET # ################################################################## def all(self) # 获取所有的数据对象 def filter(self, *args, **kwargs) # 条件查询 # 条件可以是：参数，字典，Q def exclude(self, *args, **kwargs) # 条件查询 # 条件可以是：参数，字典，Q def select_related(self, *fields) 性`能` 机关：表之间进行join连表操作，一次性获取关联的数据。 `总结： 1. select_related主要针一对一和多对一关系进行优化。 2. select_related使用SQL的JOIN语句进行优化，通过减少SQL查询的次数来进行优化、提高性能。` def prefetch_related(self, *lookups) `性能相关：多表连表操作时速度会慢，使用其执行多次SQL查询在Python代码中实现连表操作。` `总结： 1. 对于多对多字段（ManyToManyField）和一对多字段，可以使用prefetch_related()来进行优化。 2. prefetch_related()的优化方式是分别查询每个表，然后用Python处理他们之间的关系。 def annotate(self, *args, **kwargs) # 用于实现聚合group by查询 from django.db.models import Count, Avg, Max, Min, Sum v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id')) # SELECT u_id, COUNT(ui) AS `uid` FROM UserInfo GROUP BY u_id v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id')).filter(uid__gt=1) # SELECT u_id, COUNT(ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1 v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id',distinct=True)).filter(uid__gt=1) # SELECT u_id, COUNT( DISTINCT ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1 def distinct(self, *field_names) # 用于distinct去重 models.UserInfo.objects.values('nid').distinct() # select distinct nid from userinfo 注：只有在PostgreSQL中才能使用distinct进行去重 def order_by(self, *field_names) # 用于排序 models.UserInfo.objects.all().order_by('-id','age') def extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None) # 构造额外的查询条件或者映射，如：子查询 Entry.objects.extra(select={'new_id': \"select col from sometable where othercol > %s\"}, select_params=(1,)) Entry.objects.extra(where=['headline=%s'], params=['Lennon']) Entry.objects.extra(where=[\"foo='a' OR bar = 'a'\", \"baz = 'a'\"]) Entry.objects.extra(select={'new_id': \"select id from tb where id > %s\"}, select_params=(1,), order_by=['-nid']) def reverse(self): # 倒序 models.UserInfo.objects.all().order_by('-nid').reverse() # 注：如果存在order_by，reverse则是倒序，如果多个排序则一一倒序 def defer(self, *fields): models.UserInfo.objects.defer('username','id') 或 models.UserInfo.objects.filter(...).defer('username','id') #映射中排除某列数据 def only(self, *fields): #仅取某个表中的数据 models.UserInfo.objects.only('username','id') 或 models.UserInfo.objects.filter(...).only('username','id') def using(self, alias): 指定使用的数据库，参数为别名（setting中的设置） ################################################## # PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS # ################################################## def raw(self, raw_query, params=None, translations=None, using=None): # 执行原生SQL models.UserInfo.objects.raw('select * from userinfo') # 如果SQL是其他表时，必须将名字设置为当前UserInfo对象的主键列名 models.UserInfo.objects.raw('select id as nid from 其他表') # 为原生SQL设置参数 models.UserInfo.objects.raw('select id as nid from userinfo where nid>%s', params=[12,]) # 将获取的到列名转换为指定列名 name_map = {'first': 'first_name', 'last': 'last_name', 'bd': 'birth_date', 'pk': 'id'} Person.objects.raw('SELECT * FROM some_other_table', translations=name_map) # 指定数据库 models.UserInfo.objects.raw('select * from userinfo', using=\"default\") ################### 原生SQL ################### from django.db import connection, connections cursor = connection.cursor() # cursor = connections['default'].cursor() cursor.execute(\"\"\"SELECT * from auth_user where id = %s\"\"\", [1]) row = cursor.fetchone() # fetchall()/fetchmany(..) def values(self, *fields): # 获取每行数据为字典格式 def values_list(self, *fields, **kwargs): # 获取每行数据为元祖 def dates(self, field_name, kind, order='ASC'): # 根据时间进行某一部分进行去重查找并截取指定内容 # kind只能是：\"year\"（年）, \"month\"（年-月）, \"day\"（年-月-日） # order只能是：\"ASC\" \"DESC\" # 并获取转换后的时间 - year : 年-01-01 - month: 年-月-01 - day : 年-月-日 models.DatePlus.objects.dates('ctime','day','DESC') def datetimes(self, field_name, kind, order='ASC', tzinfo=None): # 根据时间进行某一部分进行去重查找并截取指定内容，将时间转换为指定时区时间 # kind只能是 \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\" # order只能是：\"ASC\" \"DESC\" # tzinfo时区对象 models.DDD.objects.datetimes('ctime','hour',tzinfo=pytz.UTC) models.DDD.objects.datetimes('ctime','hour',tzinfo=pytz.timezone('Asia/Shanghai')) \"\"\" pip3 install pytz import pytz pytz.all_timezones pytz.timezone(‘Asia/Shanghai’) \"\"\" def none(self): # 空QuerySet对象 #################################### # METHODS THAT DO DATABASE QUERIES # #################################### def aggregate(self, *args, **kwargs): # 聚合函数，获取字典类型聚合结果 from django.db.models import Count, Avg, Max, Min, Sum result = models.UserInfo.objects.aggregate(k=Count('u_id', distinct=True), n=Count('nid')) ===> {'k': 3, 'n': 4} def count(self): # 获取个数 def get(self, *args, **kwargs): # 获取单个对象 def create(self, **kwargs): # 创建对象 def bulk_create(self, objs, batch_size=None): # 批量插入 # batch_size表示一次插入的个数 objs = [ models.DDD(name='r11'), models.DDD(name='r22') ] models.DDD.objects.bulk_create(objs, 10) def get_or_create(self, defaults=None, **kwargs): # 如果存在，则获取，否则，创建 # defaults 指定创建时，其他字段的值 obj, created = models.UserInfo.objects.get_or_create(username='root1', defaults={'email': '1111111','u_id': 2, 't_id': 2}) def update_or_create(self, defaults=None, **kwargs): # 如果存在，则更新，否则，创建 # defaults 指定创建时或更新时的其他字段 obj, created = models.UserInfo.objects.update_or_create(username='root1', defaults={'email': '1111111','u_id': 2, 't_id': 1}) def first(self): # 获取第一个 def last(self): # 获取最后一个 def in_bulk(self, id_list=None): # 根据主键ID进行查找 id_list = [11,21,31] models.DDD.objects.in_bulk(id_list) def delete(self): # 删除 def update(self, **kwargs): # 更新 def exists(self): # 是否有结果 Django终端打印SQL语句 在Django项目的settings.py文件中，在最后复制粘贴如下代码： LOGGING = { 'version': 1, 'disable_existing_loggers': False, 'handlers': { 'console':{ 'level':'DEBUG', 'class':'logging.StreamHandler', }, }, 'loggers': { 'django.db.backends': { 'handlers': ['console'], 'propagate': True, 'level':'DEBUG', }, } } 即为你的Django项目配置上一个名为django.db.backends的logger实例即可查看翻译后的SQL语句。 在Python脚本中调用Django环境 import os if __name__ == '__main__': os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"BMS.settings\") import django django.setup() from app01 import models books = models.Book.objects.all() print(books) "},"python/Django/111.ORM版学员管理系统.html":{"url":"python/Django/111.ORM版学员管理系统.html","title":"ORM版学员管理系统","keywords":"","body":"ORM版学员管理系统 班级表 表结构 class Class(models.Model): id = models.AutoField(primary_key=True) # 主键 cname = models.CharField(max_length=32) # 班级名称 first_day = models.DateField() # 开班时间 查询班级 URL部分： url(r'^class_list/$', views.class_list, name=\"class_list\"), 视图部分： def class_list(request): class_list = models.Class.objects.all() return render(request, \"class_list.html\", {\"class_list\": class_list}) HTML部分： {% for class in class_list %} {{ forloop.counter }} {{ class.id }} {{ class.cname }} {{ class.first_day|date:'Y-m-d' }} {% endfor %} 新增班级 URL部分： url(r'^add_class/$', views.add_class, name=\"add_class\"), 视图部分： def add_class(request): # 前端POST填好的新班级信息 if request.method == \"POST\": cname = request.POST.get(\"cname\") first_day = request.POST.get(\"first_day\") # 还可以这么获取提交的数据，但不推荐这么写 # data = request.POST.dict() # del data[\"csrfmiddlewaretoken\"] # 创建新数据的两种方式 # new_class = models.Class(cname=cname, first_day=first_day) # new_class.save() models.Class.objects.create(cname=cname, first_day=first_day) # 跳转到class_list return redirect(reverse('class_list')) # 返回添加班级的页面 return render(request, \"add_class.html\") HTML部分： 在班级列表页面添加一个a标签： 新页面添加 新添加页面： 注意 {% csrf_token %} 和 date类型的input标签。 添加班级 {% csrf_token %} 班级名称： 开班日期： 提交 删除班级 URL部分： url(r'^delete_class/$', views.delete_class, name=\"delete_class\"), 视图部分： def delete_class(request): class_id = request.GET.get(\"class_id\") models.Class.objects.filter(id=class_id).delete() return redirect(reverse(\"class_list\")) HTML部分： 在班级列表页面的表格中添加删除。 删除 编辑班级 URL部分： url(r'^edit_class/$', views.edit_class, name=\"edit_class\"), 视图部分： def edit_class(request): if request.method == \"POST\": class_id = request.POST.get(\"id\") cname = request.POST.get(\"cname\") first_day = request.POST.get(\"first_day\") models.Class.objects.create(id=class_id, cname=cname, first_day=first_day) return redirect(reverse(\"class_list\")) class_id = request.GET.get(\"class_id\") class_obj = models.Class.objects.filter(id=class_id) if class_obj: class_obj = class_obj[0] return render(request, \"edit_class.html\", {\"class\": class_obj}) # 找不到该条记录 else: return redirect(reverse(\"class_list\")) HTML部分： 编辑班级 {% csrf_token %} 班级名称： 开班日期： 提交 补充 如果将之前的URL由 /edit_class/?class_id=n修改为 /edit_class/n/ ，视图函数和HTML部分分别应该如何修改？ URL部分： url(r'^edit_class/(\\d+)$', views.edit_class, name=\"edit_class\"), 视图部分： def edit_class(request, class_id): if request.method == \"POST\": cname = request.POST.get(\"cname\") first_day = request.POST.get(\"first_day\") models.Class.objects.create(id=class_id, cname=cname, first_day=first_day) return redirect(reverse(\"class_list\")) class_obj = models.Class.objects.filter(id=class_id) if class_obj: class_obj = class_obj[0] return render(request, \"edit_class.html\", {\"class\": class_obj}) # 找不到该条记录 else: print(\"没有该班级\") return redirect(reverse(\"class_list\")) HTML部分： 编辑班级 {% csrf_token %} 班级名称： 开班日期： 提交 单表查询API汇总 all(): 查询所有结果 filter(**kwargs): 它包含了与所给筛选条件相匹配的对象 get(**kwargs): 返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误。 exclude(**kwargs): 它包含了与所给筛选条件不匹配的对象 values(*field): 返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列model的实例化对象，而是一个可迭代的字典序列 values_list(*field): 它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列 order_by(*field): 对查询结果排序 reverse(): 对查询结果反向排序 distinct(): 从返回结果中剔除重复纪录 count(): 返回数据库中匹配查询(QuerySet)的对象数量。 first(): 返回第一条记录 last(): 返回最后一条记录 exists(): 如果QuerySet包含数据，就返回True，否则返回False 注意：一定区分Object与QuerySet的区别 ！！！ QuerySet有update方法而Object默认没有。 单表查询之神奇的双下划线 models.Tb1.objects.filter(id__lt=10, id__gt=1) # 获取id大于1 且 小于10的值 models.Tb1.objects.filter(id__in=[11, 22, 33]) # 获取id等于11、22、33的数据 models.Tb1.objects.exclude(id__in=[11, 22, 33]) # not in models.Tb1.objects.filter(name__contains=\"ven\") # 获取name字段包含\"ven\"的 models.Tb1.objects.filter(name__icontains=\"ven\") # icontains大小写不敏感 models.Tb1.objects.filter(id__range=[1, 3]) # id范围是1到3的，等价于SQL的bettwen and 类似的还有：startswith，istartswith, endswith, iendswith　 date字段还可以： models.Class.objects.filter(first_day__year=2017) 备注： 在Django的日志设置中，配置上一个名为django.db.backends的logger实例即可查看翻译后的SQL语句。 LOGGING = { 'version': 1, 'disable_existing_loggers': False, 'handlers': { 'console':{ 'level':'DEBUG', 'class':'logging.StreamHandler', }, }, 'loggers': { 'django.db.backends': { 'handlers': ['console'], 'propagate': True, 'level':'DEBUG', }, } } Django项目完整版LOGGING配置： LOGGING = { 'version': 1, 'disable_existing_loggers': False, 'formatters': { 'standard': { 'format': '[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]' '[%(levelname)s][%(message)s]' }, 'simple': { 'format': '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s' }, 'collect': { 'format': '%(message)s' } }, 'filters': { 'require_debug_true': { '()': 'django.utils.log.RequireDebugTrue', }, }, 'handlers': { 'console': { 'level': 'DEBUG', 'filters': ['require_debug_true'], # 只有在Django debug为True时才在屏幕打印日志 'class': 'logging.StreamHandler', 'formatter': 'simple' }, 'default': { 'level': 'INFO', 'class': 'logging.handlers.RotatingFileHandler', # 保存到文件，自动切 'filename': os.path.join(BASE_LOG_DIR, \"xxx_info.log\"), # 日志文件 'maxBytes': 1024 * 1024 * 50, # 日志大小 50M 'backupCount': 3, 'formatter': 'standard', 'encoding': 'utf-8', }, 'error': { 'level': 'ERROR', 'class': 'logging.handlers.RotatingFileHandler', # 保存到文件，自动切 'filename': os.path.join(BASE_LOG_DIR, \"xxx_err.log\"), # 日志文件 'maxBytes': 1024 * 1024 * 50, # 日志大小 50M 'backupCount': 5, 'formatter': 'standard', 'encoding': 'utf-8', }, 'collect': { 'level': 'INFO', 'class': 'logging.handlers.RotatingFileHandler', # 保存到文件，自动切 'filename': os.path.join(BASE_LOG_DIR, \"xxx_collect.log\"), 'maxBytes': 1024 * 1024 * 50, # 日志大小 50M 'backupCount': 5, 'formatter': 'collect', 'encoding': \"utf-8\" } }, 'loggers': { # 默认的logger应用如下配置 '': { 'handlers': ['default', 'console', 'error'], # 上线之后可以把'console'移除 'level': 'DEBUG', 'propagate': True, }, # 名为 'collect'的logger还单独处理 'collect': { 'handlers': ['console', 'collect'], 'level': 'INFO', } }, } "},"python/Django/11.Form组件.html":{"url":"python/Django/11.Form组件.html","title":"Form组件","keywords":"","body":"Django之Form表单 Form介绍 我们之前在HTML页面中利用form表单向后端提交数据时，都会写一些获取用户输入的标签并且用form标签把它们包起来。 与此同时我们在好多场景下都需要对用户的输入做校验，比如校验用户是否输入，输入的长度和格式等正不正确。如果用户输入的内容有错误就需要在页面上相应的位置显示显示对应的错误信息.。 Django form组件就实现了上面所述的功能。 总结一下，其实form组件的主要功能如下: 生成页面可用的HTML标签 对用户提交的数据进行校验 保留上次输入内容 普通的登录 views.py def login(request): error_msg = \"\" if request.method == \"POST\": username = request.POST.get(\"username\") pwd = request.POST.get(\"pwd\") if username == \"Q1mi\" and pwd == \"123456\": return HttpResponse(\"OK\") else: error_msg = \"用户名或密码错误\" return render(request, \"login.html\", {\"error_msg\": error_msg}) login.html login .error { color: red; } { % csrf_token % } 用户名 密码 { { error_msg } } ` 使用form组件 views.py 先定义好一个LoginForm类。 class LoginForm(forms.Form): username = forms.CharField(min_length=8, label=\"用户名\") pwd = forms.CharField(min_length=6, label=\"密码\") def login2(request): error_msg = \"\" form_obj = LoginForm() if request.method == \"POST\": form_obj = LoginForm(request.POST) if form_obj.is_valid(): username = form_obj.cleaned_data.get(\"username\") pwd = form_obj.cleaned_data.get(\"pwd\") if username == \"Q1mi\" and pwd == \"123456\": return HttpResponse(\"OK\") else: error_msg = \"用户名或密码错误\" return render(request, \"login2.html\", {\"form_obj\": form_obj, \"error_msg\": error_msg}) login2.html login .error { color: red; } { % csrf_token % } { { form_obj.username.label } } { { form_obj.username } } { { form_obj.username.errors.0 } } { { form_obj.pwd.label } } { { form_obj.pwd } } { { form_obj.pwd.errors.0 } } { { error_msg } } 看网页效果发现 也验证了form的功能： • 前端页面是form类的对象生成的 -->生成HTML标签功能 • 当用户名和密码输入为空或输错之后 页面都会提示 -->用户提交校验功能 • 当用户输错之后 再次输入 上次的内容还保留在input框 -->保留上次输入内容 Form那些事儿 常用字段演示 initial 初始值，input框里面的初始值。 class LoginForm(forms.Form): username = forms.CharField( min_length=8, label=\"用户名\", initial=\"张三\" # 设置默认值 ) pwd = forms.CharField(min_length=6, label=\"密码\") error_messages 重写错误信息。 class LoginForm(forms.Form): username = forms.CharField( min_length=8, label=\"用户名\", initial=\"张三\", error_messages={ \"required\": \"不能为空\", \"invalid\": \"格式错误\", \"min_length\": \"用户名最短8位\" } ) pwd = forms.CharField(min_length=6, label=\"密码\") password class LoginForm(forms.Form): ... pwd = forms.CharField( min_length=6, label=\"密码\", widget=forms.widgets.PasswordInput(attrs={'class': 'c1'}, render_value=True) ) radioSelect 单radio值为字符串 class LoginForm(forms.Form): username = forms.CharField( min_length=8, label=\"用户名\", initial=\"张三\", error_messages={ \"required\": \"不能为空\", \"invalid\": \"格式错误\", \"min_length\": \"用户名最短8位\" } ) pwd = forms.CharField(min_length=6, label=\"密码\") gender = forms.fields.ChoiceField( choices=((1, \"男\"), (2, \"女\"), (3, \"保密\")), label=\"性别\", initial=3, widget=forms.widgets.RadioSelect ) 单选Select class LoginForm(forms.Form): ... hobby = forms.fields.ChoiceField( choices=((1, \"篮球\"), (2, \"足球\"), (3, \"双色球\"), ), label=\"爱好\", initial=3, widget=forms.widgets.Select ) 多选Select class LoginForm(forms.Form): ... hobby = forms.fields.MultipleChoiceField( choices=((1, \"篮球\"), (2, \"足球\"), (3, \"双色球\"), ), label=\"爱好\", initial=[1, 3], widget=forms.widgets.SelectMultiple ) 单选checkbox class LoginForm(forms.Form): ... keep = forms.fields.ChoiceField( label=\"是否记住密码\", initial=\"checked\", widget=forms.widgets.CheckboxInput ) 多选checkbox class LoginForm(forms.Form): ... hobby = forms.fields.MultipleChoiceField( choices=((1, \"篮球\"), (2, \"足球\"), (3, \"双色球\"),), label=\"爱好\", initial=[1, 3], widget=forms.widgets.CheckboxSelectMultiple ) 关于choice的注意事项： 在使用选择标签时，需要注意choices的选项可以从数据库中获取，但是由于是静态字段 ***获取的值无法实时更新***，那么需要自定义构造方法从而达到此目的。 方式一： from django.forms import Form from django.forms import widgets from django.forms import fields class MyForm(Form): user = fields.ChoiceField( # choices=((1, '上海'), (2, '北京'),), initial=2, widget=widgets.Select ) def __init__(self, *args, **kwargs): super(MyForm,self).__init__(*args, **kwargs) # self.fields['user'].widget.choices = ((1, '上海'), (2, '北京'),) # 或 self.fields['user'].widget.choices = models.Classes.objects.all().values_list('id','caption') 方式二： from django import forms from django.forms import fields from django.forms import models as form_model class FInfo(forms.Form): authors = form_model.ModelMultipleChoiceField(queryset=models.NNewType.objects.all()) # authors = form_model.ModelChoiceField(queryset=models.NNewType.objects.all()) Django form内置字段 Field required=True, 是否允许为空 widget=None, HTML插件 label=None, 用于生成Label标签或显示内容 initial=None, 初始值 help_text='', 帮助信息(在标签旁边显示) error_messages=None, 错误信息 {'required': '不能为空', 'invalid': '格式错误'} show_hidden_initial=False, 是否在当前插件后面再加一个隐藏的且具有默认值的插件（可用于检验两次输入是否一直） validators=[], 自定义验证规则 localize=False, 是否支持本地化 disabled=False, 是否可以编辑 label_suffix=None Label内容后缀 CharField(Field) max_length=None, 最大长度 min_length=None, 最小长度 strip=True 是否移除用户输入空白 IntegerField(Field) max_value=None, 最大值 min_value=None, 最小值 FloatField(IntegerField) ... DecimalField(IntegerField) max_value=None, 最大值 min_value=None, 最小值 max_digits=None, 总长度 decimal_places=None, 小数位长度 BaseTemporalField(Field) input_formats=None 时间格式化 DateField(BaseTemporalField) 格式：2015-09-01 TimeField(BaseTemporalField) 格式：11:12 DateTimeField(BaseTemporalField)格式：2015-09-01 11:12 DurationField(Field) 时间间隔：%d %H:%M:%S.%f ... RegexField(CharField) regex, 自定制正则表达式 max_length=None, 最大长度 min_length=None, 最小长度 error_message=None, 忽略，错误信息使用 error_messages={'invalid': '...'} EmailField(CharField) ... FileField(Field) allow_empty_file=False 是否允许空文件 ImageField(FileField) ... 注：需要PIL模块，pip3 install Pillow 以上两个字典使用时，需要注意两点： - form表单中 enctype=\"multipart/form-data\" - view函数中 obj = MyForm(request.POST, request.FILES) URLField(Field) ... BooleanField(Field) ... NullBooleanField(BooleanField) ... ChoiceField(Field) ... choices=(), 选项，如：choices = ((0,'上海'),(1,'北京'),) required=True, 是否必填 widget=None, 插件，默认select插件 label=None, Label内容 initial=None, 初始值 help_text='', 帮助提示 ModelChoiceField(ChoiceField) ... django.forms.models.ModelChoiceField queryset, # 查询数据库中的数据 empty_label=\"---------\", # 默认空显示内容 to_field_name=None, # HTML中value的值对应的字段 limit_choices_to=None # ModelForm中对queryset二次筛选 ModelMultipleChoiceField(ModelChoiceField) ... django.forms.models.ModelMultipleChoiceField TypedChoiceField(ChoiceField) coerce = lambda val: val 对选中的值进行一次转换 empty_value= '' 空值的默认值 MultipleChoiceField(ChoiceField) ... TypedMultipleChoiceField(MultipleChoiceField) coerce = lambda val: val 对选中的每一个值进行一次转换 empty_value= '' 空值的默认值 ComboField(Field) fields=() 使用多个验证，如下：即验证最大长度20，又验证邮箱格式 fields.ComboField(fields=[fields.CharField(max_length=20), fields.EmailField(),]) MultiValueField(Field) PS: 抽象类，子类中可以实现聚合多个字典去匹配一个值，要配合MultiWidget使用 SplitDateTimeField(MultiValueField) input_date_formats=None, 格式列表：['%Y--%m--%d', '%m%d/%Y', '%m/%d/%y'] input_time_formats=None 格式列表：['%H:%M:%S', '%H:%M:%S.%f', '%H:%M'] FilePathField(ChoiceField) 文件选项，目录下文件显示在页面中 path, 文件夹路径 match=None, 正则匹配 recursive=False, 递归下面的文件夹 allow_files=True, 允许文件 allow_folders=False, 允许文件夹 required=True, widget=None, label=None, initial=None, help_text='' GenericIPAddressField protocol='both', both,ipv4,ipv6支持的IP格式 unpack_ipv4=False 解析ipv4地址，如果是::ffff:192.0.2.1时候，可解析为192.0.2.1， PS：protocol必须为both才能启用 SlugField(CharField) 数字，字母，下划线，减号（连字符） ... UUIDField(CharField) uuid类型 校验 方式一： from django.forms import Form from django.forms import widgets from django.forms import fields from django.core.validators import RegexValidator class MyForm(Form): user = fields.CharField( validators=[RegexValidator(r'^[0-9]+$', '请输入数字'), RegexValidator(r'^159[0-9]+$', '数字必须以159开头')], ) 方式二： import re from django.forms import Form from django.forms import widgets from django.forms import fields from django.core.exceptions import ValidationError # 自定义验证规则 def mobile_validate(value): mobile_re = re.compile(r'^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$') if not mobile_re.match(value): raise ValidationError('手机号码格式错误') class PublishForm(Form): title = fields.CharField(max_length=20, min_length=5, error_messages={'required': '标题不能为空', 'min_length': '标题最少为5个字符', 'max_length': '标题最多为20个字符'}, widget=widgets.TextInput(attrs={'class': \"form-control\", 'placeholder': '标题5-20个字符'})) # 使用自定义验证规则 phone = fields.CharField(validators=[mobile_validate, ], error_messages={'required': '手机不能为空'}, widget=widgets.TextInput(attrs={'class': \"form-control\", 'placeholder': u'手机号码'})) email = fields.EmailField(required=False, error_messages={'required': u'邮箱不能为空','invalid': u'邮箱格式错误'}, widget=widgets.TextInput(attrs={'class': \"form-control\", 'placeholder': u'邮箱'})) 补充进阶 应用Bootstrap样式 Django form应用Bootstrap样式简单示例 login { % csrf_token % } { { form_obj.username.label } } { { form_obj.username } } { { form_obj.username.errors.0 } } { { form_obj.pwd.label } } { { form_obj.pwd } } { { form_obj.pwd.errors.0 } } { { form_obj.gender.label } } { % for radio in form_obj.gender % } { { radio.tag } }{ { radio.choice_label } } { % endfor % } 注册 批量添加样式 可通过重写form类的init方法来实现。 class LoginForm(forms.Form): username = forms.CharField( min_length=8, label=\"用户名\", initial=\"张三\", error_messages={ \"required\": \"不能为空\", \"invalid\": \"格式错误\", \"min_length\": \"用户名最短8位\" } ... def __init__(self, *args, **kwargs): super(LoginForm, self).__init__(*args, **kwargs) for field in iter(self.fields): self.fields[field].widget.attrs.update({ 'class': 'form-control' }) "},"python/Django/博客项目点赞与灭操作.html":{"url":"python/Django/博客项目点赞与灭操作.html","title":"博客项目点赞与灭操作","keywords":"","body":"点赞与踩灭 功能介绍： 1.当用户在登录状态下点击赞或者灭可以做相应的操作 2.点击赞过会显示\"推荐成功\",点击灭过会显示\"反对成功\" 3.重复操作会相示对应提示\"您已经推荐过\"或\"您已经反对过\" 4.使用Ajax实现 5.服务器端使用到的知识点:事务,ORM添加操作,ORM修改操作（F查询） 执行流程： 客户端遇到的问题： 1.如何点击一个div判断是赞还是灭操作,觖决方法为使用样式判断hasClass方法判断哪个标签中有相对应的样式类,hasClass返回布尔值,将返回值is_up,文章编号article_id,通过Ajax传递给服务器 2.服务器接收到传递的数据,进行处理（其中user.id）可以使用当前登录用户的id值user.pk,取得所有值后向数据库点赞表中添加一条新记录,点赞表使用联合组键如果重复添加会报错,这里可以使用try捕获下异常,同时在文章表中的相关字段也需要更新 3.添加数据,更新数据完成后,将标志位回传给浏览器这个可以根据个人定制,ret={'state':False,'flag':False},其中ret包含两个键值对 state：操作是否成功,True正常操作，False异常操作,flag:操作是否成功,True赞操作，False灭操作 4.浏览器接收到ret后进行判断如果state为真时再对flag进行判断,flag为真则显示点赞成功,否则点灭成功;state为假说明已经有点赞或者灭的操作,再对flag进行判断 5.在urls中添加一个路由 url(r\"^poll/\", views.poll, name=\"poll\"), 代码部分 html代码 {{ article_obj.title }} {{ article_obj.articledetail.content|safe }} { % csr f_ token % } {{ article_obj.up_count }} {{ article_obj.down_count }} JS代码 $(\"#div_digg .digg\").on('click', function () { if (username) { // 查看标签是否存在diggit样式返回bool值 var is_up = $(this).hasClass(\"diggit\"); // is_up判断是点赞还是灭 // article_id是当前文章id $.ajax({ url: poll, type: \"post\", data: { is_up: is_up, article_id: article_id, csrfmiddlewaretoken: $(\"input[name='csrfmiddlewaretoken']\").val() }, success: function (data) { // 添加成功data.state为真 if(data.state) { // 操作为赞操作 if(data.flag){ $(\"#digg_count\").html(parseInt(up_count)+1); $(\"#digg_tips\").text(\"推荐成功\"); // 操作为灭操作 }else{ $(\"#bury_count\").html(parseInt(down_count)+1); $(\"#digg_tips\").text(\"反对成功\"); } // 添加失败data.state为假 }else{ if(data.flag){ $(\"#digg_tips\").text(\"您已经推荐过\"); }else{ $(\"#digg_tips\").text(\"您已经反对过\"); } } } }); } else { // 用户未登录 window.location.href = \"/logIn/\"; } }); 视图views def poll(request): \"\"\" 点赞操作 :param request: :return: \"\"\" # ret两个键值对 # 1.state：操作是否成功,True正常操作，False异常操作 # 2.flag:操作是否成功,True赞操作，False灭操作 ret = {'state': False,'flag':False} is_up = request.POST.get(\"is_up\") # 取出的is_up为布尔值，需要转换 is_up = json.loads(is_up) article_id = request.POST.get(\"article_id\") # 用户ID可以直接取当前用户ID user_id = request.user.pk try: # 添加事务 with transaction.atomic(): # 向点赞表中添加数据， # 如果用户点赞,更新文章表up_count字段 # 如果用户点灭,更新文章表down_count字段 models.ArticleUpDown.objects.create(article_id=article_id, user_id=user_id, is_up=is_up) if is_up: # 返回值为影响的行数 c = models.Article.objects.filter(pk=article_id).update(up_count=F(\"up_count\") + 1) ret['flag'] = True else: c = models.Article.objects.filter(pk=article_id).update(down_count=F(\"down_count\") + 1) ret['state'] = True except Exception as e: print(e) ret['flag'] = models.ArticleUpDown.objects.filter(article_id=article_id, user_id=user_id).first().is_up return JsonResponse(ret) "},"python/Django/博客项目评论.html":{"url":"python/Django/博客项目评论.html","title":"博客项目评论","keywords":"","body":"评论列表与评论树 功能介绍： 主要有两部分：显示评论和评论提交评论 其中显示评论有两种实现render显示与Ajax实现,提交也一样 评论楼 1.评论楼render数据 浏览器render显示取出文章对应的评论,浏览器渲染 2.对楼层的回复标签进行操作 a.在·回复标签·中动态绑定`楼层用户`,`楼层用户ID值` b.为回复按钮绑定事件,首先获得`评论文本框`的焦点, c.在文本框中将`@楼层用户`添加到文本框中, d.将楼层用户ID值赋给全局变量`parent_id` 3.提交按钮绑定事件 成功添加信息后对提交按钮绑定事件,使用Ajax向服务器传值,需要传递的值有楼层parent_id-楼层ID，content-评论内容,article_id-文章ID 判断content是否为空 判断parent_id是否为空,如果为空直接传content,不为空先将@用户名过滤后再进行传值 通过Ajaxu将数据传到服务器，先对parent_id进行判断，如果不为空在评论表中添加一条数据，同时更新文章表数据；parent_id为空同样添加，但此时这条评论为根评论 添加数据完成后，返回序列化字典(JsonResponse)，ret = {'state':False}其中state是表示添加数据是否发生异常 在Ajax中处理服务器传回的数据，state为真添成功,成功后的操作可以刷新页面(render)或者评论楼下动态添加一条记录(Ajax) render实现很容易不在复述；Ajax实现需要的楼层可以根据需要定制，如果需要访问时间(成功添加数据完成后返回值为添加数据对像，取出时间放入字典)，楼层数(在渡浏览器获得即可)，回复用户(当前登录用户)，内容(服务器返回数据)等，需要注意的是如果传回的数据类型是JSON时需要进行转换(d.条中的字典可以按需要添加) Ajax实现评论楼时数据构建时需要拼接字符串,可以使用ECMAScript 6.0（以下简称 ES6）实现,然后清空评论文本框内容，清空全局变量parent_id 评论树 加载相关文章数,据使用Ajax 使用JS对文章数据进行处理,对父ID进行判断，如果有父ID将数据添加到对应的标签下，没有父ID作为根评论显示到页面上 添加新评论会有几个BUG: 1.点击回复提交后,不刷新页面再次提交一条评论 第一条BUG的解决方案为提交评论后清空`pid` 2.点击回复手动删除@对象再手写入新的评论人 第二条的这个需要匹配回复这篇文章的评论的用户,是否在回复表中 涉及知识点 Ajax的知识运用的很多,$.each(),.indexOf(\"\"),slice(),append(),.attr(),function()(),ECMAScript 6.0 ECMAScript 6.0的简单使用 示例代码 html代码 评论列表 { % if comment_list % } 评论列表 { % for comment in comment_list % } #{ { forloop.counter } }楼&nbsp;&nbsp; { { comment.create_time|date:\"Y-m-d H:i\" } }&nbsp;&nbsp; { { comment.user.username } } { % if comment.user.pk != request.user.pk % } 回复 { % else % } 修改&nbsp;&nbsp; 删除 { % endif % } { % if comment.parent_comment_id % } @{ { comment.parent_comment.user.username } } { % endif % } { { comment } } { % endfor % } { % endif % } 评论树 评论树 JS代码 评论楼 $(function () { $('[data-toggle=\"popover\"]').popover(); $('[data-toggle=\"tooltip\"]').tooltip(); {# 定义局部变量parent_id#} var parent_id = \"\"; {# 为提交事件绑定单击事件#} $(\".comment_btn\").click(function () { var $content = $(\"#tbCommentBody\"); var article_id = \"\"; {# var parent_id = \"\";#} var content = \"\"; var csrfmiddlewaretoken = $(\"input[name='csrfmiddlewaretoken']\").val(); if (!$content.val()) { alert(\"评论内容不能为空\"); return false; } if (parent_id) { var index = $content.val().indexOf(\"\\n\"); content = $content.val().slice(index + 1); } else { content = $content.val(); } $.ajax({ url: '/blog/comment/', type: 'post', data: { article_id: article_id, parent_id: parent_id, content: content, csrfmiddlewaretoken: csrfmiddlewaretoken }, success: function (data) { console.log(data); if (data.state) { uname = \"\"; comment_new_html = ` ${uname} 刷新页面sdsdfsdsdf `; $commentlist = $(\".comment-list\"); $commentlist.append(comment_new_html); $content.val(\"\"); parent_id = \"\"; } else { console.log('失败') } } }) }); {# 为回复链接绑定事件#} $(\".comment-reply\").click(function () { var $content = $(\"#tbCommentBody\"); $content.focus(); var val = $(this).attr(\"username\"); $content.val(\"@\" + val + \"\\n\"); parent_id = $(this).attr(\"pk\"); }); }); 评论树 (function () { $.ajax({ url: '/blog/comment-list/' + $(\"#info\").attr(\"article_id\"), success: function (com_list) { $.each(com_list, function (key, value) { var pid = value.parent_comment_id; var id = value.id; var content = value.content; var uname = value.user__username; floor = document.createElement(\"div\"); $floor = $(floor); $floor.attr(\"class\", \"comment_item_tree\"); $floor.attr(\"id\", id); $floor.text(id + \"---\" + content); comment_new_html = ` ${uname} ${content} `; // console.log(floor); // console.log(comment_new_html); // 如果父评论存在,找到父评论 if (pid) { // $(\"#\" + pid).append($floor); console.log('pid',$(\"#\" + pid)); $(\"#\" + pid).append(comment_new_html); } else { // $(\".comment_tree\").append($floor); $(\".comment_tree\").append(comment_new_html); } }) } }); })(); 视图viesw 评论列表 def comment(request): \"\"\" 评论 :param request: :return: \"\"\" print(request.POST) ret = {'state':False} article_id = request.POST.get('article_id') pid = request.POST.get('parent_id') content = request.POST.get('content') uid = request.user.pk try: with transaction.atomic(): if pid: models.Comment.objects.create(article_id=article_id,content=content,user_id=uid,parent_comment_id=pid) else: models.Comment.objects.create(article_id=article_id,content=content,user_id=uid) models.Article.objects.filter(pk=article_id).update(comment_count=F(\"comment_count\")+1) ret['state'] = True except Exception as e: print(e) return JsonResponse(ret) 评论树 def comment_list(request,article_id): \"\"\" 获取当前文章的评论 :param request: :param article_id: :return: \"\"\" com_list = list(models.Comment.objects.filter(article_id=article_id).values(\"id\", \"parent_comment_id\", \"content\", \"user__username\")) print(com_list) return JsonResponse(com_list,safe=False) "},"python/lufei-payment/luffy结算中心.html":{"url":"python/lufei-payment/luffy结算中心.html","title":"luffy结算中心","keywords":"","body":"路飞支付结算中心简单介绍： 结算中心 添加购物车信息到redis 1 获取用户要结算课程ID 1.1 检测用户要结算的课程是否已经加入购物车 1.2 如果不存在提示需要先加入购物车，才能结算 1.3 获取标题、图片、默认优惠卷ID、价格策略ID、优惠卷字典这个先设置为空，后面处理 1.4 将以上信息存入到字典中，以传入的课程ID为键---值为上面收集的信息 2 获取优惠卷 2.1 查询出在当前时间段时符合条件的优惠卷记录 2.2 遍历优惠卷，先处理没有绑定课程的优惠卷， 2.3 获得优惠卷类型：满减，立减，折扣 根据优惠卷类型进行判断 如果优惠卷类型为立减，取等值货币字段 如果类型是满减，取等值货币字段，最低消费字段 如果类型是折扣，取折扣百分比字段 找到满足条件的优惠卷放入到临时字典 2.4 处理绑定课程的优惠卷: 2.5 优惠卷绑定的课程ID 2.6 优惠卷ID 2.7 获得优惠卷类型：满减，立减，折扣 2.8 根据优惠卷类型进行判断 如果优惠卷类型为立减，取等值货币字段 如果类型是满减，取等值货币字段，最低消费字段 如果类型是折扣，取折扣百分比字段 2.9 将优惠卷课程ID与用户传入的课程ID进行对比 如果不在字典，说明此优惠卷不可使用 2.10 将可以使用的优惠卷设置到指定的课程字典中 3 将绑定优惠券课程+全站优惠券 写入到redis（结算中心） 3.1 将绑定课程的优惠卷放入到redis 3.2 将全站优惠券写入到redis 修改优惠信息 1 用户提交要修改的优惠券 2 修改全站优惠券，课程ID无，优惠券ID为0 不使用优惠券情况，将全站优惠券默认ID修改为0 3 课程ID无，优惠券不为0 获取全局支付优惠券的字典 判断用户选择的优惠券是否合法 优惠券不存在，提示优惠券不合法 如果存在，修改全局优惠券字典的默认值 4 修改课程优惠券 优惠券ID不存在，修改默认课程优惠券ID为0 优惠券不为空，使用优惠当ID与用户优惠券字典对比 不存在提示不存在 存在修改默认的课程ID，默认值 展示所有优惠券信息 获得用户ID及课程ID取得redis中的绑定课程优惠券和全局优惠券进行遍历 "}}